\documentclass[12pt]{article}
\usepackage{geometry} % see geometry.pdf on how to lay out the page. There's lots.
\geometry{a4paper} % or letter or a5paper or ... etc
\usepackage{graphicx}
\def\SSEnext{SSE\kern-.1em\lower.5ex\hbox{\footnotesize next}\kern+.2ex}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{0.1in}

\title{\SSEnext Modular Device Support Tutorial and Reference}
\author{Dave Astels}

\begin{document}

\maketitle

\section{Introduction}

The goal of this document is to walk you through the process of
creating support for a new device. We will go through declaring the
payload structure and the api, and trace through the use of them from
the Go app to the device and back.

We will use a very simple mouse device for this. The device has dual
settable sensitivity, with an RGB indicator LED to indicate which is active, and
an RGB logo LED.

To start we'll create a device:

\begin{verbatim}
(device 0x1469
)
\end{verbatim}

The argument to \verb|def-device| is the product ID of the device
being described.

Notice that we have several RGB LEDs on the device.  If these will be
the same, we'll want to create a structure that can be reused:

\begin{verbatim}
(struct led
  (field red uint8)
  (field green uint8)
  (field blue uint8))
\end{verbatim}

Next up is the CPI setting, which consists of a 16-bit value and an
LED color. Assume the firmware doesn't allow you to set the cpis
individually. Rather you set the configuration of the sensor that
contains the two CPI settings, and which is being used (and probably other settings, in real
life). The firmware spec will specify the valid values which we can
declare here; they will be used to validate values being send to the
device:

\begin{verbatim}
(struct cpi
  (field value uint16)
  (field indicator led))

(struct sensor
  (field current uint8)
  (field cpis cpi
    (repeat 2)))
\end{verbatim}

Notice how the \verb|indicator| field references the previously declared
\verb|led| structure.

Also, since we have two \verb|cpi| settings in the \verb|sensor| we
need to indicate that by using the \verb|repeat| clause.

Finally we have the logo color setting, which simply wraps an
\verb|led| structure.

\begin{verbatim}
(struct logo
  (field color led))
\end{verbatim}

So now the device declaration is:

\begin{verbatim}
(device mouse
  (struct led
    (field red uint8)
    (field green uint8)
    (field blue uint8))

  (struct cpi
    (field value uint16)
    (field indicator led))

  (struct sensor
    (field current uint8)
    (field cpis cpi
      (repeat 2)))

  (struct logo
    (field color led)))
\end{verbatim}

The top level structures reflect/define the json protocol that will be used by
the rest of the system when dealing with settings for this device.
{\em Top level} means the set of structures that are not simply there
to reduce duplication. In this case the json would look like this
(with sample values):

\begin{verbatim}
{
  "sensor":{
    "current":1,
    "cpis":[
      {
        "value":800,
        "indicator":{
          "red":0,
          "green":0,
          "blue":0
        }
      },
      {
        "value":3200,
        "indicator":{
          "red":255,
          "green":0,
          "blue":0
        }
      }
    ]
  },
  "logo":{
    "red":0,
    "green":200,
    "blue":0
  }
}
 
\end{verbatim}

The firmware spec will also provide information on value field values.
In this case let's assume the CPI values are 800, 2400, 3200, and
4800. Also, there are only two cpi settings, and the \verb|current-cpi| value is
constrained to be either 0 or 1.  We can use a \verb|values| clause
in each case:

\begin{verbatim}
(struct cpi
  (field index uint8
    (values 0 1))
  (field value uint16
    (values 800 2400 3200 4800))
  (field indicator led))
\end{verbatim}

Note that we could use a \verb|range| clause for the index since they
are contiguous values, but since there are only two options
\verb|values| would just as well.

The \verb|values| clause can also take a list of values. In the above
example we could have used:

\begin{verbatim}
(values '(800 2400 3200 4800))  
\end{verbatim}

Of course, we could use anything that evaluates to a list. If the
values were more regular, e.g.:
\verb|'(800 1600 2400 3200 4000 4800)|, we could use:

\begin{verbatim}
(values (map (lambda (x) (* x 800)) (interval 1 6)))
\end{verbatim}

That's not much of a savings, but shows what possible. We could go a
step further and extract the code to a function or constant:

\begin{verbatim}
(map cpi-values (map (lambda (x) (* x 800)) (interval 1 6)))

...

(values cpi-values)
\end{verbatim}

But keep in mind that just because you can doesn't mean you should.
Always strive for clarity and understandability, while removing
duplication as much as possible.

The \verb|led| structure doesn't require validation clauses because
the ranges for it's values are the full 0..255 range allowed by the
\verb|uint8| type. In this case there is implicit validation.

The next thing to consider is the structures required to read values
from the mouse. In some cases this incoming/read structure will differ
from the outrgoing/write structure. In these cases we can declare each
varient. Let's take a case where we could write a specific cpi
setting, by passing in index field. Assuming that the index field
isn't part of the returned CPI structure, we would need:

\begin{verbatim}
(struct cpi
  (outgoing
    (field index uint8
      (values 0 1))
    (field value uint16
      (values 800 2400 3200 4800))
    (field indicator led))
  (incoming
    (field value uint16)
    (field indicator led)))
\end{verbatim}

Notice that we don't put validations in the incoming structure.

OK, back to our main example.  We've declared the data structures
involved, now we have to declare the API used to communicate with the
deviceAPI layer. An API can have a \verb|read| clause and/or a
\verb|write| clause. They have a common structure and declare how to
talk to the device library when reading from or writing to the device,
respectively.

\begin{verbatim}
(api sensor
  (read HID (chunk 0 32 (replace-byte payload 0 0x13)))
  (write HID (chunk 0 32 (replace-byte payload 0 0x03))))
\end{verbatim}



Now let's look at what happens when it get
read in and processed. Figure~\ref{fig:sensornested} shows the
internal structure resulting from the declaration.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[width=6in]{sensor_nested.png} 
\caption{Nested sensor structure}
\label{fig:sensornested}
\end{figure}

This structure provides the system with information relating to the
fields, types, and nesting. To be usefull for processing json and
generating/interpretting bytearrays, it needs to be flattened with
referneces to other types inlines, arrays expanded, etc. This will
result in the structure shown in Fig.~\ref{fig:sensorflattened}.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[height=6in]{sensor_flattened.png} 
\caption{Flattened sensor structure}
\label{fig:sensorflattened}
\end{figure}

Here we have each field instantiated, and ordered. Notice the offset
and size bits of data in each field. These are computed based on the
type of each field and relate to the bytearray that will be generated
or torn apart based on this structure. Note that there may be space
between fields in the byte array due to alignment constraints.

The bytearray for our sensor example is shown in
Fig.~\ref{fig:sensorbytearray}.

\begin{figure}[htbp] %  figure placement: here, top, bottom, or page
   \centering
   \includegraphics[]{sensor_bytearray.png} 
\caption{Sensor bytearray}
\label{fig:sensorbytearray}
\end{figure}


Also, each field object contains it's path in the original
structure, and also the associated json structure. This is used to
extract the associated data from the json struct when building the
bytearray, as well as place values into the json structure from the
bytearray when getting information from the device.

\section{Reference}

\noindent{\bf\large\verb|(device <id> <sexpr>...)|}

This creates a device declaration with the given \verb|id|. This
creates a a local environment for the device declaration and evaluates
all the \verb|sexpr| in that environment. Any valid code can appear in
the declaration, and it's effects are local to the device's
environment.

\noindent{\bf\large\verb|(usage <u>)|}  
\noindent{\bf\large\verb|(usage-page <u>)|}

These set the \verb|usage| and \verb|usage page| values, respecively, of the device.

\noindent{\bf\large\verb|(extends <parent-id>)|}

In the case where the device being declared is simply a spin (or
extension) of an existing device you can declare the relationship by
providing the PID of the parent device. And example of this is the
Sensei[RAW] family of products. All structures, apis, and functions
declared in the parent device are inherited by child devices, and can
be overridden as expected. Parent device filenames have to end in
\verb|_base.device|, e.g. \verb|sensei_raw_base.device|. This causes
them to be loaded first, thus being present when the child devices are
loaded.

\noindent{\bf\large\verb|(struct <name> [<alignment>] <field-decl>...)|}

This defines a structure which is used to translate between the JSON
data used by core and the bytearrays used by devicelib and drivers. If
the struct corresponds to a top level key in the JSON, the name you
give to the structure matches that key exactly.

The \verb|field-decl| section defines the structure of the JSON and
bytearray when writing to, or reading from, the device.

\noindent{\bf\large\verb|(aligned)|}  
\noindent{\bf\large\verb|(unaligned)|}

Sometimes the bytearray used to communicate with ther device will need
to be aligned to be aligned: words need to start on 2-byte boundaries,
and longs on 4-byte boundaries. To accomplish this the system adds
padding bytes to each field as necessary. This is the default
operation. To surpress this you can use \verb|(unaligned)| as the
first statement of the \verb|struct| declaration. You can also use
\verb|(aligned)| if you want to be explicit about it.


\noindent{\bf\large\verb|(outgoing <field>...)|}  
\noindent{\bf\large\verb|(incoming <field>...)|}  
\noindent{\bf\large\verb|(common <field>...)|}  
\noindent{\bf\large\verb|<field>...|}

The *field-decl* can take several forms. You can have one or both of
the first two options, **or** one of the last two. If you explicitly
need formats for writing and reading you can use the \verb|outgoing|
and \verb|incoming| forms, respectively, to declare them. If both are
the same, the \verb|common| form can be used. Alternatively, the
fields can simply be listed without any nesting.

Typically, this last form is used unless write & read have different
formats.

The \verb|fields| in the above is a non-empty sequence of field
declarations.

\noindent{\bf\large\verb|(field <name> <type> [<constant>] [<repeat>] [<validation>] [<json-transforms>])|}

The \verb|name| of a field corresponds to it's key in the JSON
structure. It's \verb|type| is either a primitive type or the name of
a previous structure. Currently supported primitive types are:
\verb|uint8|, \verb|uint16|, and \verb|uint32|.

\noindent{\bf\large\verb|(constant <value>)|}

Sometimes you need to place values into the bytearray that do not
appear in the JSON data. You can declare the field as usual (i.e. with
a name and type defined how many buyes are required) and supply a
value by using \verb|constant|.

\noindent{\bf\large\verb|(repeat <count>)|}

The optional \verb|repeat| clause is used when two or more repetitions
of the field are required. This corresponds to an array in the JSON.

Validation can be added to a field declaration. A panic will be raised if values provided in the JSON voilate these validations. There are two types of validation: values and ranges.

\noindent{\bf\large\verb|(values <value>...)|}  
\noindent{\bf\large\verb|(values <list>)|}

The optional \verb|values| clause provides a set of legal numeric values
for the field. These must match the field's type. Either a literal
sequence of values of a list of values can be provided. Notably, the
list can be any Lisp code that, when evaluated, results in an
appropriate list.

\noindent{\bf\large\verb|(range <low> <high>)|}

The optional \verb|range| clause provides an inclusive range of legal
values.

\noindent{\bf\large\verb|(exclude <low> <high>)|}

The optional \verb|exclude| clause provides an inclusive range of illegal
values.

The \verb|range| and \verb|exclude| clauses can be combined to create
two discrete ranges of legal values (or you can think of it as a range
of legal values with a hole in it).


\bibliographystyle{plain}
\bibliography{lisp}

\end{document}
