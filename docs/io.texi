@node Input/Output
@chapter Input/Output
@anchor{inputoutput}

@node open-input-file filename
@subsection (open-input-file @emph{filename})
@anchor{open-input-file}
Takes a @emph{filename} referring to an existing file and returns an
input port capable of delivering characters from the file.

@node open-output-file filename [append?]
@subsection (open-output-file @emph{filename} [@emph{append?}])
@anchor{open-output-file}
Takes a @emph{filename} referring to an output file to be created and
returns an output port capable of writing characters to a new file by
that name.

If @emph{append?} is given and not @code{@hashchar{}f}, the file is opened in
append mode. In this mode, the contents of the file are not overwritten;
instead any characters written to the file are appended to the end of
the existing contents. If the file does not exist, append mode creates
the file and writes to it in the normal way.

@node close-port port
@subsection (close-port @emph{port})
@anchor{close-port}
Closes @emph{port} and returns an unspecified value. The associated file
is also closed.

@node write-bytes byte-array output-port
@subsection (write-bytes @emph{byte-array} @emph{output-port})
@anchor{write-bytes}
Writes @emph{byte-array} to @emph{output-port} as a stream of raw bytes.
Most usefull for interacting with external devices via serial/usb ports.

@node write-string string [output-port]
@subsection (write-string @emph{string} [@emph{output-port}])
@anchor{write-string}
Writes @emph{string} to @emph{output-port}, performs discretionary
output flushing, and returns an unspecified value.

@node newline [output-port]
@subsection (newline [@emph{output-port}])
@anchor{newline}
Writes an end-of-line to @emph{output-port}, performs discretionary
output flushing, and returns an unspecified value.

@node write object [output-port]
@subsection (write @emph{object} [@emph{output-port}])
@anchor{write}
Writes a written representation of @emph{object} to @emph{output-port},
and returns an unspecified value. If @emph{object} has a standard
external representation, then the written representation generated by
@code{write} shall be parsable by @code{read} into an equivalent object.
Thus strings that appear in the written representation are enclosed in
doublequotes, and within those strings backslash and doublequote are
escaped by backslashes. @code{write} performs discretionary output
flushing and returns an unspecified value.

@node read-string [input-port]
@subsection (read-string [@emph{input-port}])
@anchor{read-string}
Reads characters from @emph{input-port} until it finds a terminating
character or encounters end of line. The port is updated to point to the
terminating character, or to end of line if no terminating character was
found. @code{read-string} returns the characters, up to but excluding
the terminating character, as a newly allocated string.

@node read [input-port]
@subsection (read [@emph{input-port}])
@anchor{read}
Converts external representations of Scheme objects into the objects
themselves. read returns the next object parsable from
@emph{input-port}, updating @emph{input-port} to point to the first
character past the end of the written representation of the object. If
an end of file is encountered in the input before any characters are
found that can begin an object, read returns an end-of-file object. The
@emph{input-port} remains open, and further attempts to read will also
return an end-of-file object. If an end of file is encountered after the
beginning of an object's written representation, but the written
representation is incomplete and therefore not parsable, an error is
signalled.

@node eof-object? object
@subsection (eof-object? @emph{object})
@anchor{eof-objectp}
Returns @code{@hashchar{}t} if @emph{object} is an end-of-file object; otherwise
returns @code{@hashchar{}f}.

@node format destination control-string argument@dots{}
@subsection (format @emph{destination} @emph{control-string}
@emph{argument}@dots{})
@anchor{format}
Writes the characters of @emph{control-string} to @emph{destination},
except that a tilde (@code{~}) introduces a format directive. The
character after the tilde, possibly preceded by prefix parameters and
modifiers, specifies what kind of formatting is desired. Some directives
use an @emph{argument} to create their output; the typical directive
puts the next @emph{argument} into the output, formatted in some special
way. It is an error if no @emph{argument} remains for a directive
requiring an @emph{argument}.

The output is sent to @emph{destination}. If @emph{destination} is
@code{@hashchar{}f}, a string is created that contains the output; this string is
returned as the value of the call to @code{format}. If
@emph{destination} is @code{@hashchar{}t}, the output is sent to @code{stdout}. In
all other cases @code{format} returns an unspecified value. Otherwise,
destination must be an output port, and the output is sent there.

A format directive consists of a tilde (@math{\sim}), an optional prefix
parameter, an optional at-sign (@code{@@}) modifier, and a single
character indicating what kind of directive this is. The alphabetic case
of the directive character is ignored. The prefix parameters are
generally integers, notated as optionally signed decimal numbers.

In place of a prefix parameter to a directive, you can put the letter
@code{V} (or @code{v}), which takes an argument for use as a parameter
to the directive. Normally this should be an integer. This feature
allows variable-width fields and the like. You can also use the
character @code{#} in place of a parameter; it represents the number of
arguments remaining to be processed.

@code{~A}: The next argument, which may be any object, is printed as if
by write-line. @code{~<mincol>A} inserts spaces on the right, if
necessary, to make the width at least @code{mincol} columns. The
@code{@@} modifier causes the spaces to be inserted on the left rather
than the right.

@code{~S}: The next argument, which may be any object, is printed as if
by write (in as read-able format as possible). @code{~mincolS} inserts
spaces on the right, if necessary, to make the width at least mincol
columns. The @code{@@} modifier causes the spaces to be inserted on the
left rather than the right.

@code{~%}: This outputs a newline character. This outputs a
@code{@hashchar{}@backslashchar{}newline} character. @code{~n%} outputs n newlines. No argument
is used. Simply putting a newline in control-string would work, but
@code{~%} is often used because it makes the control string look nicer
in the middle of a program.

@code{~~}: This outputs a tilde; @code{~n~}: outputs n tildes.

@code{~newline}: Tilde immediately followed by a newline ignores the
newline and any following whitespace characters. With an @code{@@}, the
newline is left in place, but any following whitespace is ignored. This
directive is typically used when control-string is too long to fit
nicely into one line of the program:

@verbatim
(define (type-clash-error procedure arg spec actual)
   (format
    #t
    "~%Procedure ~S~%requires its %A argument ~
     to be of type ~S,~%but it was called with ~
     an argument of type ~S.~%"
    procedure arg spec actual))
(type-clash-error ’vector-ref
                  "first"
                  ’integer
                  ’vector)
@end verbatim

@verbatim
Procedure vector-ref
requires its first argument to be of type integer,
but it was called with an argument of type vector.
@end verbatim

Note that in this example newlines appear in the output only as
specified by the @math{\sim}% directives; the actual newline characters
in the control string are suppressed because each is preceded by a
tilde.


@c Local Variables:
@c mode: texinfo
@c End:
