# Generator Examples

This file is ported directly from Clojure's test.check

The following examples assume you have the following file loaded (which is loaded at startup in the standard distribution):

    lisp/gen_test.scm

For the most part, these are in order of simplest to most complex. They also
skip over some of the built-in, basic generators.

## A simple example

First, let's start with an example, suppose we want to test a sort function.
It's easy to come up with some trivial properties for our function, namely that
the output should be in ascending order. We also might want to make sure that
the count of the input is preserved. Our test might look like:

    (define (ascending? coll)
      (every (lambda (pair) (<= (car pair) (cadr pair)))
              (partition 2 1 coll)))
    
    (define property
      (prop/for-all (v (gen/list gen/int 10))
        (let ((s (sort v <)))
          (and (= (length v) (length s))
               (ascending? s)))))
    
    ;; test our property
    (check/run 100 property)
    ==> {result: true, num-tests: 100}

What if we were to forget to actually sort our list? The test will fail, and
then check/run will find the simplest example that caused a failure.
<!-- will try and find 'smaller' inputs that still cause the test -->
<!-- to fail. For example, the function might originally fail with input: -->
<!-- `[5 4 2 2 2]`, but check/run will shrink this down to `[0 -1]` (or `[1 0]`). -->

## Generators

In order to write our property, we'll use generators. A generator knows how to
generate random values for a specific type. The `gen_test `framework
 has many built-in generators, as well as combinators for creating
your own new generators. You can write sophisticated generators just by
combining the existing generators with the given combinators. As we write
generators, we can see them in practice with the `sample` function:

    (gen/sample gen/int)
    ==> (0 1 -1 0 -1 4 4 2 7 1)

we can ask for more samples:

    (gen/sample gen/int 20)
    ==> (0 1 1 0 2 -4 0 5 -7 -8 4 5 3 11 -9 -4 6 -5 -3 0)

You may notice that as you ask for more values, the 'size' of the generated
values increases. As check/run generates more values, it increases the
'size' of the generated values. This allows tests to fail early, for simple
values, and only increase the size as the test continues to pass.

### Compound generators

Some generators take other generators as arguments. For example the `vector`
and `list` generator:

    (gen/sample (gen/vector gen/uint))
    ==> (#() #() #(1) #(1) #() #() #(5 6 6 2 0 1) #(3 7 5) #(2 0 0 6 2 5 8) #(9 1 9 3 8 3 5))

    (gen/sample (gen/list gen/boolean))
    ==> (() () (#f) (#f #t #f) (#f #t) (#f #t #t #t) (#t) (#f #f #t #t) () (#t))

    (gen/sample (gen/alist gen/symbol gen/boolean) 5)
    ==> (((z . #f)) ((k . #t)) ((v8Z . #f)) ((E . #f) (uww . #f) (s . #t)))

Sometimes we'll want to create heterogeneous collections. The `tuple` generator
allows us to to do this:

    (gen/sample (gen/tuple gen/uint gen/boolean gen/string) 5)
    ==> ((1 #f "_YD\N") (3 #t "j3+ZQ") (4 #f "toD2%") (3 #t "L(yy\"") (0 #t "%V8og"))

### Generator combinators

There are several generator combinators, we'll take a look at `fmap`,
`such-that` and `bind`.

#### fmap

`fmap` allows us to create a new generator by applying a function to the
values generated by another generator. Let's say we want to to create a set of
natural numbers. We can create a set by calling `set` on a vector. So let's
create a vector of natural numbers (using the `nat` generator), and then use
`fmap` to call `set` on the values:

    (define (sum l) (reduce + 0 l))
    (gen/sample (gen/fmap sum (gen/vector gen/uint)) 10)
    ==> (0 4 31 57 52 39 98 72 122 76)

#### such-that

`such-that` allows us to create a generator that passes a predicate. Imagine we
wanted to generate non-empty lists, we can use `such-that` to filter out empty
lists:

    (define (not-empty x) (> (length x) 0))
    (gen/sample (gen/such-that not-empty (gen/list gen/boolean)))
    ==> ((#t) (#t) (#f) (#t #f) (#f) (#t) (#f #f #t #t) (#f) (#t) (#f))

#### bind

`bind` allows us to create a new generator based on the _value_ of a previously
created generator. For example, say we wanted to generate a vector of keywords,
and then choose a random element from it, and return both the vector and the
random element. `bind` takes a generator, and a function that takes a value
from that generator, and creates a new generator.

    (def keyword-vector (gen/such-that not-empty (gen/vector gen/keyword)))
    (def vec-and-elem
      (gen/bind keyword-vector
                (fn [v] (gen/tuple (gen/elements v) (gen/return v)))))
    
    (gen/sample vec-and-elem 4)
    ==> (#(va: #(va: b4:)) #(Zu1: #(w: Zu1:)) #(2: #(2)) #(27X: #(27X: KW:)))

This allows us to build quite sophisticated generators.

### Record generators

Let's go through an example of generating random values of our own
`defrecord`s. Let's create a simple user record:

    (define-record User user-name: user-id: email: active?:)
    
    (new:> User new: '("reiddraper" 15 "reid@example.com" #t))
    ==> {proto*: User
         user-name: "reiddraper"
         user-id: 15
         email: "reid@example.com"
         active?: #t}

We can use the `User.new` helper function to construct our user. First, let's
look at the generators we'll use for the arguments. For the user-name, we can
just use an alphanumeric string, user IDs will be natural numbers, we'll
construct our own simple email generator, and we'll use booleans to denote
whether the user account is active. Let's write a simple email address
generator:

    (define domain (gen/elements '("gmail.com" "hotmail.com" "computer.org")))

    (define email-gen
      (gen/fmap (lambda (name-and-domain-name)
                  (let ((name (car name-and-domain-name))
                        (domain-name (cadr name-and-domain-name)))
                    (str name "@" domain-name)))
                (gen/tuple (gen/string gen/alphanum-char 10) domain)))
    
    (last (gen/sample email-gen))
    ==> "CW6161Q6@hotmail.com"

To put it all together, we'll use `fmap` to call our record constructor, and
`tuple` to create a vector of the arguments:

    (define user-gen
      (gen/fmap (lambda (args) (new:> User args))
                (gen/tuple (gen/string gen/alphanum-char 10)
                           gen/uint
                           email-gen
                           gen/boolean)))
    
    (last (gen/sample user-gen))
    ==> {active?: #t email: "YL7hLn4YUK@computer.org" proto*: User user-id: 102 user-name: "rfjDoMRACR"}

<!-- ### Recursive generators -->

<!-- --- -->
<!-- NOTE: Writing recursive generators was significantly simplified in version -->
<!-- 0.5.9. For the old way, see the [0.5.8 -->
<!-- documentation](https://github.com/clojure/test.check/blob/v0.5.8/doc/intro.md#recursive-generators). -->

<!-- --- -->

<!-- Writing recursive, or tree-shaped generators is easy using `gen/recursive-gen`. -->
<!-- `recursive-gen` takes two arguments, a compound generator, and a scalar -->
<!-- generator. We'll start with a simple example, and then move into something more -->
<!-- complex. First, let's generate a nested vector of booleans. So our compound -->
<!-- generator will be `gen/vector` and our scalar will be `gen/boolean`: -->

<!-- ```clojure -->
<!-- (def nested-vector-of-boolean (gen/recursive-gen gen/vector gen/boolean)) -->
<!-- (last (gen/sample nested-vector-of-boolean 20)) -->
<!-- ;; => [[#t] [#f #t #t] [#f]] -->
<!-- ``` -->

<!-- Now, let's make our own, JSON-like generator. We'll allow `gen/list` and -->
<!-- `gen/map` as our compound types and `gen/int` and `gen/boolean` as our scalar -->
<!-- types. Since `recursive-gen` only accepts one of each type of generator, we'll -->
<!-- combine our compound types with a simple function, and the two scalars with -->
<!-- `gen/one-of`. -->

<!-- ```clojure -->
<!-- (def compound (fn [inner-gen] -->
<!--                   (gen/one-of [(gen/list inner-gen) -->
<!--                                (gen/map inner-gen inner-gen)]))) -->
<!-- (def scalars (gen/one-of [gen/int gen/boolean])) -->
<!-- (def my-json-like-thing (gen/recursive-gen compound scalars)) -->
<!-- (last (gen/sample my-json-like-thing 20)) -->
<!-- ;; => -->
<!-- ;; (() -->
<!-- ;;  {{4 -11, 1 -19} (#f), -->
<!-- ;;  {} {1 6}, -->
<!-- ;;  (#f #f) {#t -3, #f #f, -7 1}}) -->
<!-- ``` -->

<!-- And we see we got a list whose first element is the empty the list. The second -->
<!-- element is a map with int keys and values. Etc. -->

## Integers 5 through 9, inclusive

    (define five-through-nine (gen/choose 5 9))
    (gen/sample five-through-nine)
    ==> (6 5 9 5 7 7 6 9 7 9)


## A random element from a vector

    (define languages (gen/elements '("clojure" "haskell" "erlang" "scala" "python")))
    (gen/sample languages)
    ==> ("clojure" "scala" "clojure" "haskell" "clojure" "erlang" "erlang" "erlang" "haskell" "python")


## An integer or nil

    (define int-or-nil (gen/one-of gen/int (gen/return nil)))
    (gen/sample int-or-nil)
    ==> (nil 0 -2 nil nil 3 nil nil 4 2)

## An integer 90% of the time, nil 10%

    (define mostly-ints (gen/weighted '((9 . gen/int) (1 . (gen/return nil)))))
    (gen/sample mostly-ints)
    ==> (0 -1 nil 0 -2 0 6 -6 8 7)

## Even, positive integers

    (define even-and-positive (gen/fmap (lambda (x) (* 2 x)) gen/uint))
    (gen/sample even-and-positive 20)
    ==> (0 0 2 0 8 6 4 12 4 18 10 0 8 2 16 16 6 4 10 4)

## Powers of two

    ;; generate exponents with gen/uint (strictly positive integers),
    ;; and then apply the lambda to them
    (define (two-raised-to x) (expt 2 x))
    (define powers-of-two (gen/fmap two-raised-to (gen/choose 0 32)))
    (gen/sample powers-of-two)
    ==> (2 2 8 16 16 64 16 2 4 4)

## Sorted seq of integers

    ;; apply the sort function to each generated vector
    (define (sort< l) (sort l <))
    (define sorted-vec (gen/fmap sort< (gen/vector gen/byte)))
    (gen/sample sorted-vec)
    ==> (() (1) (2 2) (1 2 3) (1 2 4) (2 3 3 4) (1) (0 1 3 4 6) (0 2 8) (1))

## An integer and a boolean

    (define int-and-boolean (gen/tuple gen/byte gen/boolean))
    (gen/sample int-and-boolean)
    ==> ((30 #f) (16 #f) (227 #f) (112 #t) (127 #t) (78 #t) (148 #f) (43 #f) (30 #f) (184 #f))

## Any number but 5

    (define anything-but-five (gen/such-that (lambda (x) (neqv? x 5)) gen/byte))
    (gen/sample anything-but-five)
    ==> (0 0 2 1 3 1 4 7 1 6)

It's important to note that `such-that` should only be used for predicates that
are _very_ likely to match. For example, you should _not_ use `such-that` to
filter out random vectors that are not sorted, as is this is exceedingly
unlikely to happen randomly. If you want sorted vectors, just sort them using
`gen/fmap` and `sort`.

## A vector and a random element from it

    (define val-and-elem (gen/bind (gen/list gen/int 5) (lambda (val) (gen/tuple (gen/return val) (gen/elements val)))))
    (gen/sample vector-and-elem)
    ==> (((-1) -1)
         ((0) 0)
         ((-1 -1) -1)
         ((2 0 -2) 2)
         ((0 1 1) 0)
         ((-2 -3 -1 1) -1)
         ((-1 2 -5) -5)
         ((5 -7 -3 7) 5)
         ((-1 2 2) 2)
         ((-8 7 -3 -2 -6) -3))

`gen/bind` and `gen/fmap` are similar: they're both binary functions that take
a generator and a function as arguments (though their argument order is
reversed). They differ in what the provided function's return value should be.
The function provided to `gen/fmap` should return a _value_. We saw that
earlier when we used `gen/fmap` to sort a vector. `sort` returns a normal
value. The function provided to `gen/bind` should return a _generator_. Notice
how above we're providing a function that returns a `gen/tuple` generator? The
decision of which to use depends on whether you want to simply transform the
_value_ of a generator (sort it, multiply it by two, etc.), or create an
entirely new generator out of it.

