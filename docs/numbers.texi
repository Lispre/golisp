@node Numerical Operations
@section Numerical Operations
@anchor{numerical-operations}
@menu
* + number@dots{}::
* * number @dots{}::
* - number@dots{}::
* / number@dots{}::
* succ integer::
* 1+ integer::
* pred integer::
* -1+ integer::
* quotient n1 _n2::
* remiander n1 n2::
* modulo n1 n2::
* floor number::
* ceiling number::
* integer number::
* float number::
* number->string number [base]::
* string->number numeric-string [base]::
@end menu

@node + number@dots{}
@subsection (+ @emph{number}@dots{})
@anchor{plus}

@node * number @dots{}
@subsection (* @emph{number}@dots{})
@anchor{times}
These procedures return the sum or product of their arguments.

@verbatim
(+ 3 4)                 ==>  7
(+ 3)                   ==>  3
(+)                     ==>  0
(* 4)                   ==>  4
(*)                     ==>  1
@end verbatim

@node - number@dots{}
@subsection (- @emph{number}@dots{})
@anchor{subtract}

@node / number@dots{}
@subsection (/ @emph{number}@dots{})
@anchor{divide}
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left. With one argument,
however, they return the additive or multiplicative inverse of their
argument.

@verbatim
(- 3 4)                 ==>  -1
(- 3 4 5)               ==>  -6
(- 3)                   ==>  -3
(/ 3 4 5)               ==>  0.15
(/ 4)                   ==>  0.25
@end verbatim

Note that @code{/} always preforms floating point division. If the
quotient is a whole number it will be returned as an integer.

@verbatim
(/ 12 5)                ==>  2.4
(/ 12 2.4)              ==>  5
@end verbatim

@node succ integer
@subsection (succ @emph{integer})
@anchor{succ }

@node 1+ integer
@subsection (1+ @emph{integer})
@anchor{one-plus}
Equivalent to @code{(+ integer 1)}.

@node pred integer
@subsection (pred @emph{integer})
@anchor{pred}

@node -1+ integer
@subsection (-1+ @emph{integer})
@anchor{minus-one-plus}
Equivalent to @code{(- integer 1)}.

@node quotient n1 _n2
@subsection (quotient @emph{n1} _n2)
@anchor{quotient}

@node remiander n1 n2
@subsection (remiander @emph{n1} @emph{n2})
@anchor{remiander}

@node modulo n1 n2
@subsection (modulo @emph{n1} @emph{n2})
@anchor{modulo}
These procedures implement number-theoretic (integer) division: for
positive integers @emph{n1} and @emph{n2}, if @emph{n3} and @emph{n4}
are integers such that

@verbatim
n1 = (n2 * n3) + n4

0 <= n4 < n2
@end verbatim

then

@verbatim
(quotient n1 n2)        ==>  n3
(remainder n1 n2)       ==>  n4
(modulo n1 n2)          ==>  n4
@end verbatim

for integers @emph{n1} and @emph{n2} with @emph{n2} not equal to 0,

@verbatim
(= n1
   (+ (* n2 (quotient n1 n2))
      (remainder n1 n2)))
                        ==>  #t
@end verbatim

The value returned by @code{quotient} always has the sign of the product
of its arguments. @code{remainder} and @code{modulo} differ on negative
arguments -- the @code{remainder} always has the sign of the dividend,
the @code{modulo} always has the sign of the divisor:

@verbatim
(modulo 13 4)           ==>  1
(remainder 13 4)        ==>  1

(modulo -13 4)          ==>  3
(remainder -13 4)       ==>  -1

(modulo 13 -4)          ==>  -3
(remainder 13 -4)       ==>  1

(modulo -13 -4)         ==>  -1
(remainder -13 -4)      ==>  -1
@end verbatim

The @code{%} function is an alias for @code{remainder}.

@node floor number
@subsection (floor @emph{number})
@anchor{floor}
Returns the greatest integer value less than or equal to @emph{number}.
@emph{number} can be an integer or float. Return value is a float.

@verbatim
(floor 3.4)             ==> 3.0
(floor -3.4)            ==> -4.0
(floor 3)               ==> 3.0
@end verbatim

@node ceiling number
@subsection (ceiling @emph{number})
@anchor{ceiling}
Returns the largest integer value greater than or equal to
@emph{number}. @emph{number} can be an integer or float. Return value is
a float.

@verbatim
(ceiling 3.4)           ==> 4.0
(ceiling -3.4)          ==> -3.0
(ceiling 3)             ==> 3.0
@end verbatim

@node integer number
@subsection (integer @emph{number})
@anchor{integer}
Returns the integer value of @emph{number}. If it is an integer, it is
simply returned. However, if it is a float the integer part is returned.

@verbatim
(integer 5)             ==> 5
(integer 5.2)           ==> 5
(integer -5.8)          ==> -5
@end verbatim

@node float number
@subsection (float @emph{number})
@anchor{float}
Returns the float value of @emph{number}. If it is a float, it is simply
returned. However, if it is an integer the corresponding float is
returned.

@verbatim
(float 5)               ==> 5.0
@end verbatim

Note that converting a float to a string for printing using the format
@code{%g} to use the minimum number of characters so @code{5.0} will
actually print as @code{5}.

@node number->string number [base]
@subsection (number->string @emph{number} [@emph{base}])
@anchor{number-string}
Converts @emph{number} (first converted to an integer) to a string, in
the given @emph{base}. Allowed bases are 2, 8, 10, and 16. If the base
is omitted, 10 is used. No base prefixes (e.g. @code{@hashchar{}x} for base 16)
are added.

@verbatim
(number->string 42)    ==> "42"
(number->string 42 2)  ==> "101010"
(number->string 42 8)  ==> "52"
(number->string 42 10) ==> "42"
(number->string 42 16) ==> "2a"
(number->string 42 15) ==> ERROR number->string: unsupported base 15
@end verbatim

@node string->number numeric-string [base]
@subsection (string->number @emph{numeric-string} [@emph{base}])
@anchor{string-number}
Converts @emph{numeric-string} to an integer, in the given base. Allowed
bases are 2, 8, 10, and 16. If the base is omitted, 10 is used. No base
prefixes (e.g. @code{@hashchar{}x} for base 16) are allowed. Specifying an
unsupported base will result in @code{0}.

@verbatim
(string->number "42")       ==> 42
(string->number "101010" 2) ==> 42
(string->number "52" 8)     ==> 42
(string->number "42" 10)    ==> 42
(string->number "2a" 16)    ==> 42
(string->number "42" 15)    ==> ERROR number->string: unsupported base 15
@end verbatim

@node Comparisons
@section Comparisons
@anchor{comparisons}
All comparison operations work with floating point numbers as well.
@menu
* < number1 number2 @dots{}::
* > number1 number2 @dots{}::
* <= number1 number2 @dots{}::
* >= number1 number2 @dots{}::
* zero? number::
* positive? number::
* negative? number::
* odd? number::
* even? number::
* min number@dots{}::
* min number@dots{}::
* max number@dots{}::
* max number@dots{}::
* log number::
@end menu

@node < number1 number2 @dots{}
@subsection (< @emph{number1} @emph{number2} @dots{})
@anchor{less-than}

@node > number1 number2 @dots{}
@subsection (> @emph{number1} @emph{number2} @dots{})
@anchor{greater-than}

@node <= number1 number2 @dots{}
@subsection (<= @emph{number1} @emph{number2} @dots{})
@anchor{less-than-equal}

@node >= number1 number2 @dots{}
@subsection (>= @emph{number1} @emph{number2} @dots{})
@anchor{greater-than-equal}
These procedures return @code{@hashchar{}t} if their arguments are (respectively):
equal (two alternatives), not equal (two alternatives), monotonically
increasing, monotonically decreasing, monotonically nondecreasing, or
monotonically nonincreasing. They return @code{@hashchar{}f} otherwise. Note that
@code{<}, @code{>}, @code{<=}, and @code{>=} can take more than 2
arguments.

@node zero? number
@subsection (zero? @emph{number})
@anchor{zerop}

@node positive? number
@subsection (positive? @emph{number})
@anchor{positivep}

@node negative? number
@subsection (negative? @emph{number})
@anchor{negativep}

@node odd? number
@subsection (odd? @emph{number})
@anchor{oddp}

@node even? number
@subsection (even? @emph{number})
@anchor{evenp}
These numerical predicates test a number for a particular property,
returning @code{@hashchar{}t} or @code{@hashchar{}f}.

@node min number@dots{}
@subsection (min @emph{number}@dots{})
@anchor{min}

@node min numberlist
@subsection (min (@emph{number}@dots{}))
@anchor{min-numberlist}

@node max number@dots{}
@subsection (max @emph{number}@dots{})
@anchor{max}

@node max numberlist
@subsection (max (@emph{number}@dots{}))
@anchor{max-numberlist}
These procedures return the maximum or minimum of their arguments. Note
that the arguments can be a series of numbers or a list of numbers:

@verbatim
(min 3 7 1 2)     ==> 1
(min '(3 7 1 2))  ==> 1
@end verbatim

@node log number
@subsection (log @emph{number})
@anchor{log}
This computes the natural logarithm of @emph{number} @strong{(not the
base ten logarithm)}. An integer argument will be converted to a float.
The result is always a float.


@c Local Variables:
@c mode: texinfo
@c End:
