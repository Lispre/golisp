\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename golisp-ref
@settitle SteelSeries GoLisp v1.1: Language Reference
@c %**end of header

@copying
This manual is for Golisp (version 1.1, updated
May 2017).

Copyright @copyright{} 2013-2016 SteelSeries.
Copyright @copyright{} 2016-2017 Dave Astels.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with no Front-Cover Texts and no Back-Cover Texts.
A copy of the license is included in the section entitled "GNU Free
Documentation License."
@end quotation
@end copying

@dircategory Programming Languages
@direntry
* GoLisp Reference: (golisp-ref).
                                Reference Manual
@end direntry


@titlepage
@title GoLisp v1.1 Language Reference
@author Dave Astels
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnothtml
@shortcontents
@end ifnothtml
@contents

@ifnottex
@node Top, Acknowledgements, (dir), (dir)
@top GoLisp v1.1: Language Reference

@insertcopying
@end ifnottex

@menu
* Acknowledgements::
* Overview::
* Running GoLisp::
* Data types::
* Special Forms::
* Type tests::
* Equivalence Predicates::
* Logical::
* Binary::
* Characters::
* Strings::
* Lists::
* Vectors::
* Associations::
* Frames::
* Miscellaneous Datatypes::
* Environments::
* Utility::
* Concurrency::
* Time and Date::
* Timers::
* Input/Output::
* Compiling::
* Testing::
* Extending GoLisp::
@end menu

@node Acknowledgements, Overview, Top, Top
@unnumbered Acknowledgements

Thanks go to SteelSeries for supporting the early work on
GoLisp. Chris Dargis, Tom Panfil, and Dave Tibbets contributed at
various times. Derek Palmer (at hash Rocket at the time) did work to
get it running on Linux. Special thanks go to SteelSeries software
engineers Joel Hunsley and Michael Lelli for their extensive efforts.

@node Overview, Special Forms, Acknowledgements, Top
@chapter Overview

GoLisp is a relatively complete implementation of the core
of a Scheme flavored Lisp. It supports a Scheme style of lexical
scoping, and includes a sizable number of core built-in functions. A
macro facility is included, as well. Other than some of the more
esoteric functions being missing, it should be usable for running code
from SICP.

The core of GoLisp is implemented in Go. The original reason for
building GoLisp was for use as an embeddable scripting environment for
our Go application in order to write declarative descriptions of
device communication prototcols. It is very easy to run Lisp code from
Go, either by loading Lisp source files, or by evaluating a string of
Lisp code. Furthermore, you can easily add primitive functions,
written in Go, in your application without having to edit any of the
GoLisp code.

Over time GoLisp has been used for a wider variety of purposes. Using
it as the implementation language for a Smarthome system on Raspberry
Pi class hardware was the impetus behind writing a more efficient
interpretor and a compiler.

GoLisp includes both an interpreter and bytecode compiler (and
matching execution engine). interpretted and compiled functions can be
intermixed relatively freely. There are some things that only work in
interpreted code. Over time these exceptions will be
removed. @xref{compiler}

@node Running GoLisp
@chapter Running GoLisp
@anchor{running-golisp}
Before GoLisp will work, the environment variable @code{GOLISPHOME} must
be defined as the path where the GoLisp @code{lisp} and @code{tools}
directories are located.

@verbatim
golisp [options] [files-to-load] [- program-args]
@end verbatim

@code{files-to-load} is a series of filenames or directories to be
loaded at startup (after the core library files are loaded). Any files,
and contained files, that end in ``.scm'' are loaded.

Supported @code{options}:

@itemize
@item @strong{@code{-r}} after files have been loaded, drop into the REPL.
This will cause GoLisp to NOT use the @code{main} function if it is
present.

@item @strong{@code{-t}} loads and runs tests contained
in the first @code{files-to-load}. Any remaining file arguments are
ignored. If a directory is specified then all test files in that
directory are run.

@item @strong{@code{-v}} use with @code{-t} to request verbose test output.

@item @strong{@code{-d "symbol=value"}} define something in the global
environment. The lisp equivalent is @code{(define symbol value)}.
@code{value} must be a literal constant.

@item @strong{@code{-e "code"}} after startup (i.e. the standard library has
loaded as well as any files specified on the command line), evaluate
@code{code}. The result is printed and, unless the REPL has been
requested, GoLisp exits. E.g.

@verbatim
>:golisp -e "(+ 2 3)"
==> 5
@end verbatim

@end itemize

Once options are processed and neither testing mode nor REPL mode have
been requested and no expression has been supplied to be evaluated, then
a function named @code{main} is look for. If found it is applied to the
values, if any, that follow the @code{-}.

@node Data types
@chapter Data types
@anchor{data-types}

@strong{Booleans} represent true and false. Boolean literals are
@code{@hashchar{}t} and @code{@hashchar{}f} for true and false, respectively. The only thing
that is considered to be logically false is @code{@hashchar{}f}. Everything else
is logically true, inluding 0 and the empty list, which may surprise
some.

@strong{Integers} are sixtyfour bit signed integers. Both decimal,
hexadecimal, and binary formats are supported. E.g. @code{26},
@code{@hashchar{}x1a}, @code{@hashchar{}x1A}, @code{@hashchar{}b00011001}.

@strong{Floats} are Go @code{float32} numbers. Accordingly they are
signed. All arithmetic functions with the exception of modulus work as
expected for both integers and floats. Numbers are coerced to floats as
required, specifically if any arguments are float, all are converted to
float and the result will be a float.

@strong{Characters} are single characters. This is differen than strings
with length 1.

@strong{Strings} are any sequence of characters other than @code{"}
enclosed by a pair of @code{"}, e.g. @code{"string"}. If you need to
have @code{"} in a string, use @code{@backslashchar{}"}.

@strong{Symbols} are simple identifiers, e.g. @code{function-name}.
Symbols follow the follow 3 simple rules:

@itemize

@item can only contain graphic characters (i.e. no control characters)

@item can not contain any of the characters: @code{();,"`&[]@{@}@backslashchar{}}

@item can not begin with a number or single quote

@item can not contain whitespace

@end itemize

Typically, @code{-} is used to separate words in a symbol, @code{_} is
used in special symbols (such as system use) to separate words and as a
prefix and suffix. The characters @code{?}, @code{!}, and @code{*} are
typically used as the final character of a function name to denote:

@strong{?} a predicate, e.g. @code{nil?}

@strong{!} a mutating function (changes the argument rather than
returning a modified copy), e.g. @code{set-car!}

@strong{*} a variant of the primary function, e.g. @code{flatten} (which
does a one level flattening of a list) and @code{flatten*} (which is a
recursive @code{flatten})

If a symbol ends with @code{:} it is what is called a @emph{naked
symbol}. It has no value other than itself. If it is evaluated, the
result is the symbol itself. This feature is utilized by frames.

@strong{Cons Cells}, aka @strong{Lists} are the central data type in
classic Lisp used both as dotted pairs @code{(a . b)} and general lists
@code{(a b)}. For an overview of cons cells and how to use them see [1],
[3], or @code{http://cs.gmu.edu/simsean/lisp/cons/}. Note that dotted
pairs @emph{require} spaces around the period; @code{(a.b)} is a list
containing the symbol @code{a.b}, not a cons cell with car of @code{a}
and cdr of @code{b}.

@strong{Bytearrays} are simply objects that encapsulate @code{[]byte}
objects. The difference is that there is syntactic support for them. Use
square braces surrounding a list of numbers between 0 and 255,
inclusive. For example: @code{[1 2 3 4 5]}. That format will parse to an
@code{object} containing a the Go bytearray (i.e. @code{[]byte}).
Bytearrays evaluate to themselves. There are also functions for doing
bytearray manipulation.

@strong{Channels} are simple objects that encapsulate Go `channel'
objects.

@strong{Vectors} are a more efficient alternative to lists when the
number of elements are known ahead of time and static. A vector can be
grown, but it's done explicitly with a function. Many enumeration and
access functions that accept a list (or lists) can be passed a vector
(or vectors) instead.

@strong{Ports} provide access to files for reading and writing.

@strong{Frames} are sets of named slots that hold arbitrary values,
including functions. Frames can @emph{inherit} from other frames in a
prototypical manner. They are inspired by the languages Self [4] and
Newtonscript [5].

@strong{Functions} are user defined procedures. They are covered in
detail later.

@strong{Macros} are user defined syntactic extensions. Note that GoLisp
macros are not yet hygenic, so use caution.

You can create an manipulate all of the above types in GoLisp. There are
two more types that are usable in GoLisp, but can only be created in Go.

@strong{Primitives} are just as they are in Lisp or Smalltalk: functions
written in the implementation language, in this case Go, and exposed as
functions in Lisp. The combinaion of primitives and objects allow you to
integrate with the underlying Go program. @strong{Special Forms} are
almost identical to primitives, except that they use normal evaluation
order instead of applicative order which functions and primitives use.

@strong{Objects} allow you to encapsulate a Go object (struct) in a Lisp
data object. There is no way to do this from Lisp itself, but is useful
when writing primitive functions (see below). The objects can be used as
any other object, but are opaque outside of primitives built to use
them.

@node Special Forms
@chapter Special Forms
@anchor{special-forms}
A special form is an expression that follows special evaluation rules.
This section describes the basic GoLisp special forms.
@menu
* Lambda Expressions::
* Lexical Binding::
* Definitions::
* Type Signatures::
* Top-Level Definitions::
* Internal Definitions::
* Assignments::
* Quoting::
* Macros::
* Sequencing::
* Conditionals::
* Iteration::
* Eval/Apply::
@end menu

@node Lambda Expressions
@section Lambda Expressions
@anchor{lambda-expressions}
@menu
* lambda formals sexpr@dots{}::
@end menu

@node lambda formals sexpr@dots{}
@subsection (lambda @emph{formals} @emph{sexpr}@dots{})
@anchor{lambda}
A @strong{lambda} expression evaluates to a procedure. The environment
in effect when the @strong{lambda} expression is evaluated is remembered
as part of the procedure; it is called the @emph{closing environment}.
When the procedure is later called with some arguments, the closing
environment is extended by binding the variables in the formal parameter
list to fresh locations, and the locations are filled with the arguments
according to rules about to be given. The new environment created by
this process is referred to as the @emph{invocation environment}.

Once the invocation environment has been constructed, the @emph{sexprs}
in the body of the @strong{lambda} expression are evaluated sequentially
in that environment. This means that the region of the variables bound
by the @strong{lambda} expression is all of the @emph{sexprs} in the
body. The result of evaluating the last @emph{sexpr} in the body is
returned as the result of the procedure call.

@emph{formals}, the formal parameter list, is often referred to as a
@emph{lambda list}.

The process of matching up formal parameters with arguments is somewhat
involved, but simpler than Scheme. There are two types of parameters,
and the matching treats each in sequence:

@strong{Required}

All of the @emph{required} parameters are matched against the arguments
first. If there are fewer arguments than required parameters, a
@code{wrong number of arguments} error is signalled; this error is also
signalled if there are more arguments than required parameters and there
are no further parameters.

@strong{Rest}

Finally, if there is a @emph{rest} parameter (there can only be one),
any remaining arguments are made into a list, and the @emph{rest}
parameter is bound to it. (If there are no remaining arguments, the
@emph{rest} parameter is bound to the empty list.)

In Scheme, unlike some other Lisp implementations, the list to which a
@emph{rest} parameter is bound is always freshly allocated. It has
infinite extent and may be modified without affecting the procedure's
caller.

A period, i.e. ``.'', is used to separate the @emph{rest} parameter (if
there is one) from the @emph{required} parameters. The ``.''
@strong{must} be surrounded by spaces.

@code{(a b c)}: @code{a}, @code{b}, and @code{c} are all required. The
procedure must be passed exactly three arguments.

@code{(a b . c)}: @code{a} and @code{b} are required and @code{c} is
rest. The procedure may be passed two or more arguments.

Some examples of @strong{lambda} expressions:

@verbatim
(lambda (x) (+ x x))            ==>  <function: unnamed>

((lambda (x) (+ x x)) 4)        ==>  8

(define reverse-subtract
  (lambda (x y)
    (- y x)))
(reverse-subtract 7 10)         ==>  3

(define foo
  (let ((x 4))
    (lambda (y) (+ x y))))
(foo 6)                         ==>  10
@end verbatim

@node Lexical Binding
@section Lexical Binding
@anchor{lexical-binding}
The three binding constructs @code{let}, @code{let*}, and @code{letrec},
give Scheme block structure. The syntax of the three constructs is
identical, but they differ in the regions they establish for their
variable bindings. In a @code{let} expression, the initial values are
computed before any of the variables become bound. In a @code{let*}
expression, the evaluations and bindings are sequentially interleaved.
And in a @code{letrec} expression, all the bindings are in effect while
the initial values are being computed (thus allowing mutually recursive
definitions).
@menu
* let variable init@dots{} sexpr@dots{}::
* let* variable init@dots{} sexpr@dots{}::
* letrec variable init@dots{} sexpr@dots{}::
@end menu

@node let variable init@dots{} sexpr@dots{}
@subsection (let ((@emph{variable} @emph{init})@dots{})
@emph{sexpr}@dots{})
@anchor{let}
The @emph{inits} are evaluated in the current environment (in some
unspecified order), the @emph{variables} are bound to fresh locations
holding the results, the @emph{sexprs} are evaluated sequentially in the
extended environment, and the value of the last @emph{sexpr} is
returned. Each binding of a @emph{variable} has the sequence of
@emph{sexpr} as its region.

GoLisp allows any of the @emph{inits} to be omitted, in which case the
corresponding @emph{variables} are unassigned.

Note that the following are equivalent:

@verbatim
(let ((variable init)...) expression...)
((lambda (variable...) expression...) init...)
@end verbatim

Some examples:

@verbatim
(let ((x 2) (y 3))
  (* x y))                              ==>  6

(let ((x 2) (y 3))
  (let ((foo (lambda (z) (+ x y z)))
        (x 7))
    (foo 4)))                           ==>  9
@end verbatim

@node let* variable init@dots{} sexpr@dots{}
@subsection (let* ((@emph{variable} @emph{init})@dots{})
@emph{sexpr}@dots{})
@anchor{letstar}
@code{let*} is similar to @code{let}, but the bindings are performed
sequentially from left to right, and the region of a binding is that
part of the `let*' expression to the right of the binding. Thus the
second binding is done in an environment in which the first binding is
visible, and so on.

Note that the following are equivalent:

@verbatim
(let* ((variable1 init1)
       (variable2 init2)
       ...
       (variablen initn))
   expression...)

(let ((variable1 init1))
  (let ((variable2 init2))
    ...
      (let ((variablen initn))
        expression...)
    ...))
@end verbatim

An example:

@verbatim
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))                           ==>  70
@end verbatim

@c @node letrec variable init@dots{} sexpr@dots{}
@c @subsection (letrec ((@emph{variable} @emph{init})@dots{})
@c @emph{sexpr}@dots{})
@c @anchor{letrec-variable-init-sexpr}
@c The @emph{variables} are bound to fresh locations holding unassigned
@c values, the @emph{inits} are evaluated in the extended environment (in
@c some unspecified order), each @emph{variable} is assigned to the result
@c of the corresponding @emph{init}, the @emph{expressions} are evaluated
@c sequentially in the extended environment, and the value of the last
@c @emph{expression} is returned. Each binding of a @emph{variable} has the
@c entire @code{letrec} expression as its region, making it possible to
@c define mutually recursive procedures.

@c Any of the @emph{inits} may be omitted, in which case the corresponding
@c @emph{variable} is unassigned.

@c @verbatim
@c (letrec ((even? (lambda (n)
@c                   (if (zero? n)
@c                       #t
@c                       (odd? (- n 1)))))
@c          (odd? (lambda (n)
@c                  (if (zero? n)
@c                      #f
@c                      (even? (- n 1))))))
@c (even? 88))                                 ==>  #t
@c @end verbatim

@c One restriction on @code{letrec} is very important: it shall be possible
@c to evaluated each @emph{init} without assigning or referring to the
@c value of any @emph{variable}. If this restriction is violated, then it
@c is an error. The restriction is necessary because Scheme passes
@c arguments by value rather than by name. In the most common uses of
@c @code{letrec}, all the @emph{inits} are @strong{lambda} expressions and
@c the restriction is satisfied automatically.

@node Definitions
@section Definitions
@menu
* define variable [sexpr]::
* define formals [doc-string] sexpr@dots{}::
* doc func::
@end menu

@node define variable [sexpr]
@subsection (define @emph{variable} [@emph{sexpr}])
@anchor{define}

@node define formals [doc-string] sexpr@dots{}
@subsection (define @emph{formals} [@emph{doc-string}]
@emph{sexpr}@dots{})
@anchor{define-func}
Definitions are valid in some but not all contexts where expressions are
allowed. Definitions may only occur at the top level of a program and at
the beginning of a lambda body (that is, the body of a @code{lambda},
@code{let}, @code{let*}, @code{letrec}, or procedure @code{define}
expression). A definition that occurs at the top level of a program is
called a @emph{top-level definition}, and a definition that occurs at
the beginning of a body is called an @emph{internal definition}.

The second form is used as a shorthand to define a procedure. The first
``required parameter'' in @emph{formals} is not a parameter but the
@emph{name} of the resulting procedure; thus @emph{formals} must have at
least one required parameter.

Hence the following are identical.

@verbatim
(define inc (lambda (x) (+ x 1)))
(define (inc x) (+ x 1))
@end verbatim

Using this form of define, a function that accepts a completely option
set of arguments can be made:

@verbatim
(define (f . args) args)

(f) ==> ()
(f 1) ==> (1)
(f 1 2 3) ==> (1 2 3)
@end verbatim

Please note: You can not currently define a lambda with completely
optional arguments.

Finally, you can also provide a documentation string between the
@emph{formals} and the body. For example:

@verbatim
(define (inc x) 
  "Increment the argument." 
  (+ x 1))
@end verbatim

@node doc func
@subsection (doc @emph{func})
@anchor{doc}
This retrieves the documentation for the function @emph{func}.

@node Type Signatures
@section Type Signatures
@anchor{type-signatures}
GoLisp provides basic, and optional, type checking for the arguments and
return values of user defined functions. Additionally, primtive
functions also have type checking on arguments, as appropriate.
@menu
* typedef fname arg-types@dots{} [-> return-type]::
* type func::
@end menu

@node typedef fname arg-types@dots{} [-> return-type]
@subsection (typedef @emph{fname} @emph{arg-types}@dots{} [-> @emph{return-type}])
@anchor{typedef}
This is similar to defining a function: @emph{fname} is the name of a
function that will be defined later (typicaly the next form) and
@emph{arg-types} correspond to its arguments). But with @code{typedef}
these are argument type specification, not argument names.

Argunment type specifications can take two forms: @emph{type} which can
be a string or symbol, or a set of types separated by a pipe (E.g.
@code{"integer|string"}) with no spaces. The latter must be a string.

When a function is passed a type that does not match its specified
type(s) an error is raised, similar to:

@verbatim
> (typedef less-than number number)
> (define (less-than x y) (\textless{} x y))
> (less-than 1 4.3)
==> #t
> (less-than 1 'a)
Error in evaluation: 
Evaling (less-than 1 'a). less-than argument 1 has the wrong type, 
                          expected float or integer but was given symbol
@end verbatim

A type specification can also include a type specification of the result
of the function. Note that the @code{->} is required. If a return type
is not provided, @code{anytype} is the default.

@verbatim
> (typedef less-than number number -> boolean)
> (define (less-than x y) (if (< x y) 'yes 'no))
> (less-than 1 4.3)
Error in evaluation: 
Evaling (less-than 1 4.3). less-than returns the wrong type, 
                           expected boolean but returned symbol
@end verbatim

The following types are supported:

@itemize
@item list
@item vector
@item sequence (equivalent to list|vector)
@item integer
@item float
@item number (equivalent to integer|float)
@item boolean
@item string
@item character
@item symbol
@item stringy (equivalent to string|symbol)
@item function
@item macro
@item primitive
@item procedure (equivalent to function|primitive)
@item boxedobject
@item frame
@item environment
@item port
@item anytype (equivalent to all the above typed combined)
@end itemize

Note that the @emph{list} type just requires a ConsCell; if a proper
list or other specific type is required, then either
@code{http://daveastels.typed.com/blog/code-contracts-in-golisp}
pre-conditions or explicit tests will be needed.

Putting all this together, a complete definition of a function would
look like:

@verbatim
(typedef inc number -> number)
(define (inc x) 
  "Increment the argument." 
  (+ x 1))
@end verbatim

@node type func
@subsection (type @emph{func})
@anchor{type}
This retrieves the type signature for the function @emph{func}.

@verbatim
(type inc)
==> (number -> number)
@end verbatim

@node Top-Level Definitions
@section Top-Level Definitions
@anchor{top-level-definitions}
A top-level definition,

@verbatim
(define variable sexpr)
@end verbatim

has essentially the same effect as this assignment expression, if
@emph{variable} is bound:

@verbatim
(set! variable expression)
@end verbatim

If @emph{variable} is not bound, however, @code{define} binds
@emph{variable} to a new location in the current environment before
performing the assignment (it is an error to perform a @code{set!} on an
unbound variable).

@verbatim
(define add3
  (lambda (x) (+ x 3)))                ==>  unspecified
(add3 3)                                ==>  6

(define first car)                      ==>  unspecified
(first '(1 2))                          ==>  1

(define bar)                            ==>  unspecified
bar                                     error--> Unassigned variable
@end verbatim

@node Internal Definitions
@section Internal Definitions
@anchor{internal-definitions}
An @emph{internal definition} is a definition that occurs at the
beginning of a @emph{body} (that is, the body of a @code{lambda},
@code{let}, @code{let*}, @code{letrec}, or procedure @code{define}
expression), rather than at the top level of a program. The variable
defined by an internal definition is local to the @emph{body}. That is,
@emph{variable} is bound rather than assigned, and the region of the
binding is the entire @emph{body}. For example,

@verbatim
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                        ==>  45
@end verbatim

A @emph{body} containing internal definitions can always be converted
into a completely equivalent @code{letrec} expression. For example, the
@code{let} expression in the above example is equivalent to

@verbatim
(let ((x 5))
  (letrec ((foo (lambda (y) (bar x y)))
           (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
@end verbatim

@node Assignments
@section Assignments
@anchor{assignments}
@menu
* set! variable object::
@end menu

@node set! variable object
@subsection (set! @emph{variable} @emph{object})
@anchor{set}
@emph{expression} is evaluated and the resulting value is stored in the
location to which @emph{variable} is bound. The value of the @code{set!}
expression is unspecified.

@emph{variable} must be bound either in some region enclosing the
@code{set!} expression, or at the top level. However, @strong{variable}
is permitted to be unassigned when the `set!' form is entered.

@verbatim
(define x 2)                            ==>  unspecified
(+ x 1)                                 ==>  3
(set! x 4)                              ==>  unspecified
(+ x 1)                                 ==>  5
@end verbatim

@node Quoting
@section Quoting
@anchor{quoting}
This section describes the expressions that are used to modify or
prevent the evaluation of objects.
@menu
* quote datum::
* quasiquote template::
@end menu

@node quote datum
@subsection (quote @emph{datum})
@anchor{quote}
@strong{(quote @emph{datum})} evaluates to @emph{datum}. @emph{datum}
may be any external representation of a GoLisp object. Use @code{quote}
to include literal constants in Scheme code.

@verbatim
(quote a)                               ==>  a
(quote #(a b c))                        ==>  #(a b c)
(quote (+ 1 2))                         ==>  (+ 1 2)
@end verbatim

@code{(quote datum)} may be abbreviated as @code{'datum}. The two
notations are equivalent in all respects.

@verbatim
'a                                      ==>  a
'#(a b c)                               ==>  #(a b c)
'(+ 1 2)                                ==>  (+ 1 2)
'(quote a)                              ==>  (quote a)
''a                                     ==>  (quote a)
@end verbatim

Numeric constants, string constants, character constants, and boolean
constants evaluate to themselves, so they don't need to be quoted.

@verbatim
'"abc"                                  ==>  "abc"
"abc"                                   ==>  "abc"
'145932                                 ==>  145932
145932                                  ==>  145932
'#t                                     ==>  #t
#t                                      ==>  #t
@end verbatim

@node quasiquote template
@subsection (quasiquote @emph{template})
@anchor{quasiquote}
``Backquote'' or ``quasiquote'' expressions are useful for constructing
a list or vector structure when most but not all of the desired
structure is known in advance. If no commas appear within the
@emph{template}, the result of evaluating is equivalent (in the sense of
@code{equal?}) to the result of evaluating @code{'template}. If a comma
appears within the @emph{template}, however, the expression following
the comma is evaluated (``unquoted'') and its result is inserted into
the structure instead of the comma and the expression. If a comma
appears followed immediately by an at-sign (@@), then the following
expression shall evaluate to a list; the opening and closing parentheses
of the list are then ``stripped away'' and the elements of the list are
inserted in place of the comma at-sign expression sequence.

@verbatim
`(list ,(+ 1 2) 4)                       ==>  (list 3 4)

(let ((name 'a)) `(list ,name ',name))   ==>  (list a 'a)

`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)    ==>  (a 3 4 5 6 b)

`((foo ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))
                                         ==>  ((foo 7) . cons)

`#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)
                                         ==>  #(10 5 2 4 3 8)

`,(+ 2 3)                                ==>  5
@end verbatim

Quasiquote forms may be nested. Substitutions are made only for unquoted
components appearing at the same nesting level as the outermost
backquote. The nesting level increases by one inside each successive
quasiquotation, and decreases by one inside each unquotation.

@verbatim
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
     ==>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)

(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))       ==>  (a `(b ,x ,'y d) e)
@end verbatim

The above notations and @code{(quasiquote template)} are identical in
all respects. is identical to and is identical to .

@verbatim
(quasiquote (list (unquote (+ 1 2)) 4))
           ==>  (list 3 4)

'(quasiquote (list (unquote (+ 1 2)) 4))
           ==>  `(list ,(+ 1 2) 4)
           _i.e.,_ (quasiquote (list (unquote (+ 1 2)) 4))
@end verbatim

Unpredictable behavior can result if any of the symbols
@code{quasiquote}, @code{unquote}, or @code{unquote-splicing} appear in
a @emph{template} in ways otherwise than as described above.

@node Macros
@section Macros
@anchor{macros}
@menu
* define-macro formals template::
* defmacro formals template::
* expand name [object@dots{}]::
@end menu

@node define-macro formals template
@subsection (define-macro (@emph{formals}) @emph{template})
@anchor{define-macro}

@node defmacro formals template
@subsection (defmacro (@emph{formals}) @emph{template})
@anchor{defmacro}
@emph{The former is from standard Scheme and is the preferred name. The
latter is retained for backward compatibility with earlier versions of
GoLisp.}

Create a named macro:

@emph{formals} is the same as in a procedure definition: a name followed
by formal parameters, if any. @strong{NOTE} that the arguments to a
macro invocation are @strong{not} evaluated, but are passed as is to the
macro to do with as it wishes.

@emph{template} the template expression that is processed when the macro
is invoked. The result of evaluating the processed template expression
becomes the value of the macro's invocation. @emph{template} is
typically (even always) a quasiquoted expression using the formal
parameter names for purposes of unquotiing in order to fill in the
template.

@verbatim
(define-macro (double x)
   `(+ ,x ,x))

(double 5) ==> 10
@end verbatim

@node expand name [object@dots{}]
@subsection (expand @emph{name} [@emph{object}@dots{}])
@anchor{expand}
Expands the macro named by @emph{name}, passing the evaluated sequence
of @emph{object} as arguments. @strong{NOTE:} whereas invoking the macro
(in the same way you invoke a function) expands and evaluates,
@code{expand} (as you would expect) only expands the macro, resulting in
the expanded template sexpr. This can then be evaluated as desired.

@verbatim
(define-macro (double x)
   `(+ ,x ,x))

(expand double 5) ==> (+ 5 5)
@end verbatim

@node Sequencing
@section Sequencing
@anchor{sequencing}
The @code{begin} special form is used to evaluate expressions in a
particular order.
@menu
* begin expression @dots{}::
* -> value sexprsymbol@dots{}::
* => value sexprsymbol@dots{}::
@end menu

@node begin expression @dots{}
@subsection (begin @emph{expression} @dots{})
@anchor{begin}
The @emph{expressions} are evaluated sequentially from left to right,
and the value of the last @emph{expression} is returned. This expression
type is used to sequence side effects such as input and output. Keep in
mind, @code{begin} does @strong{not} create a nested lexical
environment.

@verbatim
(define x 0)
(begin (set! x 5)
       (+ x 1))                 ==>  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))
                                -|  4 plus 1 equals 5
                                ==>  unspecified
@end verbatim

Often the use of @code{begin} is unnecessary, because many special forms
already support sequences of expressions (that is, they have an implicit
@code{begin}). Some of these special forms are:

@itemize
@item
case

@item
cond

@item
define ;”procedure define” only

@item
do

@item
lambda

@item
let

@item
let*

@item
letrec

@end itemize

@node -> value sexprsymbol@dots{}
@subsection (-> @emph{value} @emph{sexprsymbol}@dots{})
@anchor{chain}
This creates a function chain. @emph{value} (evaluated first) is used as
the last (or only) argument to the first @emph{sexpr}. The result of
each @emph{sexpr} is used as the last/only argument of the next, and the
result of the final @emph{sexpr} is the value of the @code{->} form. If
a @emph{sexpr} would take a single argument (which would be provided by
the @emph{value} or the result of the previous @emph{sexpr}, just the
function name can be used.

The form @code{(-> 0 a b c)} is equivalent to @code{(c (b (a 0)))}.

@verbatim
(-> 1 (+ 3) (- 6))     ==> 2     ; (- 6 (+ 3 1))
(-> 1 (+ 3) (- 6) str) ==> "2"   ; (str (- 6 (+ 3 1)))
@end verbatim

The major advantage of this form is avoiding having to create a sequence
on intermediate values/bindings purely to support the data flow.
@code{->} lets you create a pipeline that you can put one value into and
get the final result out the other end.

@node => value sexprsymbol@dots{}
@subsection (=> @emph{value} @emph{sexprsymbol}@dots{})
@anchor{parallel-chain}
This operates similarly to @code{->} with two differences:

@enumerate 
@item
@emph{value} (evaluated @strong{once} at the beginning) is used as the
last/only argument to @strong{each} function, and they are independent and
do not pass results one to another.

@item
@emph{value} is the result of the form.

@end enumerate

The expression

@verbatim
(=> 1 a b c)
@end verbatim

is equivalent to

@verbatim
(begin
  (a 1)
  (b 1)
  (c 1)
  1)
@end verbatim

and

@verbatim
(=> (+ x 1) a b c)
@end verbatim

is the same as

@verbatim
(let ((y (+ x 1)))
  (a y)
  (b y)
  (c y)
  y)
@end verbatim

@node Conditionals
@section Conditionals
@anchor{conditionals}
The behavior of the ``conditional expressions'' is determined by whether
objects are true or false. The conditional expressions count only
@code{@hashchar{}f} as false. They count everything else, including @code{@hashchar{}t},
pairs, symbols, numbers, strings, vectors, and procedures as true.

In the descriptions that follow, we say that an object has ``a true
value'' or ``is true'' when the conditional expressions treat it as
true, and we say that an object has ``a false value'' or ``is false''
when the conditional expressions treat it as false.
@menu
* cond clause@dots{}::
* case key clause@dots{}::
* and expression@dots{}::
* or expression@dots{}::
* if predicate consequent [alternative]::
* when predicate expression@dots{}::
* unless predicate expression@dots{}::
@end menu

@node cond clause@dots{}
@subsection (cond @emph{clause}@dots{})
@anchor{cond}
Each @emph{clause} has this form:

@verbatim
(predicate expression...)
@end verbatim

where @emph{predicate} is any expression. The last @emph{clause} may be
an ``@code{else} clause'', which has the form:

@verbatim
(else expression...)
@end verbatim

A @code{cond} expression does the following:

@enumerate 
@item
Evaluates the @emph{predicate} expressions of successive @emph{clauses}
in order, until one of the @emph{predicates} evaluates to a true value.

@item
When a @emph{predicate} evaluates to a true value, @code{cond} evaluates
the @emph{expressions} in the associated @emph{clause} in left to right
order, and returns the result of evaluating the last @emph{expression}
in the @emph{clause} as the result of the entire @code{cond} expression.
If the selected @emph{clause} contains only the @emph{predicate} and no
@emph{expressions}, @code{cond} returns the value of the
@emph{predicate} as the result.

@item
If all @emph{predicates} evaluate to false values, and there is no
@code{else} clause, the result of the conditional expression is
unspecified; if there is an @code{else} clause, @code{cond} evaluates
its @emph{expressions} (left to right) and returns the value of the last
one.

@verbatim
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))                  ==>  greater

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))                    ==>  equal
@end verbatim

@end enumerate

Normally, programs should not depend on the value of a @code{cond}
expression that has no @code{else} clause. However, some Scheme
programmers prefer to write @code{cond} expressions in which at least
one of the @emph{predicates} is always true. In this style, the final
@emph{clause} is equivalent to an @code{else} clause.

GoLisp (and Scheme) supports an alternative clause syntax:

@verbatim
(predicate => recipient)
@end verbatim

where @emph{recipient} is an expression. If @emph{predicate} evaluates
to a true value, then @emph{recipient} is evaluated. Its value must be a
procedure of one argument; this procedure is then invoked on the value
of the @emph{predicate}.

@verbatim
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f))                        ==>  2
@end verbatim

@node case key clause@dots{}
@subsection (case @emph{key} @emph{clause}@dots{})
@anchor{case}
@emph{key} may be any expression. Each @emph{clause} has this form:

@verbatim
((object...) expression...)
@end verbatim

No @emph{object} is evaluated, and all the @emph{objects} must be
distinct. The last @emph{clause} may be an ``@strong{else} clause'',
which has the form:

@verbatim
(else expression...)
@end verbatim

A @code{case} expression does the following:

@enumerate 
@item
Evaluates @emph{key} and compares the result with each @emph{object}.

@item
If the result of evaluating @emph{key} is equivalent (in the sense of
@code{eqv?}) to an @emph{object}, @code{case} evaluates the
@emph{expressions} in the corresponding @emph{clause} from left to right
and returns the result of evaluating the last @emph{expression} in the
@emph{clause} as the result of the @code{case} expression.

@item
If the result of evaluating @emph{key} is different from every
@emph{object}, and if there's an @code{else} clause, @code{case}
evaluates its @emph{expressions} and returns the result of the last one
as the result of the @code{case} expression. If there's no @code{else}
clause, @code{case} returns an unspecified result. Programs should not
depend on the value of a @code{case} expression that has no @code{else}
clause.

@end enumerate

For example,

@verbatim
(case (* 2 3)
   ((2 3 5 7) 'prime)
   ((1 4 6 8 9) 'composite)) ==>  composite

(case (car '(c d))
   ((a) 'a)
   ((b) 'b))                 ==>  unspecified

(case (car '(c d))
   ((a e i o u) 'vowel)
   ((w y) 'semivowel)
   (else 'consonant))        ==>  consonant
@end verbatim

@node and expression@dots{}
@subsection (and @emph{expression}@dots{})
@anchor{and}
The @emph{expressions} are evaluated from left to right, and the value
of the first @emph{expression} that evaluates to a false value is
returned. Any remaining @emph{expressions} are not evaluated. If all the
@emph{expressions} evaluate to true values, the value of the last
@emph{expression} is returned. If there are no @emph{expressions} then
@code{@hashchar{}t} is returned.

@verbatim
(and (= 2 2) (> 2 1)) ==>  #t
(and (= 2 2) (< 2 1)) ==>  #f
(and 1 2 'c '(f g))   ==>  (f g)
(and)                 ==>  #t
@end verbatim

@node or expression@dots{}
@subsection (or @emph{expression}@dots{})
@anchor{or}
The @emph{expressions} are evaluated from left to right, and the value
of the first @emph{expression} that evaluates to a true value is
returned. Any remaining @emph{expressions} are not evaluated. If all
@emph{expressions} evaluate to false values, the value of the last
@emph{expression} is returned. If there are no @emph{expressions} then
@code{@hashchar{}f} is returned.

@verbatim
(or (= 2 2) (> 2 1))            ==>  #t
(or (= 2 2) (< 2 1))            ==>  #t
(or #f #f #f)                   ==>  #f
(or (memq 'b '(a b c)) (/ 3 0)) ==>  (b c)
@end verbatim

@node if predicate consequent [alternative]
@subsection (if @emph{predicate} @emph{consequent} [@emph{alternative}])
@anchor{if}
@code{if} is a macro based on @code{cond}.

@emph{predicate}, @emph{consequent}, and @emph{alternative} are
expressions. An @code{if} expression is evaluated as follows: first,
@emph{predicate} is evaluated. If it yields a true value, then
@emph{consequent} is evaluated and its value is returned. Otherwise
@emph{alternative} is evaluated and its value is returned. If
@emph{predicate} yields a false value and no @emph{alternative} is
specified, then the result of the expression is unspecified.

An @code{if} expression evaluates either @emph{consequent} or
@emph{alternative}, never both. Programs should not depend on the value
of an @code{if} expression that has no @emph{alternative}.

@verbatim
(if (> 3 2) 'yes 'no)                   ==>  yes
(if (> 2 3) 'yes 'no)                   ==>  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                            ==>  1
@end verbatim

@node when predicate expression@dots{}
@subsection (when @emph{predicate} @emph{expression}@dots{})
@anchor{when}
@code{when} is a macro based on @code{cond}.

If @emph{predicate} evaluates to logically @code{true}, the sequence of
@emph{expresions} is evaluated and the result of the last one is the
result of the @code{when} form, otherwise @code{nil} is the result.

@verbatim
(when (> x 5)
  (write-line "greater")
  (+ x 2))
@end verbatim

The above is equivalent to the following, but is simpler and clearer.

@verbatim
(if (> x 5)
    (begin (write-line "greater")
           (+ x 2)))
@end verbatim

@node unless predicate expression@dots{}
@subsection (unless @emph{predicate} @emph{expression}@dots{})
@anchor{unless}
@code{unless} is a macro based on @code{cond}.

If @emph{predicate} evaluates to logically @code{false}, the sequence of
@emph{expresions} is evaluated and the result of the last one is the
result of the @code{unless} form, otherwise @code{nil} is the result.

@verbatim
(unless (> x 5)
  (write-line "greater")
  (+ x 2))
@end verbatim

The above is equivalent to the following, but is much simpler and
clearer.

@verbatim
(if (> x 5)
    ()
    (begin (write-line "greater")
           (+ x 2)))
@end verbatim

@node Iteration
@section Iteration
@anchor{iteration}
The ``iteration expressions'' are: ``named @code{let}'' and @code{do}.
They are also binding expressions, but are more commonly referred to as
iteration expressions.
@menu
* let name variable init@dots{} _expression@dots{}::
* do variable init step@dots{} test expression@dots{} command@dots{}::
@end menu

@node let name variable init@dots{} _expression@dots{}
@subsection (let @emph{name} ((@emph{variable} @emph{init})@dots{})
_expression@dots{})
@anchor{named-let}
GoLisp permits a variant on the syntax of @emph{let} called ``named
@code{let}'' which provides a more general looping construct than
@code{do}, and may also be used to express recursions (but prefer
proper tail-ecursive functions)

Named @code{let} has the same syntax and semantics as ordinary
@code{let} except that @emph{name} is bound within the
@emph{expressions} to a procedure whose formal arguments are the
@emph{variables} and whose body is the @emph{expressions}. Thus the
execution of the @emph{expressions} may be repeated by invoking the
procedure named by @emph{name}.

GoLisp allows any of the @emph{inits} to be omitted, in which case the
corresponding @emph{variables} are unassigned.

Note: the following expressions are equivalent:

@verbatim
(let name ((variable init)...)
  expression...)

((letrec ((name
           (lambda (variable...)
             expression...)))
   name)
 init...)
@end verbatim

Here is an example:

@verbatim
(let loop
     ((numbers '(3 -2 1 6 -5))
      (nonneg '())
      (neg '()))
  (cond ((null? numbers)
         (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        (else
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))

     ==>  ((6 1 3) (-5 -2))
@end verbatim

@node do variable init step@dots{} test expression@dots{} command@dots{}
@subsection (do ((@emph{variable} @emph{init} @emph{step})@dots{}) (@emph{test} @emph{expression}@dots{}) @emph{command}@dots{})
@anchor{do }
@code{do} is an iteration construct. It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration. When a termination condition is met,
the loop exits with a specified result value.

@code{do} expressions are evaluated as follows: The @emph{init}
expressions are evaluated (in some unspecified order), the
@emph{variables} are bound to fresh locations, the results of the
@emph{init} expressions are stored in the bindings of the
@emph{variables}, and then the iteration phase begins.

Each iteration begins by evaluating @emph{test}; if the result is false,
then the @emph{command} expressions are evaluated in order for effect,
the @emph{step} expressions are evaluated in some unspecified order, the
@emph{variables} are bound to fresh locations, the results of the
@emph{steps} are stored in the bindings of the @emph{variables}, and the
next iteration begins.

If @emph{test} evaluates to a true value, then the @emph{expressions}
are evaluated from left to right and the value of the last
@emph{expression} is returned as the value of the @code{do} expression.
If no @emph{expressions} are present, then the value of the @code{do}
expression is the empty list (i.e. @code{nil}).

The region of the binding of a @emph{variable} consists of the entire
@code{do} expression except for the @emph{inits}. It is an error for a
@emph{variable} to appear more than once in the list of @code{do}
variables.

A @emph{step} may be omitted, in which case the effect is the same as if
@code{(variable init variable)} had been written instead of
@code{(variable init)}.

@verbatim
(do ((vec (make-vector 5))
      (i 0 (+ i 1)))
     ((= i 5) vec)
   (vector-set! vec i i))        ==>  #(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
   (do ((x x (cdr x))
        (sum 0 (+ sum (car x))))
       ((null? x) sum)))         ==>  25
@end verbatim

@node Eval/Apply
@section Eval/Apply
@anchor{evalapply}
@menu
* apply function object@dots{}::
* eval expression::
* definition-of function::
@end menu

@node apply function object@dots{}
@subsection (apply @emph{function} @emph{object}@dots{})
@anchor{apply}
Apply the function that results from evaluating @emph{function} to the
argument list resulting from evaluating each @emph{object}.

Each initial @emph{object} can be any type of object, but the final one
(and there must be at least one @emph{object}) must be a list.

@verbatim
(apply + 1 2 '(3 4)) ==> 10
(apply + '(1 2 3 4)) ==> 10
@end verbatim

@node eval expression
@subsection (eval @emph{expression})
@anchor{eval}
Evaluate @emph{expression} in the current environment.

@verbatim
(eval '(+ 1 2 3 4)) ==> 10
@end verbatim

@node definition-of function
@subsection (definition-of @emph{function})
@anchor{definition-of}
Fetch the definition of @emph{function}. This returns an expression that
can be evaluated to define it. One use of this is to copy definitions to
a source file.

@verbatim
(define (square x)
  (* x x))

(definition-of square) ==> (define (square x) (* x x))

(define square (lambda (x)
                 (* x x)))

(definition-of square) ==> (define square (lambda (x) (* x x)))
@end verbatim

@node Numerical Operations
@section Numerical Operations
@anchor{numerical-operations}
@menu
* + number@dots{}::
* * number @dots{}::
* - number@dots{}::
* / number@dots{}::
* succ integer::
* 1+ integer::
* pred integer::
* -1+ integer::
* quotient n1 _n2::
* remiander n1 n2::
* modulo n1 n2::
* floor number::
* ceiling number::
* integer number::
* float number::
* number->string number [base]::
* string->number numeric-string [base]::
@end menu

@node + number@dots{}
@subsection (+ @emph{number}@dots{})
@anchor{plus}

@node * number @dots{}
@subsection (* @emph{number}@dots{})
@anchor{times}
These procedures return the sum or product of their arguments.

@verbatim
(+ 3 4)                 ==>  7
(+ 3)                   ==>  3
(+)                     ==>  0
(* 4)                   ==>  4
(*)                     ==>  1
@end verbatim

@node - number@dots{}
@subsection (- @emph{number}@dots{})
@anchor{subtract}

@node / number@dots{}
@subsection (/ @emph{number}@dots{})
@anchor{divide}
With two or more arguments, these procedures return the difference or
quotient of their arguments, associating to the left. With one argument,
however, they return the additive or multiplicative inverse of their
argument.

@verbatim
(- 3 4)                 ==>  -1
(- 3 4 5)               ==>  -6
(- 3)                   ==>  -3
(/ 3 4 5)               ==>  0.15
(/ 4)                   ==>  0.25
@end verbatim

Note that @code{/} always preforms floating point division. If the
quotient is a whole number it will be returned as an integer.

@verbatim
(/ 12 5)                ==>  2.4
(/ 12 2.4)              ==>  5
@end verbatim

@node succ integer
@subsection (succ @emph{integer})
@anchor{succ }

@node 1+ integer
@subsection (1+ @emph{integer})
@anchor{one-plus}
Equivalent to @code{(+ integer 1)}.

@node pred integer
@subsection (pred @emph{integer})
@anchor{pred}

@node -1+ integer
@subsection (-1+ @emph{integer})
@anchor{minus-one-plus}
Equivalent to @code{(- integer 1)}.

@node quotient n1 _n2
@subsection (quotient @emph{n1} _n2)
@anchor{quotient}

@node remiander n1 n2
@subsection (remiander @emph{n1} @emph{n2})
@anchor{remiander}

@node modulo n1 n2
@subsection (modulo @emph{n1} @emph{n2})
@anchor{modulo}
These procedures implement number-theoretic (integer) division: for
positive integers @emph{n1} and @emph{n2}, if @emph{n3} and @emph{n4}
are integers such that

@verbatim
n1 = (n2 * n3) + n4

0 <= n4 < n2
@end verbatim

then

@verbatim
(quotient n1 n2)        ==>  n3
(remainder n1 n2)       ==>  n4
(modulo n1 n2)          ==>  n4
@end verbatim

for integers @emph{n1} and @emph{n2} with @emph{n2} not equal to 0,

@verbatim
(= n1
   (+ (* n2 (quotient n1 n2))
      (remainder n1 n2)))
                        ==>  #t
@end verbatim

The value returned by @code{quotient} always has the sign of the product
of its arguments. @code{remainder} and @code{modulo} differ on negative
arguments -- the @code{remainder} always has the sign of the dividend,
the @code{modulo} always has the sign of the divisor:

@verbatim
(modulo 13 4)           ==>  1
(remainder 13 4)        ==>  1

(modulo -13 4)          ==>  3
(remainder -13 4)       ==>  -1

(modulo 13 -4)          ==>  -3
(remainder 13 -4)       ==>  1

(modulo -13 -4)         ==>  -1
(remainder -13 -4)      ==>  -1
@end verbatim

The @code{%} function is an alias for @code{remainder}.

@node floor number
@subsection (floor @emph{number})
@anchor{floor}
Returns the greatest integer value less than or equal to @emph{number}.
@emph{number} can be an integer or float. Return value is a float.

@verbatim
(floor 3.4)             ==> 3.0
(floor -3.4)            ==> -4.0
(floor 3)               ==> 3.0
@end verbatim

@node ceiling number
@subsection (ceiling @emph{number})
@anchor{ceiling}
Returns the largest integer value greater than or equal to
@emph{number}. @emph{number} can be an integer or float. Return value is
a float.

@verbatim
(ceiling 3.4)           ==> 4.0
(ceiling -3.4)          ==> -3.0
(ceiling 3)             ==> 3.0
@end verbatim

@node integer number
@subsection (integer @emph{number})
@anchor{integer}
Returns the integer value of @emph{number}. If it is an integer, it is
simply returned. However, if it is a float the integer part is returned.

@verbatim
(integer 5)             ==> 5
(integer 5.2)           ==> 5
(integer -5.8)          ==> -5
@end verbatim

@node float number
@subsection (float @emph{number})
@anchor{float}
Returns the float value of @emph{number}. If it is a float, it is simply
returned. However, if it is an integer the corresponding float is
returned.

@verbatim
(float 5)               ==> 5.0
@end verbatim

Note that converting a float to a string for printing using the format
@code{%g} to use the minimum number of characters so @code{5.0} will
actually print as @code{5}.

@node number->string number [base]
@subsection (number->string @emph{number} [@emph{base}])
@anchor{number-string}
Converts @emph{number} (first converted to an integer) to a string, in
the given @emph{base}. Allowed bases are 2, 8, 10, and 16. If the base
is omitted, 10 is used. No base prefixes (e.g. @code{@hashchar{}x} for base 16)
are added.

@verbatim
(number->string 42)    ==> "42"
(number->string 42 2)  ==> "101010"
(number->string 42 8)  ==> "52"
(number->string 42 10) ==> "42"
(number->string 42 16) ==> "2a"
(number->string 42 15) ==> ERROR number->string: unsupported base 15
@end verbatim

@node string->number numeric-string [base]
@subsection (string->number @emph{numeric-string} [@emph{base}])
@anchor{string-number}
Converts @emph{numeric-string} to an integer, in the given base. Allowed
bases are 2, 8, 10, and 16. If the base is omitted, 10 is used. No base
prefixes (e.g. @code{@hashchar{}x} for base 16) are allowed. Specifying an
unsupported base will result in @code{0}.

@verbatim
(string->number "42")       ==> 42
(string->number "101010" 2) ==> 42
(string->number "52" 8)     ==> 42
(string->number "42" 10)    ==> 42
(string->number "2a" 16)    ==> 42
(string->number "42" 15)    ==> ERROR number->string: unsupported base 15
@end verbatim

@node Comparisons
@section Comparisons
@anchor{comparisons}
All comparison operations work with floating point numbers as well.
@menu
* < number1 number2 @dots{}::
* > number1 number2 @dots{}::
* <= number1 number2 @dots{}::
* >= number1 number2 @dots{}::
* zero? number::
* positive? number::
* negative? number::
* odd? number::
* even? number::
* min number@dots{}::
* min number@dots{}::
* max number@dots{}::
* max number@dots{}::
* log number::
@end menu

@node < number1 number2 @dots{}
@subsection (< @emph{number1} @emph{number2} @dots{})
@anchor{less-than}

@node > number1 number2 @dots{}
@subsection (> @emph{number1} @emph{number2} @dots{})
@anchor{greater-than}

@node <= number1 number2 @dots{}
@subsection (<= @emph{number1} @emph{number2} @dots{})
@anchor{less-than-equal}

@node >= number1 number2 @dots{}
@subsection (>= @emph{number1} @emph{number2} @dots{})
@anchor{greater-than-equal}
These procedures return @code{@hashchar{}t} if their arguments are (respectively):
equal (two alternatives), not equal (two alternatives), monotonically
increasing, monotonically decreasing, monotonically nondecreasing, or
monotonically nonincreasing. They return @code{@hashchar{}f} otherwise. Note that
@code{<}, @code{>}, @code{<=}, and @code{>=} can take more than 2
arguments.

@node zero? number
@subsection (zero? @emph{number})
@anchor{zerop}

@node positive? number
@subsection (positive? @emph{number})
@anchor{positivep}

@node negative? number
@subsection (negative? @emph{number})
@anchor{negativep}

@node odd? number
@subsection (odd? @emph{number})
@anchor{oddp}

@node even? number
@subsection (even? @emph{number})
@anchor{evenp}
These numerical predicates test a number for a particular property,
returning @code{@hashchar{}t} or @code{@hashchar{}f}.

@node min number@dots{}
@subsection (min @emph{number}@dots{})
@anchor{min}

@node min numberlist
@subsection (min (@emph{number}@dots{}))
@anchor{min-numberlist}

@node max number@dots{}
@subsection (max @emph{number}@dots{})
@anchor{max}

@node max numberlist
@subsection (max (@emph{number}@dots{}))
@anchor{max-numberlist}
These procedures return the maximum or minimum of their arguments. Note
that the arguments can be a series of numbers or a list of numbers:

@verbatim
(min 3 7 1 2)     ==> 1
(min '(3 7 1 2))  ==> 1
@end verbatim

@node log number
@subsection (log @emph{number})
@anchor{log}
This computes the natural logarithm of @emph{number} @strong{(not the
base ten logarithm)}. An integer argument will be converted to a float.
The result is always a float.

@node Equivalence Predicates
@chapter Equivalence Predicates
@anchor{equivalence-predicates}
A ``predicate'' is a procedure that always returns a boolean value
(@code{@hashchar{}t} or @code{@hashchar{}f}). An ``equivalence predicate'' is the
computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive). Of the equivalence predicates
described in this section, @code{eq?} is the finest or most
discriminating, and @code{equal?} is the coarsest. @code{eqv?} is
slightly less discriminating than @code{eq?}.

@node eqv? obj1 obj2
@subsection (eqv? @emph{obj1} @emph{obj2})
@anchor{eqvp}
The @code{eqv?} procedure defines a useful equivalence relation on
objects. Briefly, it returns @code{@hashchar{}t} if @emph{obj1} and @emph{obj2}
should normally be regarded as the same object.

The @code{eqv?} procedure returns @code{@hashchar{}t} if:

@itemize
@item
@emph{obj1} and @emph{obj2} are both @code{@hashchar{}t} or both @code{@hashchar{}f}.

@item
@emph{obj1} and @emph{obj2} are both interned symbols and

@verbatim
(string=? (symbol->string obj1)
          (symbol->string obj2))
      ==> #t
@end verbatim

@item
@emph{obj1} and @emph{obj2} are both numbers, are numerically equal
according to the @code{=} procedure.

@item
both @emph{obj1} and @emph{obj2} are the empty list.

@item
@emph{obj1} and @emph{obj2} are procedures whose location tags are
equal.

@item
@emph{obj1} and @emph{obj2} are pairs, vectors, strings, byte arrays,
records, cells, or weak pairs that denote the same locations in the
store.

@end itemize

The @code{eqv?} procedure returns @code{@hashchar{}f} if:

@itemize
@item
@emph{obj1} and @emph{obj2} are of different types.

@item
one of @emph{obj1} and @emph{obj2} is @code{@hashchar{}t} but the other is
@code{@hashchar{}f}.

@item
@emph{obj1} and @emph{obj2} are symbols but

@verbatim
(string=? (symbol->string obj1)
          (symbol->string obj2))
     ==> #f
@end verbatim

@item
@emph{obj1} and @emph{obj2} are numbers for which the @code{=} procedure
returns @code{@hashchar{}f}.

@item
one of @emph{obj1} and @emph{obj2} is the empty list but the other is
not.

@item
@emph{obj1} and @emph{obj2} are procedures which have distinct
underlying representations.

@item
@emph{obj1} and @emph{obj2} are pairs, vectors, strings, byte arrays, or
frames that denote distinct locations.

@end itemize

Some examples:

@verbatim
(eqv? 'a 'a)                 ==>  #t
(eqv? 'a 'b)                 ==>  #f
(eqv? 2 2)                   ==>  #t
(eqv? '() '())               ==>  #t
(eqv? 100000000 100000000)   ==>  #t
(eqv? (cons 1 2) (cons 1 2)) ==>  #f
(eqv? (lambda () 1)
      (lambda () 2))         ==>  #f
(eqv? #f 'nil)               ==>  #f
(let ((p (lambda (x) x)))
  (eqv? p p))                ==>  #t
@end verbatim

The following examples illustrate how GoLisp behaves in cases where MIT
Scheme's rules do not fully specify the behavior of `eqv?'.

@verbatim
(eqv? "" "")                 ==>  #f
(eqv? '#() '#())             ==>  #f
(eqv? (lambda (x) x)
      (lambda (x) x))        ==>  #f
(eqv? (lambda (x) x)
      (lambda (y) y))        ==>  #f
@end verbatim

Objects of distinct types must never be regarded as the same object.

Since it is an error to modify constant objects (those returned by
literal expressions), the implementation may share structure between
constants where appropriate. Thus the value of @code{eqv?} on constants
is sometimes unspecified, however, the following cases hold.

@verbatim
(let ((x '(a)))
  (eqv? x x))                ==>  #t
(eqv? '(a) '(a))             ==>  #f
(eqv? "a" "a")               ==>  #f
(eqv? '(b) (cdr '(a b)))     ==>  #f
@end verbatim

@node eq? obj1 obj2
@subsection (eq? @emph{obj1} @emph{obj2})
@anchor{eqp}
@code{eq?} is similar to @code{eqv?} except that in some cases it is
capable of discerning distinctions finer than those detectable by
@code{eqv?}.

@code{eq?} and @code{eqv?} are guaranteed to have the same behavior on
symbols, booleans, the empty list, pairs, records, and non-empty strings
and vectors. @code{eq?}'s behavior on numbers and characters is
implementation-dependent, but it will always return either true or
false, and will return true only when @code{eqv?} would also return
true. @code{eq?} may also behave differently from @code{eqv?} on empty
vectors and empty strings.

@verbatim
(eq? 'a 'a)                  ==>  #t
(eq? '(a) '(a))              ==>  #f
(eq? (list 'a) (list 'a))    ==>  #f
(eq? "a" "a")                ==>  #t
(eq? "" "")                  ==>  #t
(eq? '() '())                ==>  #t
(eq? 2 2)                    ==>  #t
(eq? car car)                ==>  #t
(let ((n (+ 2 3)))
  (eq? n n))                 ==>  #t
(let ((x '(a)))
  (eq? x x))                 ==>  #t
(let ((x '#()))
  (eq? x x))                 ==>  #t
(let ((p (lambda (x) x)))
  (eq? p p))                 ==>  #t
@end verbatim

@code{eq?} of two vectors compares the vector contents using @code{eq?},
so two vectors are @code{eq?} only when their contents are also
@code{eq?}.

@node equal? obj1 obj2
@subsection (equal? @emph{obj1} @emph{obj2})
@anchor{equalp}
@code{equal?} recursively compares the contents of pairs, vectors, and
strings, applying @code{eqv?} on other objects such as numbers, symbols,
and booleans. A rule of thumb is that objects are generally
@code{equal?} if they print the same. @code{equal?} may fail to
terminate if its arguments are circular data structures.

@verbatim
(equal? 'a 'a)               ==>  #t
(equal? '(a) '(a))           ==>  #t
(equal? '#(a) '#(a))         ==>  #t
(equal? '(a (b) c)
        '(a (b) c))          ==>  #t
(equal? "abc" "abc")         ==>  #t
(equal? 2 2)                 ==>  #t
(equal? (make-vector 5 'a)
        (make-vector 5 'a))  ==>  #t
(equal? (lambda (x) x)
        (lambda (y) y))      ==>  #f
@end verbatim

@node neqv? object object
@subsection (neqv? @emph{object} @emph{object})
@anchor{neqvp}

@node neq? object object
@subsection (neq? @emph{object} @emph{object})
@anchor{neqp}

@node nequal? object object
@subsection (nequal? @emph{object} @emph{object})
@anchor{nequalp}
Each is the logical negation of the corresponding equivalence predicate.

@node Logical
@chapter Logical
@anchor{logical}

@node boolean=? object1 object2
@subsection (boolean=? @emph{object1} @emph{object2})
@anchor{boolean-eqp}
Returns whether @emph{object1} and @emph{object2} are both truthy or are
both falsy.

@node Binary
@chapter Binary
@anchor{binary}

@node binary-and int-1 int-2
@subsection (binary-and @emph{int-1} @emph{int-2})
@anchor{binary-and}
Performs a bitwise AND of @emph{int-1} and @emph{int-2}, returning the
result.

@verbatim
(number->string (binary-and #xaa #x0f) 16) ==> "a"
(number->string (binary-and #xaa #xf0) 16) ==> "a0"
@end verbatim

@node binary-or int-1 int-2
@subsection (binary-or @emph{int-1} @emph{int-2})
@anchor{binary-or}
Performs a bitwise OR of @emph{int-1} and @emph{int-2}, returning the
result.

@verbatim
(number->string (binary-or #xaa #x0f) 16) ==> "af"
(number->string (binary-or #xaa #xf0) 16) ==> "fa"
@end verbatim

@node binary-not int
@subsection (binary-not @emph{int})
@anchor{binary-not}
Performs a bitwise NOT of @emph{int}, returning the result.

@verbatim
(number->string (binary-not #x000000aa) 16) ==> "ffffff55"
@end verbatim

@node left-shift int count
@subsection (left-shift @emph{int} @emph{count})
@anchor{left-shift}
Returns @emph{int} shifted left by @emph{count} bits. The original value is not changed.  Zeros are shifed in as required.

@verbatim
(number->string (left-shift (string->number "10101010" 2) 1) 2) ==> "101010100"
(number->string (left-shift (string->number "10101010" 2) 3) 2) ==> "10101010000"
@end verbatim

@node right-shift int count
@subsection (right-shift @emph{int} @emph{count})
@anchor{right-shift}
Returns @emph{int} shifted right by @emph{count} bits. The original value is not changed. Zeros are shifted in as required.

@verbatim
(number->string (right-shift (string->number "10000" 2) 1) 2) ==> "1000"
(number->string (right-shift (string->number "10000" 2) 4) 2) ==> "1"
@end verbatim

@node Characters
@chapter Characters
@anchor{characters}
GoLisp has minimal support for characters: just that required for basic
string manipulation. this may be expanded in the future.
@menu
* External Representation of Characters::
@end menu

@node External Representation of Characters
@section External Representation of Characters
@anchor{external-representation-of-characters}
Characters are written using the notation @code{@hashchar{}CHARACTER} or
@code{@hashchar{}@backslashchar{}CHARACTER-NAME}. For example:

@verbatim
#\a                     ; lowercase letter
#\A                     ; uppercase letter
#\(                     ; left parenthesis
#\space                 ; the space character
#\newline               ; the newline character
@end verbatim

Case is significant in @code{@hashchar{}@backslashchar{}CHARACTER}, but not in
@code{@hashchar{}@backslashchar{}CHARACTER-NAME}. If CHARACTER in @code{@hashchar{}@backslashchar{}CHARACTER} is a letter,
@emph{CHARACTER} must be followed by a delimiter character such as a
space or closing parenthesis, bracket, or brace. Characters written in
the @code{@hashchar{}@backslashchar{}} notation are self-evaluating; you don't need to quote
them.

The following @emph{CHARACTER-NAME}s are supported, shown here with
their ASCII equivalents:

@verbatim
Character Name          ASCII Name
 --------------          ----------

 altmode                 ESC
 backspace               BS
 esc                     ESC
 linefeed                LF
 page                    FF
 return                  CR
 rubout                  DEL
 space
 tab                     HT
@end verbatim

@node Strings
@chapter Strings
@anchor{strings}
A string is a immutable sequence of characters.

A string is written as a sequence of characters enclosed within double
quotes @code{" "}. To include a double quote inside a string, precede
the double quote with a backslash `@backslashchar{}' (escape it), as in

@verbatim
"The word \"recursion\" has many meanings."
@end verbatim

The printed representation of this string is

@verbatim
The word "recursion" has many meanings.
@end verbatim

To include a backslash inside a string, precede it with another
backslash; for example,

@verbatim
"Use #\\Control-q to quit."
@end verbatim

The printed representation of this string is

@verbatim
Use #\Control-q to quit.
@end verbatim

The effect of a backslash that doesn't precede a double quote or
backslash is unspecified in standard Scheme, but GoLisp specifies the
effect for three other characters: @code{@backslashchar{}t},
@code{@backslashchar{}n}, and @code{@backslashchar{}f}.  These escape
sequences are respectively translated into tab, newline, and page
characters.

If a string literal is continued from one line to another, the string
will contain the newline character at the line break. Standard Scheme
does not specify what appears in a string literal at a line break.

The ``length'' of a string is the number of characters that it
contains.  This number is a non-negative integer that is established
when the string is created. Each character in a string has an
``index'', which is a number that indicates the character's position
in the string. The index of the first (leftmost) character in a string
is 0, and the index of the last character is one less than the length
of the string. The ``valid indexes'' of a string are the non-negative
integers less than the length of the string. When speciffying
substrings, the following relation must hold between the start and end
values (@xref{substring}):

@verbatim
0 <= start <= end <= (string-length string)
@end verbatim


@menu
* Construction of Strings::
* String Operations::
* Comparison of Strings::
* Alphabetic Case in Strings::
* Cutting and Pasting Strings::
* Regexp Support::
@end menu

@node Construction of Strings
@section Construction of Strings
@anchor{construction-of-strings}
@menu
* make-string k [char]::
* string char@dots{}::
* list->string char-list::
* string-copy string::
@end menu

@node make-string k [char]
@subsection (make-string @emph{k} [@emph{char}])
@anchor{make-string}
Returns a newly allocated string of length @emph{k}. If you specify
@emph{char}, all elements of the string are initialized to @emph{char},
otherwise the contents of the string are unspecified.

@verbatim
(make-string 10 #\x)              ==>  "xxxxxxxxxx"
@end verbatim

@node string char@dots{}
@subsection (string @emph{char}@dots{})
@anchor{string-from-char}
Returns a newly allocated string consisting of the specified characters.
The arguments should be single character strings.

@verbatim
(string "a")                         ==>  "a"
(string "a" "b" #\c)                 ==>  "abc"
(string #\a #\space #\b #\space #\c) ==>  "a b c"
(string)                             ==>  undefined
@end verbatim

@node list->string char-list
@subsection (list->string @emph{char-list})
@anchor{list-string}
@emph{char-list} must be a list of strings. @code{list->string} returns
a newly allocated string formed by concatenating the elements of
@emph{char-list}. This is equivalent to @code{(apply string char-list)}.
The inverse of this operation is @code{string->list}.

@verbatim
(list->string '(#\a #\b))       ==>  "ab"
(string->list "Hello")          ==>  (#\H #\e #\l #\l #\o)
@end verbatim

@node string-copy string
@subsection (string-copy @emph{string})
@anchor{string-copy}
Returns a newly allocated copy of @emph{string}.

@node Selecting String Components
@section String Operations
@anchor{selecting-string-components}
@menu
* string? object::
* string-length string::
* string-null? string::
* string-ref string k::
* string-set! string k char::
@end menu

@node string? object
@subsection (string? @emph{object})
@anchor{stringp}
Returns @code{@hashchar{}t} if @emph{object} is a string; otherwise returns
@code{@hashchar{}f}.

@verbatim
(string? "Hi")                  ==>  #t
(string? 'Hi)                   ==>  #f
@end verbatim

@node string-length string
@subsection (string-length @emph{string})
@anchor{string-length}
Returns the length of @emph{string} as an non-negative integer.

@verbatim
(string-length "")              ==>  0
(string-length "The length")    ==>  10
@end verbatim

@node string-null? string
@subsection (string-null? @emph{string})
@anchor{string-nullp}
Returns @code{@hashchar{}t} if @emph{string} has zero length; otherwise returns
@code{@hashchar{}f}.

@verbatim
(string-null? "")               ==>  #t
(string-null? "Hi")             ==>  #f
@end verbatim

@node string-ref string k
@subsection (string-ref @emph{string} @emph{k})
@anchor{string-ref}
Returns character @emph{k} of @emph{string}. @emph{k} must be a valid
index of @emph{string}.

@verbatim
(string-ref "Hello" 1)          ==>  #\e
(string-ref "Hello" 5)          ERROR 5 not in correct range
@end verbatim

@node string-set! string k char
@subsection (string-set! @emph{string} @emph{k} @emph{char})
@anchor{string-set}
Stores @emph{char} (a single character string) in element @emph{k} of
@emph{string} and returns an unspecified value. @emph{k} must be a valid
index of @emph{string}.

@verbatim
(define s "Dog")              ==>  "Dog"
(string-set! s 0 #\L)         ==>  "Log"
s                             ==>  "Log"
(string-set! s 3 #\t)         ERROR 3 not in correct range
@end verbatim

@node Comparison of Strings
@section Comparison of Strings
@anchor{comparison-of-strings}
@menu
* string=? string1 string2::
* substring=? string1 start1 end1 string2 start2 end2::
* string-ci=? string1 string2::
* substring-ci=? string1 start1 end1 string2 start2 end2::
* string<? string1 string2::
* substring<? string1 start1 end1 string2 start2 end2::
* string-ci<? string1 string2::
* substring-ci<? string1 start1 end1 string2 start2 end2::
* string>? string1 string2::
* substring>? string1 start1 end1 string2 start2 end2::
* string-ci>? string1 string2::
* substring-ci>? string1 start1 end1 string2 start2 end2::
* string<=? string1 string2::
* substring<=? string1 start1 end1 string2 start2 end2::
* string-ci<=? string1 string2::
* substring-ci<=? string1 start1 end1 string2 start2 end2::
* string>=? string1 string2::
* substring>=? string1 start1 end1 string2 start2 end2::
* string-ci>=? string1 string2::
* substring-ci>=? string1 start1 end1 string2 start2 end2::
* string-compare string1 string2 if-eq if-lt if-gt::
* string-compare-ci string1 string2 if-eq if-lt if-gt::
@end menu

@node string=? string1 string2
@subsection (string=? @emph{string1} @emph{string2})
@anchor{string-eqp}

@node substring=? string1 start1 end1 string2 start2 end2
@subsection (substring=? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-eqp}

@node string-ci=? string1 string2
@subsection (string-ci=? @emph{string1} @emph{string2})
@anchor{string-ci-eqp}

@node substring-ci=? string1 start1 end1 string2 start2 end2
@subsection (substring-ci=? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ci-eqp}
Returns @code{@hashchar{}t} if the two strings (substrings) are the same length
and contain the same characters in the same (relative) positions;
otherwise returns @code{@hashchar{}f}. @code{string-ci=?} and
@code{substring-ci=?} don't distinguish uppercase and lowercase letters,
but @code{string=?} and @code{substring=?} do.

@verbatim
(string=? "PIE" "PIE")                  ==>  #t
(string=? "PIE" "pie")                  ==>  #f
(string-ci=? "PIE" "pie")               ==>  #t
(substring=? "Alamo" 1 3 "cola" 2 4)    ==>  #t ; compares "la"
@end verbatim

@node string<? string1 string2
@subsection (string<? @emph{string1} @emph{string2})
@anchor{string-ltp}

@node substring<? string1 start1 end1 string2 start2 end2
@subsection (substring<? string1 @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ltp}

@node string-ci<? string1 string2
@subsection (string-ci<? @emph{string1} @emph{string2})
@anchor{string-ci-ltp}

@node substring-ci<? string1 start1 end1 string2 start2 end2
@subsection (substring-ci<? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ci-ltp}

@node string>? string1 string2
@subsection (string>? @emph{string1} @emph{string2})
@anchor{string-gtp}

@node substring>? string1 start1 end1 string2 start2 end2
@subsection (substring>? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-gtp}

@node string-ci>? string1 string2
@subsection (string-ci>? @emph{string1} @emph{string2})
@anchor{string-ci-gtp}

@node substring-ci>? string1 start1 end1 string2 start2 end2
@subsection (substring-ci>? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ci-gtp}

@node string<=? string1 string2
@subsection (string<=? @emph{string1} @emph{string2})
@anchor{string-ltep}

@node substring<=? string1 start1 end1 string2 start2 end2
@subsection (substring<=? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ltep}

@node string-ci<=? string1 string2
@subsection (string-ci<=? @emph{string1} @emph{string2})
@anchor{string-ci-ltep}

@node substring-ci<=? string1 start1 end1 string2 start2 end2
@subsection (substring-ci<=? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ci-ltep}

@node string>=? string1 string2
@subsection (string>=? @emph{string1} @emph{string2})
@anchor{string-gtep}

@node substring>=? string1 start1 end1 string2 start2 end2
@subsection (substring>=? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-gtep}

@node string-ci>=? string1 string2
@subsection (string-ci>=? @emph{string1} @emph{string2})
@anchor{string-ci-gtep}

@node substring-ci>=? string1 start1 end1 string2 start2 end2
@subsection (substring-ci>=? @emph{string1} @emph{start1} @emph{end1} @emph{string2} @emph{start2} @emph{end2})
@anchor{substring-ci-gtep}
These procedures compare strings (substrings) according to the order of
the characters they contain. The arguments are compared using a
lexicographic (or dictionary) order. If two strings differ in length but
are the same up to the length of the shorter string, the shorter string
is considered to be less than the longer string.

@verbatim
(string<? "cat" "dog")          ==>  #t
(string<? "cat" "DOG")          ==>  #f
(string-ci<? "cat" "DOG")       ==>  #t
(string>? "catkin" "cat")       ==>  #t ; shorter is lesser
@end verbatim

@node string-compare string1 string2 if-eq if-lt if-gt
@subsection (string-compare @emph{string1} @emph{string2} @emph{if-eq} @emph{if-lt} @emph{if-gt})
@anchor{string-compare}

@node string-compare-ci string1 string2 if-eq if-lt if-gt
@subsection (string-compare-ci @emph{string1} @emph{string2} @emph{if-eq} @emph{if-lt} @emph{if-gt})
@anchor{string-compare-ci}
@emph{if-eq}, @emph{if-lt}, and @emph{if-gt} are procedures of no
arguments (thunks). The two strings are compared; if they are equal,
@emph{if-eq} is applied, if @emph{string1} is less than @emph{string2},
@emph{if-lt} is applied, else if @emph{string1} is greater than
@emph{string2}, @emph{if-gt} is applied. The value of the procedure is
the value of the thunk that is applied.

@code{string-compare} distinguishes uppercase and lowercase letters;
@code{string-compare-ci} does not.

@verbatim
(define (cheer) (display "Hooray!"))
(define (boo)   (display "Boo-hiss!"))
(string-compare "a" "b"  cheer  (lambda() 'ignore)  boo)
        -|  Hooray!
        ==>  unspecified
@end verbatim

In GoLisp, only @code{string-compare} and @code{string-compare-ci} are
available by default. If you want the other comparison functions you
need to @code{(load "lisp/strings.scm")}.

@node Alphabetic Case in Strings
@section Alphabetic Case in Strings
@anchor{alphabetic-case-in-strings}
@menu
* string-capitalized? string::
* substring-capitalized? string start end::
* string-upper-case? string::
* substring-upper-case? string start end::
* string-lower-case? string::
* substring-lower-case? string start end::
* string-capitalize string::
* string-capitalize! string::
* substring-capitalize! string start end::
* string-downcase string::
* string-downcase! string::
* substring-downcase! string start end::
* string-upcase string::
* string-upcase! string::
* substring-upcase! string start end::
@end menu

@node string-capitalized? string
@subsection (string-capitalized? @emph{string})
@anchor{string-capitalizedp}

@node substring-capitalized? string start end
@subsection (substring-capitalized? @emph{string} @emph{start} @emph{end})
@anchor{substring-capitalizedp}
These procedures return @code{@hashchar{}t} if the first word in the string
(substring) is capitalized, and any subsequent words are either lower
case or capitalized. Otherwise, they return @code{@hashchar{}f}. A word is defined
as a non-null contiguous sequence of alphabetic characters, delimited by
non-alphabetic characters or the limits of the string (substring). A
word is capitalized if its first letter is upper case and all its
remaining letters are lower case.

@verbatim
(map string-capitalized? '(""    "A"    "art"  "Art"  "ART"))
                       ==> (#f    #t     #f     #t     #f)
@end verbatim

@node string-upper-case? string
@subsection (string-upper-case? @emph{string})
@anchor{string-upper-casep}

@node substring-upper-case? string start end
@subsection (substring-upper-case? @emph{string} @emph{start} @emph{end})
@anchor{substring-upper-casep}

@node string-lower-case? string
@subsection (string-lower-case? @emph{string})
@anchor{string-lower-casep}

@node substring-lower-case? string start end
@subsection (substring-lower-case? @emph{string} @emph{start} @emph{end})
@anchor{substring-lower-casep}
These procedures return @code{@hashchar{}t} if all the letters in the string
(substring) are of the correct case, otherwise they return @code{@hashchar{}f}.
The string (substring) must contain at least one letter or the
procedures return @code{@hashchar{}f}.

@verbatim
(map string-upper-case?  '(""    "A"    "art"  "Art"  "ART"))
                       ==> (#f    #t     #f     #f     #t)
@end verbatim

@node string-capitalize string
@subsection (string-capitalize @emph{string})
@anchor{string-capitalize}

@node string-capitalize! string
@subsection (string-capitalize! @emph{string})
@anchor{string-capitalize-bang}

@node substring-capitalize! string start end
@subsection (substring-capitalize! @emph{string} @emph{start} @emph{end})
@anchor{substring-capitalize-bang}
@code{string-capitalize} returns a newly allocated copy of @emph{string}
in which the first alphabetic character is uppercase and the remaining
alphabetic characters are lowercase. For example, @code{"abcDEF"}
becomes @code{"Abcdef"}. @code{string-capitalize!} is the destructive
version of @code{string-capitalize}: it alters @emph{string} and returns
an unspecified value. @code{substring-capitalize!} destructively
capitalizes the specified part of @emph{string}.

@node string-downcase string
@subsection (string-downcase @emph{string})
@anchor{string-downcase}

@node string-downcase! string
@subsection (string-downcase! @emph{string})
@anchor{string-downcase-bang}

@node substring-downcase! string start end
@subsection (substring-downcase! @emph{string} @emph{start} @emph{end})
@anchor{substring-downcase-bang}
@code{string-downcase} returns a newly allocated copy of @emph{string}
in which all uppercase letters are changed to lowercase.
@code{string-downcase!} is the destructive version of
@code{string-downcase}: it alters @emph{string} and returns an
unspecified value. @code{substring-downcase!} destructively changes the
case of the specified part of @emph{string}.

@verbatim
(define str "ABCDEFG")          ==>  unspecified
(substring-downcase! str 3 5)   ==>  "ABCdeFG"
str                             ==>  "ABCdeFG"
@end verbatim

@node string-upcase string
@subsection (string-upcase @emph{string})
@anchor{string-upcase}

@node string-upcase! string
@subsection (string-upcase! @emph{string})
@anchor{string-upcase-bang}

@node substring-upcase! string start end
@subsection (substring-upcase! @emph{string} @emph{start} @emph{end})
@anchor{substring-upcase-bang}
@code{string-upcase} returns a newly allocated copy of @emph{string} in
which all lowercase letters are changed to uppercase.
@code{string-upcase!} is the destructive version of
@code{string-upcase}: it alters @emph{string} and returns an unspecified
value. @code{substring-upcase!} destructively changes the case of the
specified part of @emph{string}.

@node Cutting and Pasting Strings
@section Cutting and Pasting Strings
@anchor{cutting-and-pasting-strings}
@menu
* string-split string separator::
* string-join strings separator::
* string-append string@dots{}::
* substring string start end::
* string-head string end::
* string-tail string start::
* string-pad-left string k [char]::
* string-pad-right string k [char]::
* string-trim string [char-set]::
* string-trim-left string [char-set]::
* string-trim-right string [char-set]::
@end menu

@node string-split string separator
@subsection (string-split @emph{string} @emph{separator})
@anchor{string-split}
Splits @emph{string} into a list of substrings that are separated by
@emph{separator}.

@verbatim
(string-split "1-2-3" "-")) ==> ("1" "2" "3")
@end verbatim

@node string-join strings separator
@subsection (string-join @emph{strings} @emph{separator})
@anchor{string-join}
Joins the list of @emph{strings} into a single string by interposing
@emph{separator}.

@verbatim
(string-join '("1" "2" "3") "-") ==> "1-2-3"
@end verbatim

@node string-append string@dots{}
@subsection (string-append @emph{string}@dots{})
@anchor{string-append}
Returns a newly allocated string made from the concatenation of the
given strings.

@verbatim
(string-append)                 ==>  undefined
(string-append "*" "ace" "*")   ==>  "*ace*"
(string-append "" "" "")        ==>  ""
(eqv? str (string-append str))  ==>  #f ; newly allocated
@end verbatim

@node substring string start end
@subsection (substring @emph{string} @emph{start} @emph{end})
@anchor{substring}
Returns a newly allocated string formed from the characters of
@emph{string} beginning with index @emph{start} (inclusive) and ending
with @emph{end} (exclusive).

@verbatim
(substring "" 0 0)              ==> ""
(substring "arduous" 2 5)       ==> "duo"
(substring "arduous" 2 8)       ERROR 8 not in correct range

(define (string-copy s)
  (substring s 0 (string-length s)))
@end verbatim

@node string-head string end
@subsection (string-head @emph{string} @emph{end})
@anchor{string-head}
Returns a newly allocated copy of the initial substring of
@emph{string}, up to but excluding @emph{end}. It could have been
defined by:

@verbatim
(define (string-head string end)
  (substring string 0 end))

(string-head "uncommon" 2)      ==> "un"
@end verbatim

@node string-tail string start
@subsection (string-tail @emph{string} @emph{start})
@anchor{string-tail}
Returns a newly allocated copy of the final substring of @emph{string},
starting at index @emph{start} and going to the end of @emph{string}. It
could have been defined by:

@verbatim
(define (string-tail string start)
  (substring string start (string-length string)))

(string-tail "uncommon" 2)      ==>  "common"
@end verbatim

@node string-pad-left string k [char]
@subsection (string-pad-left @emph{string} @emph{k} [@emph{char}])
@anchor{string-pad-left}

@node string-pad-right string k [char]
@subsection (string-pad-right @emph{string} @emph{k} [@emph{char}])
@anchor{string-pad-right}
These procedures return a newly allocated string created by padding
@emph{string} out to length @emph{k}, using @emph{char}. If @emph{char}
is not given, it defaults to @code{#\space}. If @emph{k} is less than
the length of @emph{string}, the resulting string is a truncated form of
@emph{string}. @code{string-pad-left} adds padding characters or
truncates from the beginning of the string (lowest indices), while
@code{string-pad-right} does so at the end of the string (highest
indices).

@verbatim
(string-pad-left "hello" 4)             ==>  "ello"
(string-pad-left "hello" 8)             ==>  "   hello"
(string-pad-left "hello" 8 #\*)         ==>  "***hello"
(string-pad-right "hello" 4)            ==>  "hell"
(string-pad-right "hello" 8)            ==>  "hello   "
(string-pad-right "hello" 8 #\*)        ==>  "hello***"
@end verbatim

@node string-trim string [char-set]
@subsection (string-trim @emph{string} [@emph{char-set}])
@anchor{string-trim}

@node string-trim-left string [char-set]
@subsection (string-trim-left @emph{string} [@emph{char-set}])
@anchor{string-trim-left}

@node string-trim-right string [char-set]
@subsection (string-trim-right @emph{string} [@emph{char-set}])
@anchor{string-trim-right}
Returns a newly allocated string created by removing all characters that
are not in @emph{char-set} from: @code{string-trim} both ends of
@emph{string}; @code{string-trim-left} the beginning of @emph{string};
or @code{string-trim-right} the end of @emph{string}. @emph{char-set}
defaults to @code{char-set:not-whitespace}.

@verbatim
(string-trim "  in the end  ")          ==>  "in the end"
(string-trim "              ")          ==>  ""
(string-trim "100th" char-set:numeric)  ==>  "100"
(string-trim-left "-.-+-=-" (char-set #\+))
                                        ==>  "+-=-"
(string-trim "but (+ x y) is" (char-set #\( #\)))
                                        ==>  "(+ x y)"
@end verbatim

@node Regexp Support
@section Regexp Support
@anchor{regexp-support}
There is some preliminary support for regular expressions.
@menu
* re-string-match-go regexp string::
@end menu

@node re-string-match-go regexp string
@subsection (re-string-match-go @emph{regexp} @emph{string})
@anchor{re-string-match-go}
This matches regexp against the respective string, returning #f for no
match, or a list of strings (see below) if the match succeeds.

When a successful match occurs, the above procedure returns a list of
strings. Each string corresponds to an instance of the
regular-expression grouping operator `('. Additionally, the first string
corresponds to the entire substring matching the regular expression.

Note that this is different from the Scheme matching procedure.

@node Lists
@chapter Lists
@anchor{lists}
A ``pair'' (sometimes called a ``dotted pair'') is a data structure with
two fields called the ``car'' and ``cdr'' fields (for historical
reasons). Pairs are created by the procedure @code{cons}. The car and
cdr fields are accessed by the procedures @code{car} and @code{cdr}. The
car and cdr fields are assigned by the procedures @code{set-car!} and
@code{set-cdr!}.

Pairs are used primarily to represent ``lists''. A list can be defined
recursively as either the empty list or a pair whose cdr is a list. More
precisely, the set of lists is defined as the smallest set X such that

@itemize
@item
The empty list is in X.

@item
If LIST is in X, then any pair whose cdr field contains LIST is also in
X.

@end itemize

The objects in the car fields of successive pairs of a list are the
``elements'' of the list. For example, a two-element list is a pair
whose car is the first element and whose cdr is a pair whose car is the
second element and whose cdr is the empty list. The ``length'' of a list
is the number of elements, which is the same as the number of pairs. The
``empty list'' is a special object of its own type (it is not a pair);
it has no elements and its length is zero.

The most general notation (external representation) for GoLisp pairs is
the ``dotted'' notation @code{(C1 . C2)} where C1 is the value of the
car field and C2 is the value of the cdr field. For example,
@code{(4 . 5)} is a pair whose car is @code{4} and whose cdr is
@code{5}. Note that @code{(4 . 5)} is the external representation of a
pair, not an expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces. The
empty list is written @code{()}. For example, the following are
equivalent notations for a list of symbols:

@verbatim
(a b c d e)
(a . (b . (c . (d . (e . ())))))
@end verbatim

Whether a given pair is a list depends upon what is stored in the cdr
field. When the @code{set-cdr!} procedure is used, an object can be a
list one moment and not the next:

@verbatim
(define x (list 'a 'b 'c))
(define y x)
y                                       ==> (a b c)
(list? y)                               ==> #t
(set-cdr! x 4)                          ==> (a . 4)
x                                       ==> (a . 4)
(eqv? x y)                              ==> #t
y                                       ==> (a . 4)
(list? y)                               ==> #f
(set-cdr! x x)                          ==> <Unprintable looping pair structure>
(list? y)                               ==> #f
@end verbatim

A chain of pairs that doesn't end in the empty list is called an
``improper list''. Note that an improper list is not a list. The list
and dotted notations can be combined to represent improper lists, as the
following equivalent notations show:

@verbatim
(a b c . d)
(a . (b . (c . d)))
@end verbatim

Within literal expressions and representations of objects read by the
@code{read} procedure, the forms @code{'DATUM}, @code{`DATUM},
@code{,DATUM}, and @code{,@@DATUM} denote two-element lists whose first
elements are the symbols @code{quote}, @code{quasiquote},
@code{unquote}, and @code{unquote-splicing}, respectively. The second
element in each case is DATUM. This convention is supported so that
arbitrary GoLisp programs may be represented as lists. Among other
things, this permits the use of the @code{read} procedure to parse
Scheme programs.
@menu
* Pairs::
* Construction of Lists::
* Selecting List Components::
* Cutting and Pasting Lists::
* Filtering Lists::
* Searching Lists::
* Mapping of Lists::
* Reduction of Lists::
* Miscellaneous List Operations::
@end menu

@node Pairs
@section Pairs
@anchor{pairs}
This section describes the simple operations that are available for
constructing and manipulating arbitrary graphs constructed from pairs.
@menu
* pair? object::
* cons obj1 obj2::
* car pair::
* cdr pair::
* set-car! pair object::
* set-cdr! pair object::
* set-nth! n list new-value::
* caar pair::
* cadr pair::
* cdar pair::
* cddr pair::
* caaar pair::
* caadr pair::
* cadar pair::
* caddr pair::
* cdaar pair::
* cdadr pair::
* cddar pair::
* cdddr pair::
* caaaar pair::
* caaadr pair::
* caadar pair::
* caaddr pair::
* cadaar pair::
* cadadr pair::
* caddar pair::
* cadddr pair::
* cdaaar pair::
* cdaadr pair::
* cdadar pair::
* cdaddr pair::
* cddaar pair::
* cddadr pair::
* cdddar pair::
* cddddr pair::
* general-car-cdr object path::
* copy object::
@end menu

@node pair? object
@subsection (pair? @emph{object})
@anchor{pairp}
Returns @code{@hashchar{}t} if @emph{object} is a pair; otherwise returns
@code{@hashchar{}f}.

@verbatim
(pair? '(a . b))                        ==> #t
(pair? '(a b c))                        ==> #t
(pair? '())                             ==> #f
(pair? '#(a b))                         ==> #f
@end verbatim

@node cons obj1 obj2
@subsection (cons @emph{obj1} @emph{obj2})
@anchor{cons}
Returns a newly allocated pair whose car is @emph{obj1} and whose cdr is
@emph{obj2}. The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every previously existing object.

@verbatim
(cons 'a '())                           ==> (a)
(cons '(a) '(b c d))                    ==> ((a) b c d)
(cons "a" '(b c))                       ==> ("a" b c)
(cons 'a 3)                             ==> (a . 3)
(cons '(a b) 'c)                        ==> ((a b) . c)
@end verbatim

@node car pair
@subsection (car @emph{pair})
@anchor{car}
Returns the contents of the car field of @emph{pair}. Note that taking
the @code{car} of the empty list results in the empty list.

@verbatim
(car '(a b c))                          ==> a
(car '((a) b c d))                      ==> (a)
(car '(1 . 2))                          ==> 1
(car '())                               ==> ()
@end verbatim

@node cdr pair
@subsection (cdr @emph{pair})
@anchor{cdr}
Returns the contents of the cdr field of @emph{pair}. Note that taking
the @code{cdr} of the empty list results in the empty list.

@verbatim
(cdr '((a) b c d))                      ==> (b c d)
(cdr '(1 . 2))                          ==> 2
(cdr '())                               ==> ()
@end verbatim

@node set-car! pair object
@subsection (set-car! @emph{pair} @emph{object})
@anchor{set-car}
Stores @emph{object} in the car field of @emph{pair}. The value returned
by @code{set-car!} is unspecified.

@verbatim
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)                        ==> unspecified
(set-car! (g) 3)                        ERROR Illegal datum
@end verbatim

@node set-cdr! pair object
@subsection (set-cdr! @emph{pair} @emph{object})
@anchor{set-cdr}
Stores @emph{object} in the cdr field of @emph{pair}. The value returned
by @code{set-cdr!} is unspecified.

@node set-nth! n list new-value
@subsection (set-nth! @emph{n} @emph{list} @emph{new-value})
@anchor{set-nth}
Set the @code{car} pointer of the nth cons cell of @emph{list}.
Numbering starts at 1.

@verbatim
(define a '(1 2 3 4))
(set-nth! 3 a 0)
a ==> (1 2 0 4)
@end verbatim

@node caar pair
@subsection (caar @emph{pair})
@anchor{caar}

@node cadr pair
@subsection (cadr @emph{pair})
@anchor{cadr}

@node cdar pair
@subsection (cdar @emph{pair})
@anchor{cdar}

@node cddr pair
@subsection (cddr @emph{pair})
@anchor{cddr}

@node caaar pair
@subsection (caaar @emph{pair})
@anchor{caaar}

@node caadr pair
@subsection (caadr @emph{pair})
@anchor{caadr}

@node cadar pair
@subsection (cadar @emph{pair})
@anchor{cadar}

@node caddr pair
@subsection (caddr @emph{pair})
@anchor{caddr}

@node cdaar pair
@subsection (cdaar @emph{pair})
@anchor{cdaar}

@node cdadr pair
@subsection (cdadr @emph{pair})
@anchor{cdadr}

@node cddar pair
@subsection (cddar @emph{pair})
@anchor{cddar}

@node cdddr pair
@subsection (cdddr @emph{pair})
@anchor{cdddr}

@node caaaar pair
@subsection (caaaar @emph{pair})
@anchor{caaaar}

@node caaadr pair
@subsection (caaadr @emph{pair})
@anchor{caaadr}

@node caadar pair
@subsection (caadar @emph{pair})
@anchor{caadar}

@node caaddr pair
@subsection (caaddr @emph{pair})
@anchor{caaddr}

@node cadaar pair
@subsection (cadaar @emph{pair})
@anchor{cadaar}

@node cadadr pair
@subsection (cadadr @emph{pair})
@anchor{cadadr}

@node caddar pair
@subsection (caddar @emph{pair})
@anchor{caddar}

@node cadddr pair
@subsection (cadddr @emph{pair})
@anchor{cadddr}

@node cdaaar pair
@subsection (cdaaar @emph{pair})
@anchor{cdaaar}

@node cdaadr pair
@subsection (cdaadr @emph{pair})
@anchor{cdaadr}

@node cdadar pair
@subsection (cdadar @emph{pair})
@anchor{cdadar}

@node cdaddr pair
@subsection (cdaddr @emph{pair})
@anchor{cdaddr}

@node cddaar pair
@subsection (cddaar @emph{pair})
@anchor{cddaar}

@node cddadr pair
@subsection (cddadr @emph{pair})
@anchor{cddadr}

@node cdddar pair
@subsection (cdddar @emph{pair})
@anchor{cdddar}

@node cddddr pair
@subsection (cddddr @emph{pair})
@anchor{cddddr}
These procedures are compositions of @code{car} and @code{cdr}; for
example, @code{caddr} could be defined by

@verbatim
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end verbatim

@node general-car-cdr object path
@subsection (general-car-cdr @emph{object} @emph{path})
@anchor{general-car-cdr}
This procedure is a generalization of @code{car} and @code{cdr}.
@emph{path} encodes a particular sequence of @code{car} and @code{cdr}
operations, which @code{general-car-cdr} executes on @emph{object}.
@emph{path} is a non-negative integer that encodes the operations in a
bitwise fashion: a zero bit represents a @code{cdr} operation, and a one
bit represents a @code{car}. The bits are executed LSB to MSB, and the
most significant one bit, rather than being interpreted as an operation,
signals the end of the sequence.

For example, the following are equivalent:

@verbatim
(general-car-cdr OBJECT #b1011)
(cdr (car (car OBJECT)))
@end verbatim

Here is a partial table of path/operation equivalents:

@verbatim
#b10    cdr
#b11    car
#b100   cddr
#b101   cdar
#b110   cadr
#b111   caar
#b1000  cdddr
@end verbatim

@node Construction of Lists
@section Construction of Lists
@anchor{construction-of-lists}
@menu
* list object@dots{}::
* make-list k [element]::
* cons* object object @dots{}::
* make-initialized-list k init-proc::
* list-copy list::
* iota count [start [step]]::
* interval hi::
* interval lo hi::
* interval lo hi step::
* string->list string::
* substring->list string start end::
@end menu

@node list object@dots{}
@subsection (list @emph{object}@dots{})
@anchor{list}
Returns a list of its arguments.

@verbatim
(list 'a (+ 3 4) 'c)                    ==> (a 7 c)
(list)                                  ==> ()
@end verbatim

These expressions are equivalent:

@verbatim
(list OBJ1 OBJ2 ... OBJN)
(cons OBJ1 (cons OBJ2 ... (cons OBJN '()) ...))
@end verbatim

@node make-list k [element]
@subsection (make-list k [element])
@anchor{make-list}
This procedure returns a newly allocated list of length @emph{k}, whose
elements are all @emph{element}. If @emph{element} is not supplied, it
defaults to the empty list.

@verbatim
(make-list 4 'c)                        ==> (c c c c)
@end verbatim

@node cons* object object @dots{}
@subsection (cons* object object @dots{})
@anchor{cons-star}
@code{cons*} is similar to @code{list}, except that @code{cons*} conses
together the last two arguments rather than consing the last argument
with the empty list. If the last argument is not a list the result is an
improper list. If the last argument is a list, the result is a list
consisting of the initial arguments and all of the items in the final
argument. If there is only one argument, the result is the argument.

@verbatim
(cons* 'a 'b 'c)                        ==> (a b . c)
(cons* 'a 'b '(c d))                    ==> (a b c d)
(cons* 'a)                              ==> a
@end verbatim

These expressions are equivalent:

@verbatim
(cons* OBJ1 OBJ2 ... OBJN-1 OBJN)
(cons OBJ1 (cons OBJ2 ... (cons OBJN-1 OBJN) ...))
@end verbatim

@node make-initialized-list k init-proc
@subsection (make-initialized-list k init-proc)
@anchor{make-initialized-list}
Returns a @emph{K}-element list. Element I of the list, where 0 <= I <
@emph{k}, is produced by @code{(init-proc I)}. No guarantee is made
about the dynamic order in which @emph{init-proc} is applied to these
indices.

@verbatim
(make-initialized-list 4 (lambda (x) (* x x))) ==> (0 1 4 9)
@end verbatim

@node list-copy list
@subsection (list-copy list)
@anchor{list-copy}
Returns a newly allocated copy of @emph{list}. This copies each of the
pairs comprising @emph{list}. This could have been defined by

@verbatim
(define (list-copy list)
  (if (null? list)
      '()
      (cons (car list)
            (list-copy (cdr list)))))
@end verbatim

@node iota count [start [step]]
@subsection (iota count [start [step]])
@anchor{iota}
Returns a list containing the elements

@verbatim
(START START+STEP ... START+(COUNT-1)*STEP)
@end verbatim

@emph{count} must be a non-negative integer, while @emph{start} and
@emph{step} can be any numbers. The @emph{start} and @emph{step}
parameters default to 0 and 1, respectively.

@verbatim
(iota 5)          ==>  (0 1 2 3 4)
(iota 5 0 -0.1)   ==>  (0 -0.1 -0.2 -0.3 -0.4)
@end verbatim

@node interval hi
@subsection (interval @emph{hi})
@anchor{interval-hi}

@node interval lo hi
@subsection (interval @emph{lo} @emph{hi})
@anchor{interval-lo-hi}

@node interval lo hi step
@subsection (interval @emph{lo} @emph{hi} @emph{step})
@anchor{interval-lo-hi-step}
The first form creates a list of numbers from 1 to @code{hi}, inclusive.
@code{hi} @strong{must} be a positive integer.

@verbatim
(interval 5) ==> (1 2 3 4 5)
(interval 2) ==> (1 2)
@end verbatim

The second form creates a list of numbers from @code{lo} to @code{hi},
inclusive, stepping by 1. If @code{lo} > @code{hi}, a step of -1 is
used.

@verbatim
(interval 1 5) ==> (1 2 3 4 5)
(interval -2 2) ==> (-2 -1 0 1 2)
(interval 5 1) ==> (5 4 3 2 1)
(interval 2 -2) ==> (2 1 0 -1 -2)
@end verbatim

The third form creates a list of numbers from @code{lo} to @code{hi},
inclusive (if possible), @code{step} apart. @code{step} @strong{must} be
non-zero and it's sign must match the ordering of @code{lo} and
@code{hi}. I.e. if @code{lo} > @code{hi}, @code{step} must be negative,
otherwise positive.

@verbatim
(interval 1 5 2) ==> (1 3 5)
(interval 1 8 2) ==> (1 3 5 7)
(interval -2 2 2) ==> (-2 0 2)
(interval 2 -2 -2) ==> (2 0 -2)
(interval 5 1 -2) ==> (5 3 1)
(interval -1 -8 -2) ==> (-1 -3 -5 -7)
@end verbatim

@node string->list string
@subsection (string->list string)
@anchor{string-to-list}

@node substring->list string start end
@subsection (substring->list string start end)
@anchor{substring-to-list}
@code{string->list} returns a newly allocated list of the character
elements of @emph{string}. @code{substring->list} returns a newly
allocated list of the character elements of the given substring. The
inverse of @code{string->list} is @code{list->string}.

@verbatim
(string->list "abcd")                   ==> (#\a #\b #\c #\d)
(substring->list "abcdef" 1 3)          ==> (#\b #\c)
@end verbatim

@node Selecting List Components
@section Selecting List Components
@anchor{selecting-list-components}
@menu
* list? object::
* circular-list? object::
* dotted-list? object::
* length list::
* length+ clist::
* null? object::
* nil? object::
* notnull? object::
* notnil? object::
* list-ref list k::
* nth k list::
* first list::
* second list::
* third list::
* fourth list::
* fifth list::
* sixth list::
* seventh list::
* eighth list::
* ninth list::
* tenth list::
* last list::
@end menu

@node list? object
@subsection (list? @emph{object})
@anchor{listp}
Returns @code{@hashchar{}t} if @emph{object} is a list, otherwise returns
@code{@hashchar{}f}. By definition, all lists have finite length and are
terminated by the empty list. This procedure returns an answer even for
circular structures.

Any @emph{object} satisfying this predicate will also satisfy exactly
one of @code{pair?} or @code{null?}.

@verbatim
(list? '(a b c))                        ==> #t
(list? '())                             ==> #t
(list? '(a . b))                        ==> #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))                            ==> #f
@end verbatim

@node circular-list? object
@subsection (circular-list? @emph{object})
@anchor{circular-listp}
Returns @code{@hashchar{}t} if @emph{object} is a circular list, otherwise returns
@code{@hashchar{}f}.

@verbatim
(circular-list? (list 'a 'b 'c))        ==> #f
(circular-list? (cons* 'a 'b 'c))       ==> #f
(circular-list? (circular-list 'a 'b 'c)) ==> #t
@end verbatim

@node dotted-list? object
@subsection (dotted-list? @emph{object})
@anchor{dotted-listp}
Returns @code{@hashchar{}t} if @emph{object} is an improper list, otherwise
returns @code{@hashchar{}f}.

@verbatim
(dotted-list? (list 'a 'b 'c))          ==> #f
(dotted-list? (cons* 'a 'b 'c))         ==> #t
(dotted-list? (circular-list 'a 'b 'c)) ==> #f
@end verbatim

@node length list
@subsection (length @emph{list})
@anchor{length}
Returns the length of @emph{list}. Signals an error if @emph{list} isn't
a proper list.

@verbatim
(length '(a b c))                       ==> 3
(length '(a (b) (c d e)))               ==> 3
(length '())                            ==> 0
(length (circular-list 'a 'b 'c))       ERROR
@end verbatim

@node length+ clist
@subsection (length+ @emph{clist})
@anchor{length-plus}
Returns the length of @emph{clist}, if it is a proper list. Returns
@code{@hashchar{}f} if @emph{clist} is a circular list. Otherwise signals an
error.

@verbatim
(length+ (list 'a 'b 'c))               ==> 3
(length+ (cons* 'a 'b 'c))              ERROR
(length+ (circular-list 'a 'b 'c))      ==> #f
@end verbatim

@node null? object
@subsection (null? @emph{object})
@anchor{nullp}

@node nil? object
@subsection (nil? @emph{object})
@anchor{nilp}
Returns @code{@hashchar{}t} if @emph{object} is the empty list; otherwise returns
@code{@hashchar{}f}.

@verbatim
(null? '(a . b))                        ==> #f
(null? '(a b c))                        ==> #f
(null? '())                             ==> #t
@end verbatim

@node notnull? object
@subsection (notnull? @emph{object})
@anchor{notnullp}

@node notnil? object
@subsection (notnil? @emph{object})
@anchor{notnilp}
Returns @code{@hashchar{}f} if @emph{object} is the empty list; otherwise returns
@code{@hashchar{}t}.

@verbatim
(notnull? '(a . b))                        ==> #f
(notnull? '(a b c))                        ==> #f
(notnull? '())                             ==> #t
@end verbatim

@node list-ref list k
@subsection (list-ref @emph{list} @emph{k})
@anchor{list-ref-list-k}

@node nth k list
@subsection (nth @emph{k} @emph{list})
@anchor{nth-k-list}
Returns the @emph{k_th element of _list}, using zero-origin indexing.
The ``valid indexes'' of a list are the non-negative integers less than
the length of the list. The first element of a list has index @code{0},
the second has index @code{1}, and so on. @code{nth} is provided for
Common Lisp familiarity.

@verbatim
(list-ref '(a b c d) 2)                 ==> c
@end verbatim

@node first list
@subsection (first @emph{list})
@anchor{first-list}

@node second list
@subsection (second @emph{list})
@anchor{second-list}

@node third list
@subsection (third @emph{list})
@anchor{third-list}

@node fourth list
@subsection (fourth @emph{list})
@anchor{fourth-list}

@node fifth list
@subsection (fifth @emph{list})
@anchor{fifth-list}

@node sixth list
@subsection (sixth @emph{list})
@anchor{sixth-list}

@node seventh list
@subsection (seventh @emph{list})
@anchor{seventh-list}

@node eighth list
@subsection (eighth @emph{list})
@anchor{eighth-list}

@node ninth list
@subsection (ninth @emph{list})
@anchor{ninth-list}

@node tenth list
@subsection (tenth @emph{list})
@anchor{tenth-list}
Returns the specified element of @emph{list}. It is an error if
@emph{list} is not long enough to contain the specified element (for
example, if the argument to @code{seventh} is a list that contains only
six elements).

@node last list
@subsection (last @emph{list})
@anchor{last-list}
Returns the last element in the list. An error is raised if @emph{list}
is a circular list.

@node Cutting and Pasting Lists
@section Cutting and Pasting Lists
@anchor{cutting-and-pasting-lists}
@menu
* sublist list start end::
* list-head list k::
* take k list::
* list-tail list k::
* drop k list::
* append list@dots{}::
* append! list@dots{}::
* last-pair list::
* except-last-pair list::
* except-last-pair! list::
@end menu

@node sublist list start end
@subsection (sublist @emph{list} @emph{start} @emph{end})
@anchor{sublist-list-start-end}
@emph{start} and @emph{end} must be integers satisfying

@verbatim
0 <= START <= END <= (length LIST)
@end verbatim

`sublist' returns a newly allocated list formed from the elements of
@emph{list} beginning at index @emph{start} (inclusive) and ending at
@emph{end} (exclusive).

@node list-head list k
@subsection (list-head @emph{list} @emph{k})
@anchor{list-head-list-k}

@node take k list
@subsection (take @emph{k} @emph{list})
@anchor{take-k-list}
Returns a newly allocated list consisting of the first K elements of
@emph{list}. @emph{k} must not be greater than the length of
@emph{list}.

We could have defined @code{list-head} this way:

@verbatim
      (define (list-head list k)
        (sublist list 0 k))
@end verbatim

@node list-tail list k
@subsection (list-tail @emph{list} @emph{k})
@anchor{list-tail-list-k}

@node drop k list
@subsection (drop @emph{k} @emph{list})
@anchor{drop-k-list}
Returns the sublist of @emph{list} obtained by omitting the first
@emph{k} elements. The result, if it is not the empty list, shares
structure with @emph{list}. @emph{k} must not be greater than the length
of @emph{list}.

@node append list@dots{}
@subsection (append @emph{list}@dots{})
@anchor{append-list}
Returns a list consisting of the elements of the first @emph{list}
followed by the elements of the other @emph{list} arguments.

@verbatim
(append '(x) '(y))                      ==> (x y)
(append '(a) '(b c d))                  ==> (a b c d)
(append '(a (b)) '((c)))                ==> (a (b) (c))
(append)                                ==> ()
@end verbatim

The resulting list is always newly allocated, except that it shares
structure with the last @emph{list} argument. The last argument may
actually be any object; an improper list results if the last argument is
not a proper list.

@verbatim
(append '(a b) '(c . d))                ==> (a b c . d)
(append '() 'a)                         ==> a
@end verbatim

@node append! list@dots{}
@subsection (append! @emph{list}@dots{})
@anchor{append-list-1}
Returns a list that is the all the @emph{list} arguments concatenated
together. The arguments are changed rather than copied. (Compare this
with @code{append}, which copies arguments rather than destroying them.)
For example:

@verbatim
(define x '(a b c))
(define y '(d e f))
(define z '(g h))
(append! x y z)                         ==> (a b c d e f g h)
x                                       ==> (a b c d e f g h)
y                                       ==> (d e f g h)
z                                       ==> (g h)
@end verbatim

@node last-pair list
@subsection (last-pair @emph{list})
@anchor{last-pair-list}
Returns the last pair in @emph{list}, which may be an improper list.
@code{last-pair} could have been defined this way:

@verbatim
(define last-pair
  (lambda (x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x)))
@end verbatim

@node except-last-pair list
@subsection (except-last-pair @emph{list})
@anchor{except-last-pair-list}

@node except-last-pair! list
@subsection (except-last-pair! @emph{list})
@anchor{except-last-pair-list-1}
These procedures remove the last pair from @emph{list}. @emph{list} may
be an improper list, except that it must consist of at least one pair.
@code{except-last-pair} returns a newly allocated copy of @emph{list}
that omits the last pair. @code{except-last-pair!} destructively removes
the last pair from @emph{list} and returns @emph{list}. If the cdr of
@emph{list} is not a pair, the empty list is returned by either
procedure.

@node Filtering Lists
@section Filtering Lists
@anchor{filtering-lists}
@menu
* filter predicate list::
* remove predicate list::
* partition predicate list::
* partition size step list::
* delq element list::
* delv element list::
* delete element list::
@end menu

@node filter predicate list
@subsection (filter @emph{predicate} @emph{list})
@anchor{filter-predicate-list}
Returns a newly allocated copy of @emph{list} containing only the
elements satisfying @emph{predicate}. @emph{predicate} must be a
procedure of one argument.

@verbatim
(filter odd? '(1 2 3 4 5)) ==> (1 3 5)
@end verbatim

@node remove predicate list
@subsection (remove @emph{predicate} @emph{list})
@anchor{remove-predicate-list}
Like @code{filter}, except that the returned list contains only those
elements @strong{not} satisfying @emph{predicate}.

@verbatim
(remove odd? '(1 2 3 4 5)) ==> (2 4)
@end verbatim

@node partition predicate list
@subsection (partition @emph{predicate} @emph{list})
@anchor{partition-predicate-list}

@node partition size step list
@subsection (partition @emph{size} @emph{step} @emph{list})
@anchor{partition-size-step-list}
The first form partitions the elements of @emph{list} with
@emph{predicate}, and returns a list of two elements: the list of
in-elements and the list of out-elements. The @emph{list} is not
disordered--elements occur in the result lists in the same order as they
occur in the argument @emph{list}. The dynamic order in which the
various applications of @emph{predicate} are made is not specified. One
of the returned lists may share a common tail with the argument
@emph{list}.

@verbatim
(partition symbol? '(one 2 3 four five 6)) ==>
    ((one four five) (2 3 6))
@end verbatim

The second form partitions the elements of @emph{list} into lists of
length @emph{size}, returning a list of those lists. Only lists of
@emph{size} are returned; any at the end that don't fit are discarded.
As with the first form, elements occur in the result lists in the same
order as they occur in the argument @emph{list}. If the optional
@emph{step} argument is ommitted it defaults to size. Each sublist
starts at @emph{step} elements from the start of the previous. If
@emph{step} > @emph{size} elements will be skipped between sublists. If
@emph{step} < @emph{size} the sublists will overlap.

@verbatim
(partition 2 '(one 2 3 four five 6))    ==> ((one 2) (3 four) (five 6))

(partition 2 '(one 2 3 four five 6 7))  ==> ((one 2) (3 four) (five 6))

(partition 2 1 '(1 2 3 4 5 6 7 8 9 0)) ==> ((1 2) (2 3) (3 4) (4 5) (5 6)
                                            (6 7) (7 8) (8 9))

(partition 2 3 '(1 2 3 4 5 6 7 8 9 0)) ==> ((1 2) (4 5) (7 8))
@end verbatim

@node delq element list
@subsection (delq element list)
@anchor{delq-element-list}

@node delv element list
@subsection (delv element list)
@anchor{delv-element-list}

@node delete element list
@subsection (delete element list)
@anchor{delete-element-list}
Returns a newly allocated copy of @emph{list} with all entries equal to
@emph{element} removed. @code{delq} uses @code{eq?} to compare
@emph{element} with the entries in @emph{list}, @code{delv} uses
@code{eqv?}, and @code{delete} uses @code{equal?}.

@node Searching Lists
@section Searching Lists
@anchor{searching-lists}
@menu
* find predicate list::
* find-tail predicate list::
* memq object list::
* memv object list::
* member object list::
* memp predicate list::
@end menu

@node find predicate list
@subsection (find @emph{predicate} @emph{list})
@anchor{find-predicate-list}
Returns the first element in @emph{list} for which @emph{predicate} is
true; returns @code{@hashchar{}f} if it doesn't find such an element.
@emph{predicate} must be a procedure of one argument.

@verbatim
(find even? '(3 1 4 1 5 9)) ==> 4
@end verbatim

Note that @code{find} has an ambiguity in its lookup semantics--if
@code{find} returns @code{@hashchar{}f}, you cannot tell (in general) if it found
a @code{@hashchar{}f} element that satisfied @emph{predicate}, or if it did not
find any element at all. In many situations, this ambiguity cannot
arise--either the list being searched is known not to contain any
@code{@hashchar{}f} elements, or the list is guaranteed to have an element
satisfying @emph{predicate}. However, in cases where this ambiguity can
arise, you should use @code{find-tail} instead of @code{find} --
@code{find-tail} has no such ambiguity:

@verbatim
(cond ((find-tail pred lis)
        => (lambda (pair) ...)) ; Handle (CAR PAIR)
      (else ...)) ; Search failed.
@end verbatim

@node find-tail predicate list
@subsection (find-tail @emph{predicate} @emph{list})
@anchor{find-tail-predicate-list}
Returns the first pair of @emph{list} whose car satisfies
@emph{predicate}; returns @code{@hashchar{}f} if there's no such pair.
@code{find-tail} can be viewed as a general-predicate variant of
@code{memv}.

@node memq object list
@subsection (memq @emph{object} @emph{list})
@anchor{memq-object-list}

@node memv object list
@subsection (memv @emph{object} @emph{list})
@anchor{memv-object-list}

@node member object list
@subsection (member @emph{object} @emph{list})
@anchor{member-object-list}
These procedures return the first pair of @emph{list} whose car is
@emph{object}; the returned pair is always one from which @emph{list} is
composed. If @emph{object} does not occur in @emph{list}, @code{@hashchar{}f}
(n.b.: not the empty list) is returned. @code{memq} uses @code{eq?} to
compare @emph{object} with the elements of @emph{list}, while
@code{memv} uses @code{eqv?} and @code{member} uses @code{equal?}.

@verbatim
(memq 'a '(a b c))                      ==> (a b c)
(memq 'b '(a b c))                      ==> (b c)
(memq 'a '(b c d))                      ==> #f
(memq (list 'a) '(b (a) c))             ==> #f
(member (list 'a) '(b (a) c))           ==> ((a) c)
(memq 101 '(100 101 102))               ==> (101 102)
(memv 101 '(100 101 102))               ==> (101 102)
@end verbatim

Although they are often used as predicates, @code{memq}, @code{memv},
and @code{member} do not have question marks in their names because they
return useful values rather than just @code{@hashchar{}t} or @code{@hashchar{}f}.

@node memp predicate list
@subsection (memp @emph{predicate} @emph{list})
@anchor{memp-predicate-list}
Returns the first pair of @emph{list} for which @emph{predicate} returns
@code{@hashchar{}t} when passed the car; the returned pair is always one from
which @emph{list} is composed. If @emph{predicate} never returns
@code{@hashchar{}t}, @code{@hashchar{}f} (n.b.: not the empty list) is returned.

@node Mapping of Lists
@section Mapping of Lists
@anchor{mapping-of-lists}
@menu
* map procedure list@dots{}::
* for-each procedure list @dots{}::
@end menu

@node map procedure list@dots{}
@subsection (map @emph{procedure} @emph{list}@dots{})
@anchor{map-procedure-list}
@emph{procedure} must be a procedure taking as many arguments as there
are @emph{lists}. If more than one @emph{list} is given, then they must
all be the same length. @code{map} applies @emph{procedure} element-wise
to the elements of the @emph{lists} and returns a list of the results,
in order from left to right. The dynamic order in which @emph{procedure}
is applied to the elements of the @emph{lists} is unspecified; use
@code{for-each} to sequence side effects.

@verbatim
(map cadr '((a b) (d e) (g h)))           ==> (b e h)
(map (lambda (n) (expt n n)) '(1 2 3 4))  ==> (1 4 27 256)
(map + '(1 2 3) '(4 5 6))                 ==> (5 7 9)
(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b c)))                         ==> unspecified
@end verbatim

@node for-each procedure list @dots{}
@subsection (for-each @emph{procedure} @emph{list} @dots{})
@anchor{for-each-procedure-list}
The arguments to @code{for-each} are like the arguments to @code{map},
but @code{for-each} calls @emph{procedure} for its side effects rather
than for its values. Unlike @code{map}, @code{for-each} is guaranteed to
call @emph{procedure} on the elements of the @emph{lists} in order from
the first element to the last, and the value returned by @code{for-each}
is unspecified.

@verbatim
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                            ==> #(0 1 4 9 16)
@end verbatim

@node Reduction of Lists
@section Reduction of Lists
@anchor{reduction-of-lists}
@menu
* reduce procedure initial list::
* reduce-left procedure initial list::
* reduce-right procedure initial list::
* fold-right procedure initial list::
* fold-left procedure initial list::
* any predicate list@dots{}::
* every predicate list@dots{}::
@end menu

@node reduce procedure initial list
@subsection (reduce @emph{procedure} @emph{initial} @emph{list})
@anchor{reduce-procedure-initial-list}

@node reduce-left procedure initial list
@subsection (reduce-left @emph{procedure} @emph{initial} @emph{list})
@anchor{reduce-left-procedure-initial-list}
Combines all the elements of @emph{list} using the binary operation
@emph{procedure}. For example, using @code{+} one can add up all the
elements:

@verbatim
(reduce-left + 0 list-of-numbers)
@end verbatim

The argument @emph{initial} is used only if @emph{list} is empty; in
this case @emph{initial} is the result of the call to
@code{reduce-left}. If @emph{list} has a single argument, it is
returned. Otherwise, the arguments are reduced in a left-associative
fashion. For example:

@verbatim
(reduce-left + 0 '(1 2 3 4))            ==> 10
(reduce-left + 0 '(1 2))                ==> 3
(reduce-left + 0 '(1))                  ==> 1
(reduce-left + 0 '())                   ==> 0
(reduce-left + 0 '(foo))                ==> foo
(reduce-left list '() '(1 2 3 4))       ==> (((1 2) 3) 4)
@end verbatim

@node reduce-right procedure initial list
@subsection (reduce-right @emph{procedure} @emph{initial} @emph{list})
@anchor{reduce-right-procedure-initial-list}
Like @code{reduce-left} except that it is right-associative.

@verbatim
(reduce-right list '() '(1 2 3 4))      ==> (1 (2 (3 4)))
@end verbatim

@node fold-right procedure initial list
@subsection (fold-right @emph{procedure} @emph{initial} @emph{list})
@anchor{fold-right-procedure-initial-list}
Combines all of the elements of @emph{list} using the binary operation
@emph{procedure}. Unlike @code{reduce-left} and @code{reduce-right},
@emph{initial} is always used:

@verbatim
(fold-right + 0 '(1 2 3 4))             ==> 10
(fold-right + 0 '(foo))                 ERROR Illegal datum
(fold-right list '() '(1 2 3 4))        ==> (1 (2 (3 (4 ()))))
@end verbatim

@code{fold-right} has interesting properties because it establishes a
homomorphism between (@code{cons}, @code{()}) and (@emph{procedure},
@emph{initial}). It can be thought of as replacing the pairs in the
spine of the list with @emph{procedure} and replacing the @code{()} at
the end with @emph{initial}. Many of the classical list-processing
procedures can be expressed in terms of @code{fold-right}, at least for
the simple versions that take a fixed number of arguments:

@verbatim
(define (copy-list list)
  (fold-right cons '() list))

(define (append list1 list2)
  (fold-right cons list2 list1))

(define (map p list)
  (fold-right (lambda (x r) (cons (p x) r)) '() list))

(define (reverse items)
  (fold-right (lambda (x r) (append r (list x))) '() items))
@end verbatim

@node fold-left procedure initial list
@subsection (fold-left @emph{procedure} @emph{initial} @emph{list})
@anchor{fold-left-procedure-initial-list}
Combines all the elements of @emph{list} using the binary operation
@emph{procedure}. Elements are combined starting with @emph{initial} and
then the elements of @emph{list} from left to right. Whereas
@code{fold-right} is recursive in nature, capturing the essence of
cdr-ing down a list and then computing a result (although all the
reduce/fold functions are implemented iteratively in the runtime),
@code{fold-left} is iterative in nature, combining the elements as the
list is traversed.

@verbatim
(fold-left list '() '(1 2 3 4))         ==> ((((() 1) 2) 3) 4)

(define (length list)
  (fold-left (lambda (sum element) (+ sum 1)) 0 list))

(define (reverse items)
  (fold-left (lambda (x y) (cons y x)) () items))
@end verbatim

@node any predicate list@dots{}
@subsection (any @emph{predicate} @emph{list}@dots{})
@anchor{any-predicate-list}
Applies @emph{predicate} across the @emph{lists}, returning true if
@emph{predicate} returns true on any application.

If there are n list arguments @emph{list1} @dots{} @emph{listn}, then
@emph{predicate} must be a procedure taking n arguments and returning a
boolean result.

@code{any} applies @emph{predicate} to the first elements of the
@emph{list} parameters. If this application returns a true value,
@code{any} immediately returns that value. Otherwise, it iterates,
applying @emph{predicate} to the second elements of the @emph{list}
parameters, then the third, and so forth. The iteration stops when a
true value is produced or one of the lists runs out of values; in the
latter case, @code{any} returns @code{@hashchar{}f}. The application of
@emph{predicate} to the last element of the @emph{lists} is a tail call.

Note the difference between @code{find} and @code{any} -- @code{find}
returns the element that satisfied the predicate; @code{any} returns the
true value that the @emph{predicate} produced.

Like @code{every}, @code{any}'s name does not end with a question mark
-- this is to indicate that it does not return a simple boolean
(@code{@hashchar{}t} or @code{@hashchar{}f}), but a general value.

@verbatim
(any integer? '(a 3 b 2.7))   ==> #t
(any integer? '(a 3.1 b 2.7)) ==> #f
(any < '(3 1 4 1 5)
       '(2 7 1 8 2)) ==> #t
@end verbatim

@node every predicate list@dots{}
@subsection (every @emph{predicate} @emph{list}@dots{})
@anchor{every-predicate-list}
Applies @emph{predicate} across the @emph{lists}, returning true if
@emph{predicate} returns true on every application.

If there are n list arguments @emph{list1} @dots{} @emph{listn}, then
@emph{predicate} must be a procedure taking n arguments and returning a
boolean result.

@code{every} applies @emph{predicate} to the first elements of the
@emph{list} parameters. If this application returns false, @code{every}
immediately returns false. Otherwise, it iterates, applying
@emph{predicate} to the second elements of the @emph{list} parameters,
then the third, and so forth. The iteration stops when a false value is
produced or one of the @emph{lists} runs out of values. In the latter
case, @code{every} returns the true value produced by its final
application of @emph{predicate}. The application of @emph{predicate} to
the last element of the @emph{lists} is a tail call.

If one of the @emph{lists} has no elements, @code{every} simply returns
@code{@hashchar{}t}.

Like @code{any}, @code{every}'s name does not end with a question mark
-- this is to indicate that it does not return a simple boolean
(@code{@hashchar{}t} or @code{@hashchar{}f}), but a general value.

@node Miscellaneous List Operations
@section Miscellaneous List Operations
@anchor{miscellaneous-list-operations}
@menu
* circular-list object@dots{}::
* reverse list::
* sort sequence procedure::
* flatten list::
* flatten* list::
* union list@dots{}::
* intersection list@dots{}::
* complement list@dots{}::
@end menu

@node circular-list object@dots{}
@subsection (circular-list @emph{object}@dots{})
@anchor{circular-list-object-1}
This procedure is like @code{list}, except that the returned list is
circular.

@node reverse list
@subsection (reverse @emph{list})
@anchor{reverse-list}
Returns a newly allocated list consisting of the top-level elements of
@emph{list} in reverse order.

@verbatim
(reverse '(a b c))                  ==> (c b a)
(reverse '(a (b c) d (e (f))))      ==> ((e (f)) d (b c) a)
@end verbatim

@node sort sequence procedure
@subsection (sort @emph{sequence} @emph{procedure})
@anchor{sort-sequence-procedure}
@emph{sequence} must be either a list or a vector. @emph{procedure} must
be a procedure of two arguments that defines a ``total ordering'' on the
elements of @emph{sequence}. In other words, if X and Y are two distinct
elements of @emph{sequence}, then it must be the case that

@verbatim
(and (PROCEDURE X Y)
     (PROCEDURE Y X))
     ==> #f
@end verbatim

If @emph{sequence} is a list (vector), @code{sort} returns a newly
allocated list (vector) whose elements are those of @emph{sequence},
except that they are rearranged to be sorted in the order defined by
@emph{procedure}. So, for example, if the elements of @emph{sequence}
are numbers, and @emph{procedure} is @code{<}, then the resulting
elements are sorted in monotonically nondecreasing order. Likewise, if
@emph{procedure} is @code{>}, the resulting elements are sorted in
monotonically nonincreasing order. To be precise, if X and Y are any two
adjacent elements in the result, where X precedes Y, it is the case that

@verbatim
(PROCEDURE Y X)
     ==> #f
@end verbatim

There is also the function @code{vector-sort} that applies only to
vectors, and will raise an erro if applied to a list.

@node flatten list
@subsection (flatten @emph{list})
@anchor{flatten-list}
Returns a list with the contents of all top level nested lists placed
directly in the result. This is best illustrated with some examples:

@verbatim
(flatten '(a b c d)) ==> (a b c d)
(flatten '(a (b c) d)) ==> (a b c d)
(flatten '(a (b (c d)))) ==> (a b (c d))
@end verbatim

@node flatten* list
@subsection (flatten* @emph{list})
@anchor{flatten-list-1}
Returns a list with the contents of all nested lists placed directly in
the result. This is also best illustrated with some examples:

@verbatim
(flatten* '(a b c d)) ==> (a b c d)
(flatten* '(a (b c) d)) ==> (a b c d)
(flatten* '(a (b (c d)))) ==> (a b c d)
@end verbatim

@node union list@dots{}
@subsection (union @emph{list}@dots{})
@anchor{union-list}
Returns a list that contains all items in the argument @emph{list}s.
Each item appears only once in the result regardless of whether it was
repeated in any @emph{list}.

@verbatim
(union '(1 2 3) '(4 5))      ==> (1 2 3 4 5)
(union '(1 2 3) '(3 4 5))    ==> (1 2 3 4 5)
(union '(1 2 3 2) '(4 4 5))  ==> (1 2 3 4 5)
@end verbatim

@node intersection list@dots{}
@subsection (intersection @emph{list}@dots{})
@anchor{intersection-list}
Returns a list that contains only items that are in all @emph{list}
arguments.

@verbatim
(intersection '(1 2 3) '(3 4 5)) ==> (3)
(intersection '() '(3 4 5))      ==> ()
@end verbatim

@node complement list@dots{}
@subsection (complement @emph{list}@dots{})
@anchor{complement-list}
Returns a list that contains only items that were in the first
@emph{list} argument, but not in any of the subsequent argument
@emph{list}s.

@verbatim
(complement '(1 2 3 4 5) '(1 3 5))      ==> (2 4)
(complement '() '(1 2))                 ==> ()
(complement '(1 2 3 4 5) '(1 2) '(3 4)) ==> (5)
@end verbatim

@node Vectors
@chapter Vectors
@anchor{vectors}
Vectors are heterogeneous structures whose elements are indexed by
non-negative integers. A vector typically occupies less space than a
list of the same length, and the average time required to access a
randomly chosen element is typically less for the vector than for the
list.

The length of a vector is the number of elements that it contains. This
number is a non-negative integer that is fixed when the vector is
created. The valid indexes of a vector are the non-negative integers
less than the length of the vector. The first element in a vector is
indexed by zero, and the last element is indexed by one less than the
length of the vector.

Vectors are written using the notation @code{#(object ...)}. For
example, a vector of length 3 containing the number zero in element 0,
the list @code{(2 2 2 2)} in element 1, and the string @code{"Anna"} in
element 2 can be written as

@verbatim
 #(0 (2 2 2 2) "Anna")
@end verbatim

Note that this is the external representation of a vector, not an
expression evaluating to a vector. Like list constants, vector constants
must be quoted:

@verbatim
'#(0(2222)"Anna") ==> #(0 (2222) "Anna")
@end verbatim

A number of the vector procedures operate on subvectors. A subvector is
a segment of a vector that is specified by two non-negative integers,
start and end. Start is the index of the first element that is included
in the subvector, and end is one greater than the index of the last
element that is included in the subvector. Thus if start and end are the
same, they refer to a null subvector, and if start is zero and end is
the length of the vector, they refer to the entire vector. The valid
indexes of a subvector are the integers between start inclusive and end
exclusive.
@menu
* Construction of Vectors::
* Enumerating over Vectors::
* Selecting Vector Components::
* Cutting Vectors::
* Modifying Vectors::
@end menu

@node Construction of Vectors
@section Construction of Vectors
@anchor{construction-of-vectors}
@menu
* make-vector k [object]::
* vector object@dots{}::
* vector-copy vector::
* list->vector list::
* vector->list vector::
* subvector->list vector start end::
* make-initialized-vector k initialization::
* vector-grow vector k::
@end menu

@node make-vector k [object]
@subsection (make-vector @emph{k} [@emph{object}])
@anchor{make-vector}
Returns a newly allocated vector of k elements. If @emph{object} is
specified, @code{make-vector} initializes each element of the vector to
the @emph{object}. Otherwise the initial elements of the result are
unspecified.

@node vector object@dots{}
@subsection (vector @emph{object}@dots{})
@anchor{vector}
Returns a newly allocated vector whose elements are the given
@emph{objects}. @code{vector} is analogous to @code{list}.

@verbatim
(vector 'a 'b 'c) ==> #(a b c)
@end verbatim

@node vector-copy vector
@subsection (vector-copy @emph{vector})
@anchor{vector-copy}
Returns a newly allocated vector that is a copy of @emph{vector}.

@node list->vector list
@subsection (list->vector @emph{list})
@anchor{list-to-vector}
Returns a newly allocated vector initialized to the elements of
@emph{list}.

@verbatim
(list->vector '(dididit dah)) ==> #(dididit dah)
@end verbatim

@node vector->list vector
@subsection (vector->list @emph{vector})
@anchor{vector-to-list}
Returns a newly allocated list initialized to the elements of
@emph{vector}.

@verbatim
(vector->list '#(dididit dah)) ==> (dididit dah)
@end verbatim

@node subvector->list vector start end
@subsection (subvector->list @emph{vector} @emph{start} @emph{end})
@anchor{subvector-to-list}
@code{vector->list} returns a newly allocated list of the elements of
@emph{vector}. @code{subvector->list} returns a newly allocated list of
the elements of the given subvector. The inverse of @code{vector->list}
is @code{list->vector}.

@node make-initialized-vector k initialization
@subsection (make-initialized-vector @emph{k} @emph{initialization})
@anchor{make-initialized-vector}
Similar to @code{make-vector}, except that the elements of the result
are determined by calling the procedure @emph{initialization} on the
indices. For example:

@verbatim
(make-initialized-vector 5 (lambda (x) (* x x))) ==> #(0 1 4 9 16)
@end verbatim

@node vector-grow vector k
@subsection (vector-grow @emph{vector} @emph{k})
@anchor{vector-grow}
@emph{k} must be greater than or equal to the length of @emph{vector}.
Returns a newly allocated vector of length @emph{k}. The first
@code{(vector-length vector)} elements of the result are initialized
from the corresponding elements of @emph{vector}. The remaining elements
of the result are unspecified.

@node Enumerating over Vectors
@section Enumerating over Vectors
@anchor{enumerating-over-vectors}
@menu
* vector-map procedure vector@dots{}::
@end menu

@node vector-map procedure vector@dots{}
@subsection (vector-map @emph{procedure} @emph{vector}@dots{})
@anchor{vector-map-procedure-vector}
@emph{procedure} must be a procedure with arity the same as the number
or @emph{vector}s. @code{vector-map} applies @emph{procedure}
element-wise to the corresponding elements of each @emph{vector} and
returns a newly allocated vector of the results, in order from left to
right. The dynamic order in which procedure is applied to the elements
of vector is unspecified.

@verbatim
(vector-map cadr '#((ab)(de)(gh)))            ==> #(b e h)
(vector-map (lambda (n) (* n n)) '#(1 2 3 4)) ==> #(1 4 9 16)
(vector-map + '#(1 2 3) '#(4 5 6))            ==> #(5 7 9)
@end verbatim

@node Selecting Vector Components
@section Selecting Vector Components
@anchor{selecting-vector-components}
@menu
* vector-length vector::
* vector-ref vector k::
* vector-set! vector k object::
* vector-first vector::
* vector-second vector::
* vector-third vector::
* vector-fourth vector::
* vector-fifth vector::
* vector-sixth vector::
* vector-seventh vector::
* vector-eighth vector::
* vector-ninth vector::
* vector-tenth vector::
* vector-last vector::
* vector-binary-search vector key<? unwrap-key key::
@end menu

@node vector-length vector
@subsection (vector-length @emph{vector})
@anchor{vector-length}
Returns the number of elements in @emph{vector}.

@node vector-ref vector k
@subsection (vector-ref @emph{vector} @emph{k})
@anchor{vector-ref}
Returns the contents of element @emph{k} of @emph{vector}. @emph{k} must
be a valid index of @emph{vector}.

@verbatim
(vector-ref '#(1 1 2 3 5 8 13 21) 5)    ==>  8
@end verbatim

@node vector-set! vector k object
@subsection (vector-set! @emph{vector} @emph{k} @emph{object})
@anchor{vector-set-vector-k-object}
Stores @emph{object} in element @emph{k} of @emph{vector} and returns an
unspecified value. @emph{K} must be a valid index of @emph{vector}.

@verbatim
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)
            ==>  #(0 ("Sue" "Sue") "Anna")
@end verbatim

@node vector-first vector
@subsection (vector-first @emph{vector})
@anchor{vector-first}

@node vector-second vector
@subsection (vector-second @emph{vector})
@anchor{vector-second}

@node vector-third vector
@subsection (vector-third @emph{vector})
@anchor{vector-third}

@node vector-fourth vector
@subsection (vector-fourth @emph{vector})
@anchor{vector-fourth}

@node vector-fifth vector
@subsection (vector-fifth @emph{vector})
@anchor{vector-fifth}

@node vector-sixth vector
@subsection (vector-sixth @emph{vector})
@anchor{vector-sixth}

@node vector-seventh vector
@subsection (vector-seventh @emph{vector})
@anchor{vector-seventh}

@node vector-eighth vector
@subsection (vector-eighth @emph{vector})
@anchor{vector-eighth}

@node vector-ninth vector
@subsection (vector-ninth @emph{vector})
@anchor{vector-ninth}

@node vector-tenth vector
@subsection (vector-tenth @emph{vector})
@anchor{vector-tenth}
These procedures access the first several elements of @emph{vector} in
the obvious way. It is an error if the implicit index of one of these
procedures is not a valid index of @emph{vector}.

@node vector-last vector
@subsection (vector-last @emph{vector})
@anchor{vector-last-vector}
Returns the last element of @emph{vector}.

@node vector-binary-search vector key<? unwrap-key key
@subsection (vector-binary-search @emph{vector} @emph{key<?} @emph{unwrap-key} @emph{key})
@anchor{vector-binary-search}
Searches @emph{vector} for an element with a key matching @emph{key},
returning the element if one is found or @emph{#f} if none. The search
operation takes time proportional to the logarithm of the length of
@emph{vector}. @emph{unwrap-key} must be a procedure that maps each
element of @emph{vector} to a key. @emph{key<?} must be a procedure that
implements a total ordering on the keys of the elements.

@verbatim
(define (translate number)
  (vector-binary-search '#((1 . i)
                           (2 . ii)
                           (3 . iii)
                           (6 . vi))
                        < car number))
(translate 2)  ==>  (2 . ii)
(translate 4)  ==>  #f
@end verbatim

@node Cutting Vectors
@section Cutting Vectors
@anchor{cutting-vectors}
@menu
* subvector vector start end::
* vector-head vector end::
* vector-tail vector start::
@end menu

@node subvector vector start end
@subsection (subvector @emph{vector} @emph{start} @emph{end})
@anchor{subvector}
Returns a newly allocated vector that contains the elements of
@emph{vector} between index @emph{start} (inclusive) and @emph{end}
(exclusive).

@node vector-head vector end
@subsection (vector-head @emph{vector} @emph{end})
@anchor{vector-head}
Equivalent to

@verbatim
(subvector vector 0 end)
@end verbatim

@node vector-tail vector start
@subsection (vector-tail @emph{vector} @emph{start})
@anchor{vector-tail}
Equivalent to

@verbatim
(subvector vector start (vector-length vector))
@end verbatim

@node Modifying Vectors
@section Modifying Vectors
@anchor{modifying-vectors}
@menu
* vector-fill! vector object::
* subvector-fill! vector start end object::
* subvector-move-left! vector1 start1 end1 vector2 start2::
* subvector-move-right! vector1 start1 end1 vector2 start2::
* vector-sort! vector procedure::
@end menu

@node vector-fill! vector object
@subsection (vector-fill! @emph{vector} @emph{object})
@anchor{vector-fill-bang}

@node subvector-fill! vector start end object
@subsection (subvector-fill! @emph{vector} @emph{start} @emph{end} @emph{object})
@anchor{subvector-fill-bang}
Stores @emph{object} in every element of the vector (subvector) and
returns an unspecified value.

@node subvector-move-left! vector1 start1 end1 vector2 start2
@subsection (subvector-move-left! @emph{vector1} @emph{start1} @emph{end1} @emph{vector2} @emph{start2})
@anchor{subvector-move-left-bang}

@node subvector-move-right! vector1 start1 end1 vector2 start2
@subsection (subvector-move-right! @emph{vector1} @emph{start1} @emph{end1} @emph{vector2} @emph{start2})
@anchor{subvector-move-right-bang}
Destructively copies the elements of @emph{vector1}, starting with index
@emph{start1} (inclusive) and ending with @emph{end1} (exclusive), into
@emph{vector2} starting at index @emph{start2} (inclusive).
@emph{vector1}, @emph{start1}, and @emph{end1} must specify a valid
subvector, and @emph{start2} must be a valid index for @emph{vector2}.
The length of the source subvector must not exceed the length of
@emph{vector2} minus the index @emph{start2}.

The elements are copied as follows (note that this is only important
when @emph{vector1} and @emph{vector2} are @code{eqv?}):

@code{subvector-move-left!}: The copy starts at the left end and moves
toward the right (from smaller indices to larger). Thus if
@emph{vector1} and @emph{vector2} are the same, this procedure moves the
elements toward the left inside the vector.

@code{subvector-move-right!}: The copy starts at the right end and moves
toward the left (from larger indices to smaller). Thus if @emph{vector1}
and @emph{vector2} are the same, this procedure moves the elements
toward the right inside the vector.

@node vector-sort! vector procedure
@subsection (vector-sort! @emph{vector} @emph{procedure})
@anchor{vector-sort-bang}
@emph{procedure} must be a procedure of two arguments that defines a
@emph{total ordering} on the elements of @emph{vector}. The elements of
@emph{vector} are rearranged so that they are sorted in the order
defined by @emph{procedure}. The elements are rearranged in place, that
is, VECTOR is destructively modified so that its elements are in the new
order.

@code{vector-sort!} returns @emph{vector} as its value.

See also the definition of @code{sort}.

@node Associations
@chapter Associations
@anchor{associations}
@menu
* Association Lists::
@end menu

@node Association Lists
@section Association Lists
@anchor{association-lists}
``Association lists'' are one of Lisp's oldest association mechanisms.
Because they are made from ordinary pairs, they are easy to build and
manipulate, and very flexible in use. However, the average lookup time
for an association list is linear in the number of associations. Frames
are a more efficient

An ``association list'', or ``alist'', is a data structure used very
frequently in Scheme. An alist is a list of pairs, each of which is
called an ``association''. The car of an association is called the
``key'', and the cdr is called the ``value''. Having lists as pair
values can cause confusion because the pair in the alist look like proper
lists and not dotted pairs. Functions that look specifically for dotted
pairs will not consider it an association list (e.g. @code{alist?})
while those that don't will work fine (e.g. the @code{assoc} &
@code{dissoc} functions). The latter simply look at the car and cdr of
the pairs. not whether they are canonical dotted pairs (i.e. their cdr
is not a pair).

@verbatim
'((a . (1 2)) (b . (3 4)))                   ==> ((a 1 2) (b 3 4))
(alist? '((a . (1 2)) (b . (3 4))))          ==> #f
(assoc 'b '((a . (1 2)) (b . (3 4))))        ==> (b 3 4)
(cdr (assoc 'b '((a . (1 2)) (b . (3 4)))))  ==> (3 4)
@end verbatim

An advantage of the alist representation is that an alist can be
incrementally augmented simply by adding new entries to the front.
Moreover, because the searching procedures `assv' et al. search the
alist in order, new entries can ``shadow'' old entries. If an alist is
viewed as a mapping from keys to data, then the mapping can be not only
augmented but also altered in a non-destructive manner by adding new
entries to the front of the alist.
@menu
* alist? object::
* acons key value [alist]::
* pairlis keys values [alist]::
* assq object alist::
* assv object alist::
* assoc object alist::
* rassoc value alist::
* del-assq object alist::
* dissq object alist::
* del-assv object alist::
* dissv object alist::
* del-assoc object alist::
* dissoc object alist::
@end menu

@node alist? object
@subsection (alist? @emph{object})
@anchor{alistp}
Returns @code{@hashchar{}t} if @emph{object} is an association list (including the
empty list); otherwise returns @code{@hashchar{}f}. Any @emph{object} satisfying
this predicate also satisfies @code{list?}.

@node acons key value [alist]
@subsection (acons @emph{key} @emph{value} [@emph{alist}])
@anchor{acons}
Returns the result of consing a pair @code{(key . value)} to
@emph{alist}. If @emph{alist} is omitted, it defaults to the empty list.

@verbatim
(acons 'a 1)            ==> ((a . 1))
(acons 'a 1 '((b . 2))) ==> ((a . 1) (b . 2))
(acons 'b 1 '((b . 2))) ==> ((b . 1) (b . 2))
@end verbatim

@node pairlis keys values [alist]
@subsection (pairlis @emph{keys} @emph{values} [@emph{alist}])
@anchor{pairlis}
Creates an association list from lists of @emph{keys} and @emph{values}
by acons-ing onto @emph{alist}. If @emph{alist} is omitted, it defaults
to the empty list. Note that the key and value lists are paired up in
left to right order, but the order they are consed onto @emph{alist} is
unspecified.

@verbatim
(pairlis '(a b) '(1 2))                    ==> ((b . 2) (a . 1)))
(pairlis '(a b) '(1 2) '((c . 3) (d . 4))) ==> ((b . 2) (a . 1) (c . 3) (d . 4))))
@end verbatim

@node assq object alist
@subsection (assq @emph{object} @emph{alist})
@anchor{assq}

@node assv object alist
@subsection (assv @emph{object} @emph{alist})
@anchor{assv}

@node assoc object alist
@subsection (assoc @emph{object} @emph{alist})
@anchor{assoc}
These procedures find the first pair in @emph{alist} whose car field is
@emph{object}, and return that pair; the returned pair is always an
@strong{element} of @emph{alist}, @strong{not} one of the pairs from
which @emph{alist} is composed. If no pair in @emph{alist} has
@emph{object} as its car, @code{@hashchar{}f} (n.b.: not the empty list) is
returned. @code{assq} uses @code{eq?} to compare @emph{object} with the
car fields of the pairs in @emph{alist}, while @code{assv} uses
@code{eqv?} and @code{assoc} uses @code{equal?}.

@verbatim
(define e '((a . 1) (b . 2) (c . 3)))
(assq 'a e)                             ==>  (a . 1)
(assq 'b e)                             ==>  (b . 2)
(assq 'd e)                             ==>  #f
(assq (list 'a) '(((a)) ((b)) ((c))))   ==>  #f
(assoc (list 'a) '(((a)) ((b)) ((c))))  ==>  ((a))
(assv 5 '((2 . 3) (5 . 7) (11 . 13)))   ==>  (5 . 7)
@end verbatim

@node rassoc value alist
@subsection (rassoc @emph{value} @emph{alist})
@anchor{rassoc}
Return the pair from @emph{alist} whose cdr is equal to @emph{value}.
@code{@hashchar{}f} is returned is @emph{value} isn't found.

@verbatim
(rassoc 1 '((a . 1) (b . 2) (c . 3))) ==> (a . 1)
(rassoc 3 '((a . 1) (b . 2)))         ==> #f
@end verbatim

@node del-assq object alist
@subsection (del-assq @emph{object} @emph{alist})
@anchor{del-assq}

@node dissq object alist
@subsection (dissq @emph{object} @emph{alist})
@anchor{dissq}

@node del-assv object alist
@subsection (del-assv @emph{object} @emph{alist})
@anchor{del-assv}

@node dissv object alist
@subsection (dissv @emph{object} @emph{alist})
@anchor{dissv}

@node del-assoc object alist
@subsection (del-assoc @emph{object} @emph{alist})
@anchor{del-assoc}

@node dissoc object alist
@subsection (dissoc @emph{object} @emph{alist})
@anchor{dissoc}
These procedures return a newly allocated copy of @emph{alist} in which
all associations with keys equal to @emph{object} have been removed.
Note that while the returned copy is a newly allocated list, the
association pairs that are the elements of the list are shared with
@emph{alist}, not copied. @code{del-assq}/@code{dissq} use @code{eq?} to
compare @emph{object} with the keys, while @code{del-assv}/@code{dissv}
use @code{eqv?} and @code{del-assoc}/@code{dissoc} use @code{equal?}.

@verbatim
(define a
  '((butcher . "231 e22nd St.")
    (baker . "515 w23rd St.")
    (hardware . "988 Lexington Ave.")))

(del-assq 'baker a)
     ==>
     ((butcher . "231 e22nd St.")
      (hardware . "988 Lexington Ave."))
@end verbatim

@node Frames
@chapter Frames
@anchor{frames}
GoLisp contains a frame system inspired by Self [4] and NewtonScript
[5].

A frame is a set of named slots that hold arbitrary values. Slot names
must be symbols that end with a colon. For example: @code{color:}, or
@code{height:}. When evaluated normally, these special symbols don't get
looked up in the environment, they simply evaluate to themselves.

@verbatim
(define a a:)

'a ==> a
a  ==> a:

'a: ==> a:
a:  ==> a:
@end verbatim

@menu
* Basic functions::
* Parent slots::
* Function slots::
* Dynamic inheritence::
* Json support::
@end menu

@node make-slotname symbol
@subsection (make-slotname @emph{symbol})
@anchor{make-slotname}
This function takes a symbol or string and returns an interned slotname
based on it, doing what is required.

@verbatim
(make-slotname 'name) ==> name:
(make-slotname "name") ==> name:
(make-slotname name:) ==> name:
@end verbatim

@node Basic functions
@section Basic functions
@anchor{basic-functions}
@menu
* make-frame slot-name slot-value @dots{} ::
* @{ slot-name slot-value @dots{} @}::
* clone frame::
* has-slot? frame slot-name::
* slot-name? frame::
* get-slot frame slot-name::
* slot-name frame::
* get-slot-or-nil frame slot-name::
* set-slot! frame slot-name new-value::
* slot-name! frame new-value::
* remove-slot! frame slot-name::
* frame-keys frame::
* frame-values frame::
@end menu

@node make-frame slot-name slot-value @dots{} 
@subsection (make-frame @emph{slot-name} @emph{slot-value} @dots{} )
@anchor{make-frame}
Frames can be created using the @code{make-frame} function, passing it
an alternating sequence of slot names and values:

@verbatim
(make-frame a: 1 b: 2)
@end verbatim

This results in a frame with two slots, named @code{a:} and @code{b:}
with values @code{1} and @code{2}, respectively.

@node @{ slot-name slot-value @dots{} @}
@subsection @{ @emph{slot-name} @emph{slot-value} @dots{} @}
@anchor{frame-literal}
This is an alternative syntax for defining frame literals:

@verbatim
{a: 1 b: 2}
@end verbatim

Both are equivalent. Slot names and values in both cases are evaluated
(this is one reason for the non-evaluating symbols: it avoiding having
to quote literal slot names).

@node clone frame
@subsection (clone @emph{frame})
@anchor{clone}
Frames represent things. For example, you could use a frame that looks
like @code{@{x: 1 y: 10@}} to represent a point. A system that would use
point frames will typically need many independant points. The approach
to this is to create a prototypical point data frame, and use the
@code{clone} function to create individual, independant frames:

@verbatim
(define point {x: 1 y: 1})
(define p1 (clone point))
(set-slot! p1 x: 5)
(get-slot p1 x:)    ==> 5
(get-slot point x:) ==> 1
@end verbatim

@node has-slot? frame slot-name
@subsection (has-slot? @emph{frame} @emph{slot-name})
@anchor{has-slot}

@node slot-name? frame
@subsection (@emph{slot-name}? @emph{frame})
@anchor{has-slot-sugar}
The @code{has-slot?} function is used to query whether a frame contains
(directly or in an ancestor) the particular slot:

@verbatim
(define f {a: 1 b: 2})
(has-slot? f a:)      ==> #t
(a:? f)               ==> #t
(has-slot? f c:)      ==> #f
(c:? f)               ==> #f
@end verbatim

@node get-slot frame slot-name
@subsection (get-slot @emph{frame} @emph{slot-name})
@anchor{get-slot}

@node slot-name frame
@subsection (@emph{slot-name} @emph{frame})
@anchor{get-slot-sugar}
The @code{get-slot} function is used to retrieve values from frame
slots:

@verbatim
(define f {a: 1 b: 2})
(get-slot f a:)       ==> 1
(a: f)                ==> 1
(get-slot f b:)       ==> 2
(b: f)                ==> 2
@end verbatim

If the frame passed to @code{get-slot} contains a slot with the
specified name, it's value is returned. If not, then parent frames are
searched in a nondeterministic order until a slot with the specified
name is found. If a matching slot is found, it's value is returned. If
none is found an error is raised.

@verbatim
(define f {a: 1 b: 2})
(define g {parent*: f c: 3})

(get-slot g c:) ==> 3
(get-slot g a:) ==> 1  ; from the frame f
@end verbatim

@node get-slot-or-nil frame slot-name
@subsection (get-slot-or-nil @emph{frame} @emph{slot-name})
@anchor{get-slot-or-nil}
The same as above, except that if a matching slot is not found,
@code{nil} is returned instead of raising an error.

@node set-slot! frame slot-name new-value
@subsection (set-slot! @emph{frame} @emph{slot-name} @emph{new-value})
@anchor{set-slot}

@node slot-name! frame new-value
@subsection (@emph{slot-name}! @emph{frame} @emph{new-value})
@anchor{set-slot-sugar}
The @code{set-slot!} function is used to change values in frame slots:

@verbatim
(define f {a: 1 b: 2})
(get-slot f a:)    ==> 1
(set-slot! f a: 5) ==> 5
(a:! f 5) ==> 5
(get-slot f a:)    ==> 5
@end verbatim

Trying to set a slot that doesn't exist in the frame will result in a
corresponding slot being created.

@verbatim
(define f {a: 1 b: 2})
(set-slot! f c: 5) ==> 5
f                  ==> {a: 1 b: 2 c: 5}
@end verbatim

@node remove-slot! frame slot-name
@subsection (remove-slot! @emph{frame} @emph{slot-name})
@anchor{remove-slot}
The @code{remove-slot!} function is used to function is used to remove a
slot from a frame. It only removes slots from the frame itself. not any
of it's parents. @code{remove-slot!} return @code{@hashchar{}t} if the slot was
removed, @code{@hashchar{}f} otherwise.

@verbatim
(define f {a: 1 b: 2})
(remove-slot! f a:) ==> #t
f                   ==> {b: 2}
(remove-slot! f a:) ==> #f
@end verbatim

@node frame-keys frame
@subsection (frame-keys @emph{frame})
@anchor{frame-keys}
Returns a list of the slot names in @emph{frame}. Note that the order of
the result is nondeterministic.

@verbatim
(frame-keys {a: 1 b: 2}) ==> (a: b:)
@end verbatim

@node frame-values frame
@subsection (frame-values @emph{frame})
@anchor{frame-values}
Returns a list of the slot values in @emph{frame}. Note that the order
of the result is nondeterministic.

@verbatim
(frame-values {a: 1 b: 2}) ==> (1 2)
@end verbatim

@node Parent slots
@section Parent slots
@anchor{parent-slots}
Frames can have slots that refer to other slots to provide prototype
inheritance. These slots have names that have a @code{*} immediately
preceeding the trailing @code{:}, for example @code{proto*:}. The names
of the parent slots don't matter; it is the trailing @code{*:} in the
name that marks them as parent slots. A frame can have any number of
parent slots.

When a slot is being searched for, if it isn't found in the specified
slot, these @emph{parent} slots are recursively searched until the
requested slot is found or the entire graph has been examined.

@verbatim
> (define y {a: 1})
===> {a: 1}
> (define x {b: 2 p*: y})
===> {b: 2 p*: {...}}

> (a: x)
===> 1
@end verbatim

@strong{Note:} Parent slots are searched in arbitrary order.

@node Function slots
@section Function slots
@anchor{function-slots}
Now things get interesting. Slot values can be functions (typically
@code{lambda} expressions) as well as data. Function slots can be
executed by using the @code{send} function
@menu
* send frame slot-name arg@dots{}::
* slot-name> frame arg@dots{}::
* send-super slot-name arg@dots{}::
* slot-name^ arg@dots{}::
* apply-slot frame slot-name sexpr@dots{}::
* apply-slot-super slot-name sexpr@dots{}::
@end menu

@node send frame slot-name arg@dots{}
@subsection (send @emph{frame} @emph{slot-name} @emph{arg}@dots{})
@anchor{send}

@node slot-name> frame arg@dots{}
@subsection (@emph{slot-name}> @emph{frame} @emph{arg}@dots{})
@anchor{send-sugar}

@verbatim
(define f {
  add: (lambda () (+ 1 2))
})
(send f add:) ==> 3
(add:> f) ==> 3
@end verbatim

As expected, parameters are supported:

@verbatim
(define f {
  add: (lambda (x) (+ 1 x))
})
(send f add: 2) ==> 3
@end verbatim

In the body of a function, slots can be refrenced like normal variables.
To do so, simply omit the trailing colon:

@verbatim
(define f {
  a: 3
  add: (lambda (x) (+ a x))
})
(send f add: 2) ==> 5
@end verbatim

Likewise, functions in the frame (or parent frames) can be referred to
directly by name.

@verbatim
(define f {
  a: 5
  b: 2
  foo: (lambda (x) (+ x a))
  bar: (lambda () (foo b))
})
(send f bar:) ==> 7
@end verbatim

Bindings defined in the local environment (e.g. by a @code{let} form)
hide frame slots of the same name. In the following, @code{let}
overrides the @code{a:} slot by introducing a local binding for
@code{a}.

@verbatim
(let ((f {a: 42})
      (g {
         parent*: f  
         foo: 
           (lambda ()
             (let ((a 10))
             (+ 1 a)))
      }))
(send g foo:) ==> 11
@end verbatim

Of course the end game of all this is to be able to inherit functions
from parent frames:

@verbatim
(define f {
  a: 5
  foo: (lambda (x) (+ x a))
})
(define g {
  parent*: f
  b: 2
  bar: (lambda () (foo b))
})
(send g bar:) ==> 7
@end verbatim

Notice that we've been saying parent @strong{frames}, i.e. plural. Also
note that parent slot names are arbitrary and for documentation purposes
only. A frame can have any number of parents. When a slot is looked for,
the explictily specified frame is searched first, recursively followed
by parent frames in a nondeterministic order until a matching slot is
found. If none are found, the result is nil.

@verbatim
(define e {a: 5})
(define f {b: 2})
(define g {
  parent-e*: e
  parent-f*: f
  foo: (lambda (x) (+ x a))
  bar: (lambda () (foo b))}))
(send g bar:)       ==> 7
(set-slot! g a: 10)
(get-slot g a:)     ==> 10
(get-slot e a:)     ==> 5
@end verbatim

When you set a slot with parent frames involved, if the slot is found in
the explicit frame it's value is set and the new value is returned. If
it doesn't exist in the explicit frame, it gets created there. This new
slot now hides any slots in a parent with the same name.

@node send-super slot-name arg@dots{}
@subsection (send-super @emph{slot-name} @emph{arg}@dots{})
@anchor{send-super}

@node slot-name^ arg@dots{}
@subsection (@emph{slot-name}^ @emph{arg}@dots{})
@anchor{send-super-sugar}
Like @code{send}, but sends to the first parent that has the named slot.
@strong{@code{send-super} can only be used from within a function slot.}

@node apply-slot frame slot-name sexpr@dots{}
@subsection (apply-slot @emph{frame} @emph{slot-name} @emph{sexpr}@dots{})
@anchor{apply-slot}
Apply the function that results from evaluating the function in slot
@emph{slot-name} of @emph{frame} to the argument list resulting from
evaluating each @emph{sexpr}.

Each initial @emph{sexpr} can evaluate to any type of object, but the
final one (and there must be at least one @emph{sexpr}) must evaluate to
a list.

@verbatim
(define f {
  foo: 
    (lambda (x y z) 
      (+ 1 x y z))
})
(apply-slot f foo: 2 '(3 4)) ==> 10
(apply-slot f foo: '(2 3 4)) ==> 10
@end verbatim

@node apply-slot-super slot-name sexpr@dots{}
@subsection (apply-slot-super @emph{slot-name} @emph{sexpr}@dots{})
@anchor{apply-slot-super}
Like @code{apply-slot}, but sends to the first parent that has the named
slot. @strong{@code{apply-slot-super} can only be used from within a
function slot.}

@node Dynamic inheritence
@section Dynamic inheritence
@anchor{dynamic-inheritence}
Parent slots are slots like any other and can have their values changed
at any time. This ability is somewhat unusual for those with a heavy OO
background but can be very useful for changing behavior on the fly. A
prime example of this is the implimentation of a state machine. The
functions for each state can be placed in different frames and
transitions can modify the slot contaiing that state behavior.

Here's an example of this.

@verbatim
(define state {
  name: ""
  enter: (lambda ())
  halt: (lambda ())
  set-speed: (lambda (s))
  halt: (lambda ())
  transition-to: 
    (lambda (s)
      (set! state* s)
      (enter))
})

(define stop-state {
  name: "stop"
  parent*: state
  enter: 
    (lambda ()
      (set! speed 0)
      (transition-to idle-state))
})

(define idle-state {
  name: "idle"
  parent*: state
  set-speed: 
    (lambda (s)
      (set! speed s)
      (transition-to start-state))
})

(define start-state {
  name: "start"
  parent*: state
  halt: 
    (lambda ()
      (transition-tostop-state))
  set-speed: 
    (lambda (s)
      (set! speed s)
      (transition-to change-speed-state))
})

(define change-speed-state {
  name: "change-speed"
  parent*: state
  halt: 
    (lambda ()
      (transition-to stop-state))
  set-speed: 
    (lambda (s)
      (set! speed s))
})

(define motor {
  speed: 0
  state*: state
  start: 
    (lambda () 
      (transition-to stop-state))
})
@end verbatim

Now you can do things like the following:

@verbatim
(send motor start:)
motor ==> {speed: 0 state*: {name: "idle" ...}}
(send motor set-speed: 10)
motor ==> {speed: 10 state*: {name: "start" ...}}
(send motor set-speed: 20)
motor ==> {speed: 20 state*: {name: "change-speed" ...}}
(send motor set-speed: 15)
motor ==> {speed: 15 state*: {name: "change-speed" ...}}
(send motor halt:)
motor ==> {speed: 0 state*: {name: "idle" ...}}
@end verbatim

@node Json support
@section Json support
@anchor{json-support}
GoLisp has built-in support for converting between stringified Json and
frames, according to the following rules:

@itemize
@item
numbers and strings map directly in both directions

@item
frames recursively map to objects, and the reverse

@item
lists recursively map to arrays, and the reverse

@item
frame slots names map to string field names, and the reverse

@item
function slots @strong{do not} get mapped to json

@item
parent slots @strong{do not} get mapped to json

@end itemize

@menu
* json->lisp string::
* lisp->json frame::
@end menu

@node json->lisp string
@subsection (json->lisp @emph{string})
@anchor{json-to-lisp}

@verbatim
(json->lisp "{'key': [1, 2, 3]}") ==> {key: (1 2 3)}
@end verbatim

@node lisp->json frame
@subsection (lisp->json @emph{frame})
@anchor{lisp-to-json}

@verbatim
(lisp->json {key: (1 2 3)}) ==> "{'key': [1, 2, 3]}"
@end verbatim

@node Miscellaneous Datatypes
@chapter Miscellaneous Datatypes
@anchor{miscellaneous-datatypes}
@menu
* Booleans::
* Symbols::
* Bytearrays::
@end menu

@node Booleans
@section Booleans
@anchor{booleans}
The ``boolean objects'' are ``true'' and ``false''. The boolean constant
true is written as @code{@hashchar{}t}, and the boolean constant false is written
as @code{@hashchar{}f}.

The primary use for boolean objects is in the conditional expressions
@code{if}, @code{cond}, @code{and}, and @code{or}; the behavior of these
expressions is determined by whether objects are true or false. These
expressions count only @code{@hashchar{}f} as false. They count everything else,
including @code{@hashchar{}t}, pairs, symbols, numbers, strings, vectors, and
procedures as true.

Boolean constants evaluate to themselves, so you don't need to quote
them.

@verbatim
 #t                                      ==>  #t
 #f                                      ==>  #f
 '#f                                     ==>  #f
 t                                       ERROR Unbound variable
@end verbatim

@menu
* false::
* true::
* boolean? object::
* not object::
* false? object::
* boolean=? obj1 obj2::
* boolean/and object@dots{}::
* boolean/or object@dots{}::
@end menu

@node false
@subsection false

@node true
@subsection true
These variables are bound to the objects @code{@hashchar{}f} and @code{@hashchar{}t}
respectively.

Note that the symbol @code{true} is not equivalent to @code{@hashchar{}t}, and the
symbol @code{false} is not equivalent to @code{@hashchar{}f}.

@node boolean? object
@subsection (boolean? @emph{object})
@anchor{booleanp}
Returns @code{@hashchar{}t} if @emph{object} is either @code{@hashchar{}t} or @code{@hashchar{}f};
otherwise returns @code{@hashchar{}f}.

@verbatim
(boolean? #f)                           ==>  #t
(boolean? 0)                            ==>  #f
@end verbatim

@node not object
@subsection (not @emph{object})
@anchor{notp}

@node false? object
@subsection (false? @emph{object})
@anchor{falsep}
These procedures return @code{@hashchar{}t} if @emph{object} is false; otherwise
they return @code{@hashchar{}f}. In other words they @emph{invert} boolean values.
These two procedures have identical semantics; their names are different
to give different connotations to the test.

@verbatim
(not #t)                                ==>  #f
(not 3)                                 ==>  #f
(not (list 3))                          ==>  #f
(not #f)                                ==>  #t
@end verbatim

@node boolean=? obj1 obj2
@subsection (boolean=? @emph{obj1} @emph{obj2})
@anchor{booleaneqp}
This predicate is true iff @emph{obj1} and @emph{obj2} are either both
true or both false.

@node boolean/and object@dots{}
@subsection (boolean/and @emph{object}@dots{})
@anchor{booleanandp}
This procedure returns @code{@hashchar{}t} if none of its arguments are @code{@hashchar{}f}.
Otherwise it returns @code{@hashchar{}f}.

@node boolean/or object@dots{}
@subsection (boolean/or @emph{object}@dots{})
@anchor{booleanorp}
This procedure returns @code{@hashchar{}f} if all of its arguments are @code{@hashchar{}f}.
Otherwise it returns @code{@hashchar{}t}.

@node Symbols
@section Symbols
@anchor{symbols}
Unlike MIT/GNU Scheme, GoLisp only provides one type of symbol:
``interned''. Interned symbols are far more common than uninterned
symbols, and there are more ways to create them. We decided that
uninterned symbols were not necessary for our uses. Throughtout this
document ``symbol'' means ``interned symbol''

Symbols have an extremely useful property: any two symbols whose names
are the same, in the sense of @code{string=?}, are the same object (i.e.
they are @code{eq?} to one another). The term ``interned'' refers to the
process of ``interning'' by which this is accomplished.

The rules for writing an symbol are the same as the rules for writing an
identifier. Any symbol that has been returned as part of a literal
expression, or read using the @code{read} procedure and subsequently
written out using the @code{write} procedure, will read back in as the
identical symbol (in the sense of @code{eq?}).

Usually it is also true that reading in an symbol that was previously
written out produces the same symbol. An exception are symbols created
by the procedures @code{string->symbol} and @code{intern}; they can
create symbols for which this write/read invariance may not hold because
the symbols' names contain special characters.
@menu
* symbol? object::
* symbol->string symbol::
* intern string::
* string->symbol string::
* gensym [prefix]::
* symbol<? symbol1 symbol2::
@end menu

@node symbol? object
@subsection (symbol? @emph{object})
@anchor{symbol-object-1}
Returns @code{@hashchar{}t} if @emph{object} is a symbol, otherwise returns
@code{@hashchar{}f}.

@verbatim
(symbol? 'foo)                                  ==>  #t
(symbol? (car '(a b)))                          ==>  #t
(symbol? "bar")                                 ==>  #f
@end verbatim

@node symbol->string symbol
@subsection (symbol->string @emph{symbol})
@anchor{symbol-string-symbol}
Returns the name of @emph{symbol} as a string. If @emph{symbol} was
returned by @code{string->symbol}, the value of this procedure will be
identical (in the sense of @code{string=?}) to the string that was
passed to @code{string->symbol}. Unlike MIT/GNU Scheme, the result of
@code{symbol->string} is not converted to lower case.

@verbatim
(symbol->string 'flying-fish)           ==>  "flying-fish"
(symbol->string 'Martin)                ==>  "Martin"
(symbol->string (string->symbol "Malvina"))
                                        ==>  "Malvina"
@end verbatim

@node intern string
@subsection (intern @emph{string})
@anchor{intern-string}
Returns the symbol whose name is @emph{string}. This is the preferred
way to create symbols, as it guarantees the following independent of
which case the implementation uses for symbols' names:

@verbatim
(eq? 'bitBlt (intern "bitBlt")) ==>     #t
@end verbatim

The user should take care that @emph{string} obeys the rules for
identifiers, otherwise the resulting symbol cannot be read as itself.

@node string->symbol string
@subsection (string->symbol @emph{string})
@anchor{string-symbol-string}
Returns the interned symbol whose name is @emph{string}. Although you
can use this procedure to create symbols with names containing special
characters, it's usually a bad idea to create such symbols because they
cannot be read as themselves. See @code{symbol->string}.

@verbatim
(eq? 'mISSISSIppi 'mississippi)         ==>  #t
(string->symbol "mISSISSIppi")
     ==>  the symbol with the name "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt")) ==>  #t
(eq? 'JollyWog
      (string->symbol
        (symbol->string 'JollyWog)))    ==>  #t
(string=? "K. Harper, M.D."
           (symbol->string
             (string->symbol
               "K. Harper, M.D.")))     ==>  #t
@end verbatim

@node gensym [prefix]
@subsection (gensym [@emph{prefix}])
@anchor{gensym-prefix}
Create a new, unique symbol made from the @emph{prefix} (or
@code{GENSYM} if a prefix is omitted) and an increasing integer. This is
useful when you are generating code and need a unique name (in a macro,
for example).

@verbatim
(gensym)      ==> GENSYM1
(gensym)      ==> GENSYM2
(gensym)      ==> GENSYM3

(gensym "hi") ==> hi1
(gensym "ho") ==> ho1
(gensym "hi") ==> hi2
(gensym "ho") ==> ho2
(gensym "ho") ==> ho3
(gensym "hi") ==> hi3

(gensym)      ==> GENSYM4
@end verbatim

@node symbol<? symbol1 symbol2
@subsection (symbol<? @emph{symbol1} @emph{symbol2})
@anchor{symbol-symbol1-symbol2}
This procedure computes a total order on symbols. It is equivalent to

@verbatim
(string<? (symbol->string symbol1)
          (symbol->string symbol2))
@end verbatim

@node Bytearrays
@section Bytearrays
@anchor{bytearrays}
Bytearrays are an extension that GoLisp makes to Scheme arising from the
need to implement byte level communication protocols for SteelSeries
Engine 3.
@menu
* list->bytearray list of bytes and/or bytearrays::
* bytearray->list bytearray::
* replace-byte bytearray index value::
* replace-byte! bytearray index value::
* extract-byte bytearray index::
* append-bytes bytearray byte@dots{}::
* append-bytes bytearray list of bytes::
* append-bytes bytearray bytearray@dots{}::
* append-bytes! bytearray byte@dots{}::
* append-bytes! bytearray list of bytes::
* append-bytes! bytearray bytearray@dots{}::
* take k bytearray::
* drop k bytearray::
* extract-bytes bytearray index length::
@end menu

@node list->bytearray list of bytes and/or bytearrays
@subsection (list->bytearray @emph{list of bytes and/or bytearrays})
@anchor{list-bytearray-list-of-bytes-andor-bytearrays}
The list must be comprised of elements that are either numbers between 0
and 255, inclusive, or existing bytearray objects. The result is an
@emph{object} containing a @code{[]byte}.

@verbatim
(list->bytearray '(1 2 3 4))     ==> [1 2 3 4]
(list->bytearray '(1 [2 3] 4))   ==> [1 2 3 4]
(list->bytearray '([1 2] [3 4])) ==> [1 2 3 4]
@end verbatim

@node bytearray->list bytearray
@subsection (bytearray->list @emph{bytearray})
@anchor{bytearray-list-bytearray}
This is the opposite of the previous function. The result is a list
containing the numbers in the bytearray.

@verbatim
(bytearray->list [1 2 3 4]) ==> (1 2 3 4)
@end verbatim

@node replace-byte bytearray index value
@subsection (replace-byte @emph{bytearray} @emph{index} @emph{value})
@anchor{replace-byte-bytearray-index-value}
Makes a copy of @emph{bytearray} and replaces the byte at @emph{index}
with @emph{value}. The new bytearray with the replaced byte is returned.
@emph{index} must be a valid index into the byte array (zero based), and
@emph{value} must be a valid byte value, i.e. between 0 and 255,
inclusive.

@verbatim
(define a [1 2 3 4])    ==> [1 2 3 4]
(replace-byte a 2 100)  ==> [1 2 100 4]
a                       ==> [1 2 3 4]
@end verbatim

@node replace-byte! bytearray index value
@subsection (replace-byte! @emph{bytearray} @emph{index} @emph{value})
@anchor{replace-byte-bytearray-index-value-1}
Replaces the byte at @emph{index} with @emph{value}. @emph{index} must
be a valid index into the byte array (zero based), and @emph{value} must
be a valid byte value, i.e. between 0 and 255, inclusive. The original
byte array is modified and the returned bytearray object is the one that
is passed to the function.

@verbatim
(define a [1 2 3 4])    ==> [1 2 3 4]
(replace-byte! a 2 100) ==> [1 2 100 4]
a                       ==> [1 2 100 4]
@end verbatim

@node extract-byte bytearray index
@subsection (extract-byte @emph{bytearray} @emph{index})
@anchor{extract-byte-bytearray-index}
Fetch and return the byte at @emph{index}. @emph{index} must be a valid
index into the byte array (zero based).

@verbatim
(extract-byte [1 2 3 4] 2) ==> 3
@end verbatim

@node append-bytes bytearray byte@dots{}
@subsection (append-bytes @emph{bytearray} @emph{byte}@dots{})
@anchor{append-bytes-bytearray-byte}

@node append-bytes bytearray list of bytes
@subsection (append-bytes @emph{bytearray} @emph{list of bytes})
@anchor{append-bytes-bytearray-list-of-bytes}

@node append-bytes bytearray bytearray@dots{}
@subsection (append-bytes @emph{bytearray} @emph{bytearray}@dots{})
@anchor{append-bytes-bytearray-bytearray}
Appends the rest of the arguments to a copy of the bytearray that is the
first arg. The copy is returned. Things that can be appended are: a
single byte, a sequence of bytes (as a sequence of separate arguments),
a list of bytes, a bytearray object, a sequence of bytearray objects (as
a sequence of separate arguments), and code that evaluates to a byte,
list of bytes, or bytearray.

@verbatim
(append-bytes [1 2 3] 4)            ==> [1 2 3 4]
(append-bytes [1 2 3] 4 5 6)        ==> [1 2 3 4 5 6]
(append-bytes [1 2 3] '(4 5 6))     ==> [1 2 3 4 5 6]
(append-bytes [1 2 3] [4 5 6])        ==> [1 2 3 4 5 6]
(append-bytes [1 2 3] [4 5] [6])      ==> [1 2 3 4 5 6]
(append-bytes [1 2 3] (list 4 5 6))  ==> [1 2 3 4 5 6]
@end verbatim

@node append-bytes! bytearray byte@dots{}
@subsection (append-bytes! @emph{bytearray} @emph{byte}@dots{})
@anchor{append-bytes-bytearray-byte-1}

@node append-bytes! bytearray list of bytes
@subsection (append-bytes! @emph{bytearray} @emph{list of bytes})
@anchor{append-bytes-bytearray-list-of-bytes-1}

@node append-bytes! bytearray bytearray@dots{}
@subsection (append-bytes! @emph{bytearray} @emph{bytearray}@dots{})
@anchor{append-bytes-bytearray-bytearray-1}
As with @code{append-bytes}, but modifies and returns @emph{bytearray}
rather than making a copy.

@verbatim
(define a [1 2 3])  ==> [1 2 3]
(append-bytes a 4)  ==> [1 2 3 4]
a                   ==> [1 2 3]
(append-bytes! a 4) ==> [1 2 3 4]
a                   ==> [1 2 3 4]
@end verbatim

@node take k bytearray
@subsection (take @emph{k} @emph{bytearray})
@anchor{take-k-bytearray}
As with the list implementation of @code{take}, fetches and returns a
new bytearray consisting of the bytes from @emph{bytearray} starting at
index @emph{k}.

@verbatim
(take 1 [1 2 3] ==> [1])
(take 3 [1 2 3] ==> [1 2 3])
@end verbatim

@node drop k bytearray
@subsection (drop @emph{k} @emph{bytearray})
@anchor{drop-k-bytearray}

@verbatim
(drop 1 [1 2 3] ==> [2 3])
(drop 2 [1 2 3] ==> [3])
@end verbatim

As with the list implementation of @code{drop}, fetches and returns a
new bytearray consisting of the bytes from @emph{bytearray} prior to
index @emph{k}.

@node extract-bytes bytearray index length
@subsection (extract-bytes @emph{bytearray} @emph{index} @emph{length})
@anchor{extract-bytes-bytearray-index-length}
Returns a new bytearray consisting of @emph{length} bytes from
@emph{bytearray}, starting at index @emph{index}. This is functionally
equivalent to @code{(take length (drop index bytearray))} with bounds
checking added.

@verbatim
(extract-bytes [1 2 3 4 5] 0 1) ==> [1]
(extract-bytes [1 2 3 4 5] 0 3) ==> [1 2 3]
(extract-bytes [1 2 3 4 5] 2 1) ==> [3]
(extract-bytes [1 2 3 4 5] 2 3) ==> [3 4 5]
@end verbatim

@node Environments
@chapter Environments
@anchor{environments}
Scheme (and thus GoLisp) is lexically scoped. This is implemented by the
creation of a lexical environment (aka symbol table) for each lexical
scope:

@itemize
@item
function/lambda/macro invocations, which holds parameters and any local
definitions

@item
@code{let} structures, which hold the @code{let} bindings

@item
@code{do} structures, which hold the @code{do} bindings

@end itemize

Functions and lambdas capture a reference to the environment in which
they were defined, so they always have access to it's bindings (that's a
closure, btw).

Each environment has a connection to it's containing environment, and
can override/hide bindings in outer scopes. When a symbol is evaluated,
the most local environment is searched first. If a binding for the
system isn't found there, the containing environment is searched. This
continues until a binding for the sybol is found or we go all the way to
the global environment and still can't find a binding.

Section 3.2 of [1] does a great job of explaining environments in
Scheme, which is the basis for environments in GoLisp.

In Scheme, some environments are more important than others, mainly as
they tend to be larger, long lived, and serve as the root of many other
environments as a program runs. These are known as @emph{top level
environments}. Specifially, these are the global environment (the only
environment that is contained by nothing), and any environments directly
below it in the environment tree. The REPL runs in one such environment,
which effectively sandboxes it, protecting the bindings in the global
environment from corruption.

@node environment? object
@subsection (environment? @emph{object})
@anchor{environment-object}
Returns @code{@hashchar{}t} if @emph{object} is an environment; otherwise returns
@code{@hashchar{}f}.

@node environment-has-parent? environment
@subsection (environment-has-parent? @emph{environment})
@anchor{environment-has-parent-environment}
Returns @code{@hashchar{}t} if @emph{environment} has a parent environment;
otherwise returns @code{@hashchar{}f}.

@node environment-parent environment
@subsection (environment-parent @emph{environment})
@anchor{environment-parent-environment}
Returns the parent environment of @emph{environment}. It is an error if
@emph{environment} has no parent.

@node environment-bound-names environment
@subsection (environment-bound-names @emph{environment})
@anchor{environment-bound-names-environment}
Returns a newly allocated list of the names (symbols) that are bound by
@emph{environment}. This does not include the names that are bound by
the parent environment of @emph{environment}. It does include names that
are unassigned or keywords in @emph{environment}.

@node environment-macro-names environment
@subsection (environment-macro-names @emph{environment})
@anchor{environment-macro-names}
Returns a newly allocated list of the names (symbols) that are bound to
syntactic keywords in @emph{environment}.

@node environment-bindings environment
@subsection (environment-bindings @emph{environment})
@anchor{environment-bindings}
Returns a newly allocated list of the bindings of @emph{environment};
does not include the bindings of the parent environment. Each element of
this list takes one of two forms: @code{(symbol)} indicates that
@emph{symbol} is bound but unassigned, while @code{(symbol object)}
indicates that @emph{symbol} is bound, and its value is @code{object}.

@node environment-reference-type environment symbol
@subsection (environment-reference-type @emph{environment}
@emph{symbol})
@anchor{environment-reference-type}
Returns a symbol describing the reference type of @emph{symbol} in
@emph{environment} or one of its ancestor environments. The result is
one of the following:

@itemize
@item
@code{normal} means @emph{symbol} is a variable binding with a normal
value.

@item
@code{unassigned} means @emph{symbol} is a variable binding with no
value.

@item
@code{macro} means @emph{symbol} is a keyword binding.

@item
@code{unbound} means @emph{symbol} has no associated binding.

@end itemize

@node environment-bound? environment symbol
@subsection (environment-bound? @emph{environment} @emph{symbol})
@anchor{environment-boundp}
Returns @code{@hashchar{}t} if @emph{symbol} is bound in @emph{environment} or one
of its ancestor environments; otherwise returns @code{@hashchar{}f}. This is
equivalent to

@verbatim
(not (eq? ’unbound
          (environment-reference-type environment symbol)))
@end verbatim

@node environment-assigned? environment symbol
@subsection (environment-assigned? @emph{environment} @emph{symbol})
@anchor{environment-assignedp}
Returns @code{@hashchar{}t} if @emph{symbol} is bound in @emph{environment} or one
of its ancestor environments, and has a normal value. Returns @code{@hashchar{}f}
if it is bound but unassigned. Signals an error if it is unbound or is
bound to a keyword.

@node environment-lookup environment symbol
@subsection (environment-lookup @emph{environment} @emph{symbol})
@anchor{environment-lookup}
@emph{symbol} must be bound to a normal value in @emph{environment} or
one of its ancestor environments. Returns the value to which it is
bound. Signals an error if unbound, unassigned, or a keyword.

@node environment-lookup-macro environment symbol
@subsection (environment-lookup-macro @emph{environment} @emph{symbol})
@anchor{environment-lookup-macrop}
If @emph{symbol} is a keyword binding in @emph{environment} or one of
its ancestor environments, returns the value of the binding. Otherwise,
returns @code{@hashchar{}f}. Does not signal any errors other than argument-type
errors.

@node environment-assignable? environment symbol
@subsection (environment-assignable? @emph{environment} @emph{symbol})
@anchor{environment-assignablep}
@emph{symbol} must be bound in @emph{environment} or one of its ancestor
environments. Returns @code{@hashchar{}t} if the binding may be modified by side
effect.

@node environment-assign! environment symbol value
@subsection (environment-assign! @emph{environment} @emph{symbol}
@emph{value})
@anchor{environment-assign}
@emph{symbol} must be bound in @emph{environment} or one of its ancestor
environments, and must be assignable. Modifies the binding to have
@emph{value} as its value, and returns an unspecified result.

@node environment-definable? environment symbol
@subsection (environment-definable? @emph{environment} @emph{symbol})
@anchor{environment-definablep}
Returns @code{@hashchar{}t} if @emph{symbol} is definable in @emph{environment},
and @code{@hashchar{}f} otherwise.

@node environment-define environment symbol value
@subsection (environment-define @emph{environment} @emph{symbol}
@emph{value})
@anchor{environment-define}
Defines @emph{symbol} to be bound to object in @emph{environment}, and
returns an unspecified value. Signals an error if @emph{symbol} isn't
definable in @emph{environment}.

@node eval sexpr environment
@subsection (eval @emph{sexpr} @emph{environment})
@anchor{eval-with-environment}
Evaluates @emph{sexpr} in @emph{environment}. You rarely need eval in
ordinary programs; it is useful mostly for evaluating expressions that
have been created ``on the fly'' by a program.

@node system-global-environment
@subsection (system-global-environment)
The function @code{system-global-environment} is returns the
distinguished environment that's the highest level ancestor of all other
environments. It is the parent environment of all other top-level
environments. Primitives, system procedures, and most syntactic keywords
are bound in this environment.

@node the-environment
@subsection (the-environment)
Returns the current environment. This form may only be evaluated in a
top-level environment. An error is signalled if it appears elsewhere.

@node procedure-environment procedure
@subsection (procedure-environment @emph{procedure})
@anchor{procedure-environment}
Returns the closing environment of @emph{procedure}. Signals an error if
@emph{procedure} is a primitive procedure.

@node make-top-level-environment [names [values]]
@subsection (make-top-level-environment [@emph{names} [@emph{values}]])
@anchor{make-top-level-environment}
Returns a newly allocated top-level environment.
extend-top-level-environment creates an environment that has parent
environment, make-top-level-environment creates an environment that has
parent system-global-environment, and make- root-top-level-environment
creates an environment that has no parent.

The optional arguments @emph{names} and @emph{values} are used to
specify initial bindings in the new environment. If specified,
@emph{names} must be a list of symbols, and @emph{values} must be a list
of objects. If only @emph{names} is specified, each name in @emph{names}
will be bound in the environment, but unassigned. If @emph{names} and
@emph{values} are both specified, they must be the same length, and each
name in @emph{names} will be bound to the corresponding value in
@emph{values}. If neither @emph{names} nor @emph{values} is specified,
the environment will have no initial bindings.

Environments in GoLisp differ slightly from standard Scheme in that they
have a name attached. For the various forms of @code{let} and @code{do}
this is simply @code{"let"} and @code{"do"}, respectively. Not of much
use, but then these are just a byproduct of having lexical scopes.
What's more useful is the higher level environments. This brings us to
the real reason for adding environment support: game integration
sandboxes. When we were writing the game integration functionallity for
Engine3, we wanted each game's event handling to live in a separate
sandbox. This is implemented buy creating a new top level environment
under the global environment. The problem here is that it's off in it's
own world, separate from the repl. By naming environments (in this case
by the name of the game), we can add a function to return an environment
given it's name. That allows us to peek inside the sandbox from the
repl, examining and manipulating the bindings there. And so we added a
function to let us do that:

@node find-top-level-environment name
@subsection (find-top-level-environment @emph{name})
@anchor{find-top-level-environment-name}
Returns the top level environment with the given name.

@node Utility
@chapter Utility
@anchor{utility}
GoLisp provides a handful of utility functions.

@node random-byte
@subsection (random-byte)
Returns a psuedo-random unsigned integer between 0 and 255, inclusive.

@verbatim
(random-byte) ==> 13
(random-byte) ==> 207
@end verbatim

@node random
@subsection (random)
The return value is a pseudorandom integer in the range [0,
2,147,483,647]

@node random modulus
@subsection (random @emph{modulus})
@emph{Modulus} must be a positive real number. If @emph{modulus} is an
integer, @code{random} returns a pseudo-random number between zero
(inclusive) and @emph{modulus} (exclusive). If @emph{modulus} is the
float 1.0, the returned number is a float in the range [0.0, 1.0). Other
float values of @emph{modulus} are rejected.

@node sleep millis
@subsection (sleep @emph{millis})
@anchor{sleep}
Sleep for @emph{millis} milliseconds.

@verbatim
(sleep 1000)  ;; resumes execution 1 second later
@end verbatim

@node time expression@dots{}
@subsection (time @emph{expression}@dots{})
@anchor{time}
Evaluates each @emph{expression} and reports the number of milliseconds
taken to do so.

@node write-line object@dots{}
@subsection (write-line @emph{object}@dots{})
@anchor{write-line}
Writes the concatenation of the string forms of @emph{objects} followed
by a newline.

@verbatim
> (write-line "Hello, " 42 " world")
Hello, 42 world
===> ()
@end verbatim

@node str object@dots{}
@subsection (str @emph{object}@dots{})
@anchor{str}
If you provide multiple arguments to @code{str} it creates a string from
concatenating the string forms of all the @emph{objects}.

@verbatim
(str 1 "." 2) ==> "1.2"
@end verbatim

@node copy object
@subsection (copy @emph{object})
@anchor{copy}
Make a copy of the result of evaluating @emph{object}, IFF it's mutable.
This is limited to lists and association lists. All other values are
immutable. Copying an immutable item will return the item, whereas
copying a list or association list will make a deep copy of the
structure, and return it.

@node exec command arg@dots{}
@subsection (exec @emph{command} @emph{arg}@dots{})
@anchor{exec}
Makes an operating system call. @code{command} is the command to execute
and the @code{arg}s are the arguments passed on the command line to
@code{command}. @code{command} must be a string, and the @code{arg}s can
be anything.

@node Concurrency
@chapter Concurrency
GoLisp has limited concurrency support that is built on top of
goroutines and channels.
@menu
* Process management::
* Atomic Operations::
* Channels::
@end menu

@node Process management
@section Process management
@anchor{process-management}
These functions make use of a @emph{process} object. This is an opaque
piece of data that wraps a custom structure used by the concurrency
code; it is returned from @code{fork} and @code{schedule} and is used by
@code{proc-sleep}, @code{wake}, and @code{abandon} to interact with the
underlying goroutine.
@menu
* fork function::
* proc-sleep process millis::
* wake process::
* join process::
* schedule millis function::
* abandon process::
* reset-timeout process::
@end menu

@node fork function
@subsection (fork @emph{function})
@anchor{fork-function}
Executes @emph{function} in a separate goroutine. When @emph{function}
ends, the goroutine terminates. @emph{function} takes a single argument
which is the process object that is returned.

@verbatim
(define (run-once proc)
  (write-line "start")
  (sleep 1000)
  (write-line "stop"))

(fork run-once)

> start
[a second goes by]
stop
[run-once completes and the goroutine terminates]
@end verbatim

@node proc-sleep process millis
@subsection (proc-sleep @emph{process} @emph{millis})
@anchor{proc-sleep}
Use @code{proc-sleep} in a forked function to sleep for @emph{millis}
milliseconds. Using @code{proc-sleep} rather than @code{sleep} (which
can be used) allows code in another process (that has a reference to the
process object of the forked code) to preemptively terminate the sleep
using the @code{wake} function.

@code{proc-sleep} returns a boolean that indicates whether the sleep was
terminated using @code{wake}.

@node wake process
@subsection (wake @emph{process})
@anchor{wake}
Preemptively terminate a @code{proc-sleep} in the code associated with
@emph{process}.

@verbatim
> (define (run proc)
    (do ((woken #f woken))
        (woken (write-line "woken"))
      (write-line "tick")
      (set! woken (proc-sleep proc 10000))))

> (define p (fork run))

tick
tick
[times goes by, tick is printed every 10 seconds]
> (wake p)
woken
[run completes and the goroutine terminates]
@end verbatim

@node join process
@subsection (join @emph{process})
@anchor{join}
Blocks the calling function until the process completes or aborts with
an error. The return value of the process is returned, or nil if the
process ran into an error and aborted. Attempting to call @code{join} on
a process twice raises an error.

@verbatim
(define (run proc) '(1 2 3))
(define p (fork run))
(join p) ==> (1 2 3)
@end verbatim

@node schedule millis function
@subsection (schedule @emph{millis} @emph{function})
@anchor{schedule}
Schedule @emph{function} to be evaluated in a separate goroutine
@emph{millis} milliseconds from now. @emph{function} takes a single
argument which is the process object that is returned. The process
object associated with that goroutine is returned immediately.

@verbatim
> (define (run-delayed proc)
    (write-line "running"))

> (schedule 10000 run-delayed)
[10 seconds pass]
running
[run-delayed completes and the goroutine terminates]
@end verbatim

@node abandon process
@subsection (abandon @emph{process})
@anchor{abandon}
Cancels the scheduled evaluation associated with @emph{process}.

@verbatim
> (define (run-delayed proc)
    (write-line "running"))

> (define p (schedule 10000 run-delayed))
[5 seconds pass]
> (abandon p)
[the delay is cancelled and the goroutine terminates]
@end verbatim

@node reset-timeout process
@subsection (reset-timeout @emph{process})
@anchor{reset-timeout}
Resets the timer on a scheduled process. Causing it to start over. You
can use this function to postpone the evaluation of scheduled code.

@verbatim
> (define (run-delayed proc)
    (write-line "running"))

> (define p (schedule 10000 run-delayed))
[less than 10 seconds pass]
> (reset-timeout p)
[10 seconds pass]
running
[run-delayed completes and the goroutine terminates]
@end verbatim

@node Atomic Operations
@section Atomic Operations
@anchor{atomic-operations}
GoLisp has support for several kinds of atomic operations. These can be
useful for protecting memory when working with GoLisp code with
concurrent processes, or just Go code with multiple goroutines.

These functions make use of a @emph{atomic} object. This is an opaque
piece of data that wraps an integer; it is returned from @code{atomic}
and is used by all the @code{atomic-*} primitives to interact with the
underlying integer using only atomic operations.
@menu
* atomic [value]::
* atomic-load atomic::
* atomic-store! atomic new::
* atomic-add! atomic delta::
* atomic-swap! atomic new::
* atomic-compare-and-swap! atomic old new::
@end menu

@node atomic [value]
@subsection (atomic [@emph{value}])
@anchor{atomic}
Creates a new @emph{atomic} object and returns it. It can optionally be
passed a starting value to initialize to. Otherwise, the starting value
is 0.

@verbatim
> (atomic)   ==> <atomic object with value 0>
> (atomic 5) ==> <atomic object with value 5>
@end verbatim

@node atomic-load atomic
@subsection (atomic-load @emph{atomic})
@anchor{atomic-load}
Loads the current integer value of the @emph{atomic} object and returns
it as an integer.

@verbatim
> (define a (atomic 5))
> (atomic-load a) ==> 5
@end verbatim

@node atomic-store! atomic new
@subsection (atomic-store! @emph{atomic} @emph{new})
@anchor{atomic-store-bang}
Stores a new integer value in a @emph{atomic} object.

@verbatim
> (define a (atomic 5))
> (atomic-store! a 8)
> (atomic-load a) ==> 8
@end verbatim

@node atomic-add! atomic delta
@subsection (atomic-add! @emph{atomic} @emph{delta})
@anchor{atomic-add-bang}
Adds the @emph{delta} value to the one stored in the @emph{atomic}
object. The new sum is also returned.

@verbatim
> (define a (atomic 5))
> (atomic-add! a 4) ==> 9
> (atomic-load a)   ==> 9
@end verbatim

@node atomic-swap! atomic new
@subsection (atomic-swap! @emph{atomic} @emph{new})
@anchor{atomic-swap-bang}
Swaps the value currently in the @emph{atomic} object with a new value.
The old value is returned.

@verbatim
> (define a (atomic 5))
> (atomic-swap! a 4) ==> 5
> (atomic-load a)    ==> 4
@end verbatim

@node atomic-compare-and-swap! atomic old new
@subsection (atomic-compare-and-swap! @emph{atomic} @emph{old} @emph{new})
@anchor{atomic-compare-and-swap-bang}
The value in the @emph{atomic} object is compared to @emph{old}. If the
value matches, the value in the @emph{atomic} object is swapped with the
value in @emph{new} and true is returned. Otherwise, the values are not
swapped and false is returned.

@verbatim
> (define a (atomic 5))
> (atomic-compare-and-swap! a 5 4) ==> #t
> (atomic-load a)                  ==> 4

> (define b (atomic 5))
> (atomic-compare-and-swap! b 9 4) ==> #f
> (atomic-load b)                  ==> 5
@end verbatim

@node Channels
@section Channels
@anchor{channels}
Channels are the main way you communicate between goroutines in Go.
GoLisp has full support of channels.
@menu
* make-channel [buffer-size]::
* channel-write channel value::
* channel<- value::
* channel-read channel::
* <-channel::
* channel-try-write channel value::
* channel-try-read channel::
* close-channel channel::
@end menu

@node make-channel [buffer-size]
@subsection (make-channel [@emph{buffer-size}])
@anchor{make-channel}
Creates a new channel object with an optional buffer size. If
@emph{buffer-size} is omitted or 0, the channel is unbuffered.

@node channel-write channel value
@subsection (channel-write @emph{channel} @emph{value})
@anchor{channel-write}

@node channel<- value
@subsection (@emph{channel}<- @emph{value})
@anchor{channel-write-sugar}
Writes a value to a channel. If the channel is unbuffered or has a full
buffer, this call locks until there either another process tries to read
from the channel or room is made in the buffer.

@node channel-read channel
@subsection (channel-read @emph{channel})
@anchor{channel-read}

@node <-channel
@subsection (<-@emph{channel})
@anchor{channel-read-sugar}
Reads a value from a channel. If the channel is unbuffered or has no
buffered data, this call locks until there is data in the channel.
@code{<-channel} returns two values. The first value is the data read
from the channel. The second value is a boolean flag stating whether
there is more data in the channel. If the channel is closed and there
are no more items left in the buffer, a false flag is returned.
Otherwise, a true flag is returned. If a flag of false is returned, the
first value will also be nil.

@verbatim
> (define c (make-channel 1))
> (channel-write c 1)
> (c<- 1) ; alternate syntax for the previous line
> (channel-read c) ==> (1 #t)
> (<-c)            ==> (1 #t) ; alternate syntax for the previous line
> (channel-read c) ; blocks until another process writes to c
@end verbatim

@node channel-try-write channel value
@subsection (channel-try-write @emph{channel} @emph{value})
@anchor{channel-try-write}
Tries to write a value to a channel. If the channel is unbuffered with
nobody waiting for a write or has a full buffer, it returns immediately
a false value. Otherwise, it writes the value to the channel and returns
a true value.

@quotation
(define c (make-channel 1) (channel-try-write c 1) ==> #t
@end quotation
@quotation
(define c (make-channel)) (channel-try-write c 1) ==> #f
@end quotation

@node channel-try-read channel
@subsection (channel-try-read @emph{channel})
@anchor{channel-try-read}
Tries to reads a value from a channel. This call returns three values.
The first is whether data could be read or not. The second is the data
that is read, or nil if none was. The last value is whether the channel
has more data in it.

@verbatim
> (define c (make-channel 1))
> (c<- 1)
> (channel-try-read c) ==> (#t 1 #t)
> (channel-try-read c) ==> (#f () #t)
@end verbatim

@node close-channel channel
@subsection (close-channel @emph{channel})
@anchor{close-channel}
Closes the specified channel. The channel's buffered is cleared by any
other goroutines trying to read from it then all other reads immediately
return with the more flag set to false. Trying to write to a closed
channel or trying to close a channel twice results in an error.

@verbatim
> (define c (make-channel 1))
> (c<- 1)
> (close-channel c)
> (<-c) ==> (1 #t)
> (<-c) ==> (() #f)
> (<-c) ==> (() #f) ; repeats on subsequent calls
> (channel-try-read c) ==> (#t () #f)
@end verbatim

@node Time and Date
@chapter Time and Date
@anchor{time-and-date}
All of these date and time function use the local time.

@node time-now
@subsection (time-now)
Return the current local time as a list of the form
@code{(hour minute second)}.

@verbatim
(time-now) ==> (19 53 50)
@end verbatim

@node seconds
@subsection (seconds)
Returns the number of seconds since midnight on the current day.

@verbatim
(seconds) ==> 71644
@end verbatim

@node millis
@subsection (millis)
Returns the number of milliseconds since midnight on the current day.

@verbatim
(millis) ==> 71646935
@end verbatim

@node date-today
@subsection (date-today)
Return today's date as a list of the form @code{(year month day)}.

@verbatim
(date-today) ==> (2016 12 19)
@end verbatim

@node date-in-days days
@subsection (date-in-days @emph{days})
@anchor{date-in-days}
Return the date in @emph{days} days from today as a list of the form
@code{(year month day)}.

@verbatim
(date-in-days 3) ==> (2016 12 22)
@end verbatim

@node day-of-week
@subsection (day-of-week)
Returns a symbol representing the current day of the week.

@verbatim
(day-of-week) ==> monday
@end verbatim

@node Timers
@chapter Timers
@anchor{timers}

@node timer millis func
@subsection (timer @emph{millis} @emph{func})
@anchor{timer}
Schedules @emph{func} (a function of zero arguments) to be evaluated
after @emph{millis} milliseconds. Returns a timer object.

@node stop-timer timer
@subsection (stop-timer @emph{timer})
@anchor{stop-timer}
Stop and cancel the timer @emph{timer}.

@node ticker millis func
@subsection (ticker @emph{millis} @emph{func})
@anchor{ticker}
Schedules @emph{func} (a function of zero arguments) to be evaluated
after @emph{millis} milliseconds and every @emph{millis} milliseconds
thereafter until stopped. Returns a ticker object.

@node stop-ticker ticker
@subsection (stop-ticker @emph{ticker})
@anchor{stop-ticker}
Stop and cancel the ticker @emph{ticker}.

@node Input/Output
@chapter Input/Output
@anchor{inputoutput}

@node open-input-file filename
@subsection (open-input-file @emph{filename})
@anchor{open-input-file}
Takes a @emph{filename} referring to an existing file and returns an
input port capable of delivering characters from the file.

@node open-output-file filename [append?]
@subsection (open-output-file @emph{filename} [@emph{append?}])
@anchor{open-output-file}
Takes a @emph{filename} referring to an output file to be created and
returns an output port capable of writing characters to a new file by
that name.

If @emph{append?} is given and not @code{@hashchar{}f}, the file is opened in
append mode. In this mode, the contents of the file are not overwritten;
instead any characters written to the file are appended to the end of
the existing contents. If the file does not exist, append mode creates
the file and writes to it in the normal way.

@node close-port port
@subsection (close-port @emph{port})
@anchor{close-port}
Closes @emph{port} and returns an unspecified value. The associated file
is also closed.

@node write-bytes byte-array output-port
@subsection (write-bytes @emph{byte-array} @emph{output-port})
@anchor{write-bytes}
Writes @emph{byte-array} to @emph{output-port} as a stream of raw bytes.
Most usefull for interacting with external devices via serial/usb ports.

@node write-string string [output-port]
@subsection (write-string @emph{string} [@emph{output-port}])
@anchor{write-string}
Writes @emph{string} to @emph{output-port}, performs discretionary
output flushing, and returns an unspecified value.

@node newline [output-port]
@subsection (newline [@emph{output-port}])
@anchor{newline}
Writes an end-of-line to @emph{output-port}, performs discretionary
output flushing, and returns an unspecified value.

@node write object [output-port]
@subsection (write @emph{object} [@emph{output-port}])
@anchor{write}
Writes a written representation of @emph{object} to @emph{output-port},
and returns an unspecified value. If @emph{object} has a standard
external representation, then the written representation generated by
@code{write} shall be parsable by @code{read} into an equivalent object.
Thus strings that appear in the written representation are enclosed in
doublequotes, and within those strings backslash and doublequote are
escaped by backslashes. @code{write} performs discretionary output
flushing and returns an unspecified value.

@node read-string [input-port]
@subsection (read-string [@emph{input-port}])
@anchor{read-string}
Reads characters from @emph{input-port} until it finds a terminating
character or encounters end of line. The port is updated to point to the
terminating character, or to end of line if no terminating character was
found. @code{read-string} returns the characters, up to but excluding
the terminating character, as a newly allocated string.

@node read [input-port]
@subsection (read [@emph{input-port}])
@anchor{read}
Converts external representations of Scheme objects into the objects
themselves. read returns the next object parsable from
@emph{input-port}, updating @emph{input-port} to point to the first
character past the end of the written representation of the object. If
an end of file is encountered in the input before any characters are
found that can begin an object, read returns an end-of-file object. The
@emph{input-port} remains open, and further attempts to read will also
return an end-of-file object. If an end of file is encountered after the
beginning of an object's written representation, but the written
representation is incomplete and therefore not parsable, an error is
signalled.

@node eof-object? object
@subsection (eof-object? @emph{object})
@anchor{eof-objectp}
Returns @code{@hashchar{}t} if @emph{object} is an end-of-file object; otherwise
returns @code{@hashchar{}f}.

@node format destination control-string argument@dots{}
@subsection (format @emph{destination} @emph{control-string}
@emph{argument}@dots{})
@anchor{format}
Writes the characters of @emph{control-string} to @emph{destination},
except that a tilde (@code{~}) introduces a format directive. The
character after the tilde, possibly preceded by prefix parameters and
modifiers, specifies what kind of formatting is desired. Some directives
use an @emph{argument} to create their output; the typical directive
puts the next @emph{argument} into the output, formatted in some special
way. It is an error if no @emph{argument} remains for a directive
requiring an @emph{argument}.

The output is sent to @emph{destination}. If @emph{destination} is
@code{@hashchar{}f}, a string is created that contains the output; this string is
returned as the value of the call to @code{format}. If
@emph{destination} is @code{@hashchar{}t}, the output is sent to @code{stdout}. In
all other cases @code{format} returns an unspecified value. Otherwise,
destination must be an output port, and the output is sent there.

A format directive consists of a tilde (@math{\sim}), an optional prefix
parameter, an optional at-sign (@code{@@}) modifier, and a single
character indicating what kind of directive this is. The alphabetic case
of the directive character is ignored. The prefix parameters are
generally integers, notated as optionally signed decimal numbers.

In place of a prefix parameter to a directive, you can put the letter
@code{V} (or @code{v}), which takes an argument for use as a parameter
to the directive. Normally this should be an integer. This feature
allows variable-width fields and the like. You can also use the
character @code{#} in place of a parameter; it represents the number of
arguments remaining to be processed.

@code{~A}: The next argument, which may be any object, is printed as if
by write-line. @code{~<mincol>A} inserts spaces on the right, if
necessary, to make the width at least @code{mincol} columns. The
@code{@@} modifier causes the spaces to be inserted on the left rather
than the right.

@code{~S}: The next argument, which may be any object, is printed as if
by write (in as read-able format as possible). @code{~mincolS} inserts
spaces on the right, if necessary, to make the width at least mincol
columns. The @code{@@} modifier causes the spaces to be inserted on the
left rather than the right.

@code{~%}: This outputs a newline character. This outputs a
@code{@hashchar{}@backslashchar{}newline} character. @code{~n%} outputs n newlines. No argument
is used. Simply putting a newline in control-string would work, but
@code{~%} is often used because it makes the control string look nicer
in the middle of a program.

@code{~~}: This outputs a tilde; @code{~n~}: outputs n tildes.

@code{~newline}: Tilde immediately followed by a newline ignores the
newline and any following whitespace characters. With an @code{@@}, the
newline is left in place, but any following whitespace is ignored. This
directive is typically used when control-string is too long to fit
nicely into one line of the program:

@verbatim
(define (type-clash-error procedure arg spec actual)
   (format
    #t
    "~%Procedure ~S~%requires its %A argument ~
     to be of type ~S,~%but it was called with ~
     an argument of type ~S.~%"
    procedure arg spec actual))
(type-clash-error ’vector-ref
                  "first"
                  ’integer
                  ’vector)
@end verbatim

prints

@verbatim
Procedure vector-ref
requires its first argument to be of type integer,
but it was called with an argument of type vector.
@end verbatim

Note that in this example newlines appear in the output only as
specified by the @math{\sim}% directives; the actual newline characters
in the control string are suppressed because each is preceded by a
tilde.

@node Compiling
@chapter Compiling
@anchor{compiling}

@node Testing
@chapter Testing
@anchor{testing}
Golisp has a builtin testing framework, completely written in GoLisp.
@menu
* Structure::
* Assertions::
* Usage::
@end menu

@node Structure
@section Structure
@anchor{structure}
Contests and it-clauses divide up the testing of a system under test
into fixtures and focused sets of assertions.
@menu
* context tag-string fixture it@dots{}::
* it tag assertion@dots{}::
@end menu

@node context tag-string fixture it@dots{}
@subsection (context @emph{tag-string} @emph{fixture} @emph{it}@dots{})
@anchor{context-tag-string-fixture-it}
@emph{tag-string} is a string used to identify the context in the test
run's output. This should describe what the context focusses on.
@emph{fixture} is a sequence of expressions that typically add
definitions (symbol bindings) to the environment created by
@code{context}. Each @emph{it} expression (defined using @code{it})
performs speific tests relevant to the context.

@node it tag assertion@dots{}
@subsection (it @emph{tag} @emph{assertion}@dots{})
@anchor{it-tag-assertion}
This defines a cohesive block of assertions. The context's fixture code
will be run in a new environment for each @emph{it} block, thus
isolating each it.

@node Assertions
@section Assertions
@anchor{assertions}
Assertions are used to make provable (via execution) statements about
the system under test.
@menu
* assert-true expression::
* assert-false expression::
* assert-eq actual expected::
* assert-neq actual expected::
* assert-nil expression::
* assert-not-nil expression::
* assert-error expression::
* assert-nerror expression::
@end menu

@node assert-true expression
@subsection (assert-true @emph{expression})
@anchor{assert-true-expression}
Passes if @emph{expression} evaluates to a truthy value, fails
otherwise.

@node assert-false expression
@subsection (assert-false @emph{expression})
@anchor{assert-false-expression}
Passes if @emph{expression} evaluates to a falsy value, fails otherwise.

@node assert-eq actual expected
@subsection (assert-eq @emph{actual} @emph{expected})
@anchor{assert-eq-actual-expected}
Passes if the result of evaluating @emph{actual} is equal (using
@code{(equal? actual expected)}) to the result of evaluating
@emph{expected}, fails otherwise.

@node assert-neq actual expected
@subsection (assert-neq @emph{actual} @emph{expected})
@anchor{assert-neq-actual-expected}
Passes if the result of evaluating @emph{actual} is @strong{not} equal
(using @code{(not (equal? actual expected))}to the result of evaluating
@emph{expected}, fails otherwise.

@node assert-nil expression
@subsection (assert-nil @emph{expression})
@anchor{assert-nil-expression}
Passes if @emph{expression} evaluates to nil, fails otherwise.

@node assert-not-nil expression
@subsection (assert-not-nil @emph{expression})
@anchor{assert-not-nil-expression}
Passes if @emph{expression} evaluates to anything @strong{other than}
nil, fails otherwise.

@node assert-error expression
@subsection (assert-error @emph{expression})
@anchor{assert-error-expression}
Passes if evaluating @emph{expression} results in an error being
signalled, fails if it evaluates without problems.

@node assert-nerror expression
@subsection (assert-nerror @emph{expression})
@anchor{assert-nerror-expression}
Passes if evaluating @emph{expression} does not result in an error being
signalled, fails if it the evaluation signals an error.

@node Usage
@section Usage
@anchor{usage}
Generally you should create a test file for each feature you are
testing. The file is a plain lisp file and can contain any lisp code,
including global variable and function definitions.

For example, here is the test file for scoping:

@verbatim
(context "environments"

  ((define a 5)
   (define (foo a)
     (lambda (x)
      (+ a x))))

  (it "can access a in the global env"
      (assert-eq a 5))

  (it "gets a from the function's local env"
      (assert-eq ((foo 1) 5) 6)
      (assert-eq ((foo 2) 5) 7)
      (assert-eq ((foo 10) 7) 17)))
@end verbatim

Running a test results in a stream of status output for each test,
followed at the very end by a summary. Running the above results in the
following:

@verbatim
environments

  can access a in the global env
    (assert-eq a 5)

  gets a from the function's local env
    (assert-eq ((foo 1) 5) 6)
    (assert-eq ((foo 2) 5) 7)
    (assert-eq ((foo 10) 7) 17)

Ran 4 tests in 0.003 seconds
4 passes, 0 failures, 0 errors
@end verbatim

If we introduce a failure, the output would be:

@verbatim
environments

  can access a in the global env
    (assert-eq a 5)

  gets a from the function's local env
    (assert-eq ((foo 1) 5) 6)
    (assert-eq ((foo 2) 5) 8)
      - expected 8, but was 7
    (assert-eq ((foo 10) 7) 17)

Ran 4 tests in 0.002 seconds
3 passes, 1 failures, 0 errors

Failures:
  environments gets a from the function's local env:
    (assert-eq ((foo 2) 5) 8)
      - expected 8, but was 7
@end verbatim

Errors are also reported. Errors are problems that occur while
evaluating the clauses, that aren't failures. Essentially they indicate
bugs of some sort.

@verbatim
environments

  can access a in the global env
    (assert-eq a 5)

  gets a from the function's local env
    (assert-eq ((foo 1) 5) 6)
    ERROR: Quotent: (7 0) -> Divide by zero.

Ran 3 tests in 0.002 seconds
2 passes, 0 failures, 1 errors

Errors:
  environments gets a from the function's local env:
    ERROR: Quotent: (7 0) -> Divide by zero.
@end verbatim

The above output was generated by the testing framwork running in
verbose mode. You can also run in quiet mode which only outputs the
summary:

@verbatim
Ran 4 tests in 0.003 seconds
4 passes, 0 failures, 0 errors
@end verbatim

You run tests by running the golisp repl in test mode, providing either
a directory or filename. If you provide a directory all files in it that
match @code{*_test.scm} will be run. If you provide a filename, only
that file will be run.

@verbatim
$golisp -t tests/scope_test.scm

Ran 4 tests in 0.002 seconds
4 passes, 0 failures, 0 errors


$golisp -t tests

Ran 935 tests in 0.273 seconds
935 passes, 0 failures, 0 errors
@end verbatim

Adding the @code{-v} flag will produce the detailed output above.

@node Extending GoLisp
@chapter Extending GoLisp
@anchor{extending-golisp}
@menu
* Defining primitives::
* Defining primitives with argument type checking::
* Defining special forms::
* Data::
@end menu

@node Defining primitives
@section Defining primitives
@anchor{defining-primitives}
The Go function @code{MakePrimitiveFunction} allows you to create
primitive functions.

@verbatim
MakePrimitiveFunction(name string, argCount string,
                      function func(*Data, *SymbolTableFrame)(*Data, error))
@end verbatim

The arguments are:

@enumerate 
@item
The function name. This is the name of a symbol which will be used to
reference the function.

@item
An argument count expectation. This is a string that specifies how many
arguments the primitive expects. It can take several forms:

@itemize
@item
A single, specific number. E.g. exactly two: @code{"2"}

@item
A minimum number. E.g. at least two: @code{">=2"}

@item
A range of values. E.g. between two and five, inclusive: @code{"(2,5)"}

@item
One of a selection of the above: E.g. @code{"2|3|>=5"}

@item
An unspecified number, any checking must be done in the primitive
definition: @code{"*"}

@end itemize

@item
The Go function which implements the primitive. This function
@strong{must} have the signature

@verbatim
 func <Name>(args *Data, env *SymbolTableFrame) (*Data, error)
@end verbatim

@end enumerate

The implementing function takes two parameters as seen above:

@enumerate 
@item
A Lisp list containing the arguments

@item
The environment in which the primitive is being evaluated. This is used
when calling @code{Eval} or @code{Apply}, as well as for any symbol
lookups or bindings.

@end enumerate

Primitives use, like functions defined in LISP, applicative evaluation
order. That means that all arguments are evaluated and the resulting
values passed to the function. This frees you from having to evaluate
the arguments and handle errors. You still have to verify the number of
arguments (only if you used -1 as trhe argument cound in the
@code{MakePrimitiveFunction} call) and their type, if applicable.

@verbatim
MakeSpecialForm(name string,
                argCount int,
                function func(*Data, *SymbolTableFrame) (*Data, error))
@end verbatim

An example:

@verbatim
MakePrimitiveFunction("!", "1", BooleanNot)

func BooleanNot(args *Data, env *SymbolTableFrame) (result *Data, err error) {
    val := BooleanValue(First(args))
    return BooleanWithValue(!val), nil
 }
@end verbatim

You can extend the goLisp runtime without changing any of it's code. You
simply import the golisp package (typically aliased to @code{.} to make
the code less noisy) and place calls to @code{MakePrimitiveFunction} in
your package's @code{init} block.

@node Defining primitives with argument type checking
@section Defining primitives with argument type checking
@anchor{defining-primitives-with-argument-type-checking}
There is also the @code{MakeTypedPrimitiveFunction} function that takes
an additional argument which is an array of @code{uint32}s, one element
for each argument. If the defined function accepts an arbitrary number
of arguments, the final type specification is used for the remainder.
For example, if there are 3 argument type specifications and the
function is passed 5 arguments, the final specification is used for the
3rd, 4th, and 5th arguments.

@verbatim
MakeTypedPrimitiveFunction("mqtt/publish", "3", mqttPublishImpl, 
                           []uint32\{StringType, IntegerType, StringType\})
@end verbatim

There is not currently a way to provide a type specification for a
primitive's return value.

@node Defining special forms
@section Defining special forms
@anchor{defining-special-forms}
There is another, very similar function that you will typically not need
unless you are hacking on the language itself (as opposed to adding
builting functions):

@verbatim
MakeSpecialForm(name string,
                argCount int,
                function func(*Data, *SymbolTableFrame) (*Data, error))
@end verbatim

Arguments and the signature of the implementing function are identical
to @code{MakePrimitiveFunction}. The only difference is that this
defines a @emph{special form} which uses normal evaluation order. I.e.
arguments are not evaluated before calling the function; the raw
sexpressions are passed in. Thus the implementing function has full
control over what gets evaluated and when. For example:

@verbatim
MakeSpecialForm("if", "2|3", IfImpl)

func IfImpl(args *Data, env *SymbolTableFrame) (result *Data, err error) {
    c, err := Eval(First(args), env)
    if err != nil {
        return
    }

    if BooleanValue(c) {
        return Eval(Second(args), env)
    } else {
        return Eval(Third(args), env)
    }
}
@end verbatim

@node Data
@section Data
@anchor{data}
The core lisp data element is the data type which logically contains a
type tag and a value. The type tags are defined by the constants:
@code{ConsCellType}, @code{NumberType}, @code{BooleanType},
@code{StringType}, @code{SymbolType}, @code{FunctionType},
@code{PrimitiveType}, @code{ObjectType}. As the language evolves this
list (and the associated functions) will change. Refer to the file
@code{data.go} for the definitive information.

The types are described earlier. If you need to check the type of a
piece of data you can fetch it's type using the
@code{TypeOf(*Data) uint32} function and then compare it to a type tag
constant. Additionally there are predicate functions for the most common
types that have the general form:

@bye
