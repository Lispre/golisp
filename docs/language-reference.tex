
\documentclass{article}

\usepackage[utf8x]{inputenc}

\usepackage[T1]{fontenc}
\usepackage{listings}

\setcounter{footnote}{0}

\setlength{\parskip}{0.5cm plus4mm minus3mm}
\setlength{\parindent}{0pt}

\title{SteelSeries GoLisp v1.1: Language Reference}
\author{Dave Astels}

\begin{document}
\maketitle

\begin{abstract}
  Steelseries GoLisp is a Lisp-like language inspired by and based on the opensource MIT/GNU
  Scheme. As such, much of the functionallity is identical and much of the text herein is
  taken more or less verbatim from the associated reference manual [6]. Only functions
  documented here are included, and any differences from the MIT/GNU Scheme equivalents are
  noted.
\end{abstract}

\section{Running GoLisp}\label{sec:running-golisp}

Before GoLisp will work, the environment variable \verb|GOLISPHOME| must be defined as the
path where the GoLisp \verb|lisp| and \verb|tools| directories are located.

\begin{verbatim}
golisp [options] [files-to-load] [- program-args]
\end{verbatim}

\verb|files-to-load| is a series of filenames or directories to be loaded at startup (after
the core library files are loaded). Any files, and contained files, that end in ``.scm'' are
loaded.

Supported \verb|options|:

\begin{itemize}
\item {\bf\verb|-r|} after files have been loaded, drop into the REPL. This will cause GoLisp
  to NOT use the \verb|main| function if it is present.
\item {\bf\verb|-t test-file-or-directory|} loads and runs tests contained in
  \verb|test-file-or-directory| (files ending in ``.scm'').
\item {\bf\verb|-v|} use with \verb|-t| to request verbose test output.
\item {\bf\verb|-d "symbol=value"|} define something in the global environment. The lisp
  equivalent is \verb|(define symbol value)|. \verb|value| must be a literal constant.
\item {\bf\verb|-e "code"|} after startup (i.e. the standard library has loaded as well as any
  files specified on the command line), evaluate \verb|code|. The result is printed and,
  unless the REPL has been requested, GoLisp exits. E.g.
\begin{verbatim}
>:golisp -e "(+ 2 3)"
==> 5
\end{verbatim}
\end{itemize}

Once options are processed and neither testing mode nor REPL mode have been requested and no
expression has been supplied to be evaluated, then a
function named \verb|main| is look for. If found it is applied to the values, if any, that
follow the \verb|-|.

\section{Data types}\label{sec:data-types}

\textbf{Booleans} represent true and false. Boolean literals are \verb|#t| and \verb|#f|
for true and false, respectively. The only thing that is considered to be logically false is
\verb|#f|. Everything else is logically true, inluding 0 and the empty list, which may
surprise some.

\textbf{Integers} are sixtyfour bit signed integers. Both decimal ,hexadecimal, and binary
formats are supported. E.g. \verb|26|, \verb|#x1a|, \verb|#x1A|, \verb|#b00011001|.

\textbf{Floats} are Go \verb|float32| numbers. Accordingly they are signed. All arithmetic
functions with the exception of modulus work as expected for both integers and floats. Numbers
are coerced to floats as required, specifically if any arguments are float, all are converted
to float and the result will be a float.

\textbf{Characters} are single characters. This is differen than strings with length 1.

\textbf{Strings} are any sequence of characters other than \verb|"| enclosed by a pair of
\verb|"|, e.g. \verb|"string"|. If you need to have \verb|"| in a string, use
\verb|\"|.

\textbf{Symbols} are simple identifiers, e.g. \verb|function-name|. Symbols follow the
follow 3 simple rules:

\begin{itemize}
\item can only contain graphic characters (i.e. no control characters)
\item can not contain any of the characters: \verb|();,"`&[]{}\|
\item can not begin with a number or single quote
\item can not contain whitespace
\end{itemize}

Typically, \verb|-| is used to separate words in a symbol, \verb|_| is used in special
symbols (such as system use) to separate words and as a prefix and suffix. The characters
\verb|?|, \verb|!|, and \verb|*| are typically used as the final character of a function
name to denote:

\textbf{?} a predicate, e.g. \verb|nil?|

\textbf{!} a mutating function (changes the argument rather than returning a modified copy),
e.g. \verb|set-car!|

\textbf{*} a variant of the primary function, e.g. \verb|flatten| (which does a one level
flattening of a list) and \verb|flatten*| (which is a recursive \verb|flatten|)

If a symbol ends with \verb|:| it is what is called a \emph{naked symbol}. It has no value
other than itself. If it is evaluated, the result is the symbol itself. This feature is
utilized by frames.

\textbf{Cons Cells}, aka \textbf{Lists} are the central data type in classic Lisp used both as
dotted pairs \verb|(a . b)| and general lists \verb|(a b)|. For an overview of cons cells
and how to use them see [1], [3], or
\texttt{http://cs.gmu.edu/\ensuremath{\sim}sean/lisp/cons/}. Note that dotted pairs
\emph{require} spaces around the period; \verb|(a.b)| is a list containing the symbol
\verb|a.b|, not a cons cell with car of \verb|a| and cdr of \verb|b|.

\textbf{Bytearrays} are simply objects that encapsulate \verb|[]byte| objects. The
difference is that there is syntactic support for them. Use square braces surrounding a list
of numbers between 0 and 255, inclusive. For example: \verb|[1 2 3 4 5]|. That format will
parse to an \verb|object| containing a the Go bytearray (i.e. \verb|[]byte|). Bytearrays
evaluate to themselves. There are also functions for doing bytearray manipulation.

\textbf{Channels} are simple objects that encapsulate Go `channel' objects.

\textbf{Vectors} are a more efficient alternative to lists when the number of elements are
known ahead of time and static. A vector can be grown, but it's done explicitly with a
function. Many enumeration and access functions that accept a list (or lists) can be passed a
vector (or vectors) instead.

\textbf{Ports} provide access to files for reading and writing.

\textbf{Frames} are sets of named slots that hold arbitrary values, including functions.
Frames can \emph{inherit} from other frames in a prototypical manner. They are inspired by the
languages Self [4] and Newtonscript [5].

\textbf{Functions} are user defined procedures. They are covered in detail later.

\textbf{Macros} are user defined syntactic extensions. Note that GoLisp macros are not yet
hygenic, so use caution.

You can create an manipulate all of the above types in GoLisp. There are two more types that
are usable in GoLisp, but can only be created in Go.

\textbf{Primitives} are just as they are in Lisp or Smalltalk: functions written in the
implementation language, in this case Go, and exposed as functions in Lisp. The combinaion of
primitives and objects allow you to integrate with the underlying Go program. \textbf{Special
  Forms} are almost identical to primitives, except that they use normal evaluation order
instead of applicative order which functions and primitives use.

\textbf{Objects} allow you to encapsulate a Go object (struct) in a Lisp data object. There is
no way to do this from Lisp itself, but is useful when writing primitive functions (see
below). The objects can be used as any other object, but are opaque outside of primitives
built to use them.

\section{Special Forms}\label{sec:special-forms}

A special form is an expression that follows special evaluation rules. This section describes
the basic GoLisp special forms.

\subsection{Lambda Expressions}\label{sec:lambda-expressions}

\subsubsection{(lambda \emph{formals} \emph{sexpr}\ldots{})}

A \textbf{lambda} expression evaluates to a procedure. The environment in effect when the
\textbf{lambda} expression is evaluated is remembered as part of the procedure; it is called
the \emph{closing environment}. When the procedure is later called with some arguments, the
closing environment is extended by binding the variables in the formal parameter list to fresh
locations, and the locations are filled with the arguments according to rules about to be
given. The new environment created by this process is referred to as the \emph{invocation
  environment}.

Once the invocation environment has been constructed, the \emph{sexprs} in the body of the
\textbf{lambda} expression are evaluated sequentially in that environment. This means that the
region of the variables bound by the \textbf{lambda} expression is all of the \emph{sexprs} in
the body. The result of evaluating the last \emph{sexpr} in the body is returned as the result
of the procedure call.

\emph{formals}, the formal parameter list, is often referred to as a \emph{lambda list}.

The process of matching up formal parameters with arguments is somewhat involved, but simpler
than Scheme. There are two types of parameters, and the matching treats each in sequence:

\textbf{Required}

All of the \emph{required} parameters are matched against the arguments first. If there are
fewer arguments than required parameters, a \verb|wrong number of arguments| error is
signalled; this error is also signalled if there are more arguments than required parameters
and there are no further parameters.

\textbf{Rest}

Finally, if there is a \emph{rest} parameter (there can only be one), any remaining arguments
are made into a list, and the \emph{rest} parameter is bound to it. (If there are no remaining
arguments, the \emph{rest} parameter is bound to the empty list.)

In Scheme, unlike some other Lisp implementations, the list to which a \emph{rest} parameter is bound
is always freshly allocated. It has infinite extent and may be modified without affecting the
procedure's caller.

A period, i.e. ``.'', is used to separate the \emph{rest} parameter (if there is one) from the
\emph{required} parameters. The ``.'' \textbf{must} be surrounded by spaces.

\verb|(a b c)|: \verb|a|, \verb|b|, and \verb|c| are all required. The procedure must be
passed exactly three arguments.

\verb|(a b . c)|: \verb|a| and \verb|b| are required and \verb|c| is rest. The procedure may
be passed two or more arguments.

Some examples of \textbf{lambda} expressions:

\begin{verbatim}
(lambda (x) (+ x x))            ⇒  <function: unnamed>

((lambda (x) (+ x x)) 4)        ⇒  8

(define reverse-subtract
  (lambda (x y)
    (- y x)))
(reverse-subtract 7 10)         ⇒  3

(define foo
  (let ((x 4))
    (lambda (y) (+ x y))))
(foo 6)                         ⇒  10
\end{verbatim}

\subsection{Lexical Binding}\label{sec:lexical-binding}

The three binding constructs \verb|let|, \verb|let*|, and \verb|letrec|, give Scheme block
structure. The syntax of the three constructs is identical, but they differ in the regions
they establish for their variable bindings. In a \verb|let| expression, the initial values are
computed before any of the variables become bound. In a \verb|let*| expression, the
evaluations and bindings are sequentially interleaved. And in a \verb|letrec| expression, all
the bindings are in effect while the initial values are being computed (thus allowing mutually
recursive definitions).

\subsubsection{(let ((\emph{variable} \emph{init})\ldots{}) \emph{sexpr}\ldots{})}

The \emph{inits} are evaluated in the current environment (in some unspecified order), the
\emph{variables} are bound to fresh locations holding the results, the \emph{sexprs} are
evaluated sequentially in the extended environment, and the value of the last \emph{sexpr} is
returned. Each binding of a \emph{variable} has the sequence of \emph{sexpr} as its region.

GoLisp allows any of the \emph{inits} to be omitted, in which case the corresponding
\emph{variables} are unassigned.

Note that the following are equivalent:

\begin{verbatim}
(let ((variable init)...) expression...)
((lambda (variable...) expression...) init...)
\end{verbatim}

Some examples:

\begin{verbatim}
(let ((x 2) (y 3))
  (* x y))                              ⇒  6

(let ((x 2) (y 3))
  (let ((foo (lambda (z) (+ x y z)))
        (x 7))
    (foo 4)))                           ⇒  9
\end{verbatim}

\subsubsection{(let* ((\emph{variable} \emph{init})\ldots{}) \emph{sexpr}\ldots{})}

\verb|let*| is similar to \verb|let|, but the bindings are performed sequentially from left to
right, and the region of a binding is that part of the `let*' expression to the right of the
binding. Thus the second binding is done in an environment in which the first binding is
visible, and so on.

Note that the following are equivalent:

\begin{verbatim}
(let* ((variable1 init1)
       (variable2 init2)
       ...
       (variablen initn))
   expression...)

(let ((variable1 init1))
  (let ((variable2 init2))
    ...
      (let ((variablen initn))
        expression...)
    ...))
\end{verbatim}

An example:

\begin{verbatim}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))                           ⇒  70
\end{verbatim}

\subsubsection{(letrec ((\emph{variable} \emph{init})\ldots{}) \emph{sexpr}\ldots{})}

The \emph{variables} are bound to fresh locations holding unassigned values, the \emph{inits}
are evaluated in the extended environment (in some unspecified order), each \emph{variable} is
assigned to the result of the corresponding \emph{init}, the \emph{expressions} are evaluated
sequentially in the extended environment, and the value of the last \emph{expression} is
returned. Each binding of a \emph{variable} has the entire \verb|letrec| expression as its
region, making it possible to define mutually recursive procedures.

Any of the \emph{inits} may be omitted, in which case the corresponding \emph{variable} is
unassigned.

\begin{verbatim}
(letrec ((even? (lambda (n)
                  (if (zero? n)
                      #t
                      (odd? (- n 1)))))
         (odd? (lambda (n)
                 (if (zero? n)
                     #f
                     (even? (- n 1))))))
(even? 88))                                 ⇒  #t
\end{verbatim}

One restriction on \verb|letrec| is very important: it shall be possible to evaluated each
\emph{init} without assigning or referring to the value of any \emph{variable}. If this
restriction is violated, then it is an error. The restriction is necessary because Scheme
passes arguments by value rather than by name. In the most common uses of \verb|letrec|, all
the \emph{inits} are \textbf{lambda} expressions and the restriction is satisfied
automatically.

\subsection{Definitions}\label{sec:definitions}

\subsubsection{(define \emph{variable} [\emph{sexpr}])}

\subsubsection{(define \emph{formals} [\emph{doc-string}] \emph{sexpr}\ldots{})}

Definitions are valid in some but not all contexts where expressions are allowed. Definitions
may only occur at the top level of a program and at the beginning of a lambda body (that is,
the body of a \verb|lambda|, \verb|let|, \verb|let*|, \verb|letrec|, or procedure
\verb|define| expression). A definition that occurs at the top level of a program is called a
\emph{top-level definition}, and a definition that occurs at the beginning of a body is called
an \emph{internal definition}.

The second form is used as a shorthand to define a procedure. The first ``required parameter''
in \emph{formals} is not a parameter but the \emph{name} of the resulting procedure; thus
\emph{formals} must have at least one required parameter.

Hence the following are identical.

\begin{verbatim}
(define inc (lambda (x) (+ x 1)))
(define (inc x) (+ x 1))
\end{verbatim}

Using this form of define, a function that accepts a completely option set of arguments can be made:

\begin{verbatim}
(define (f . args) args)

(f) ⇒ ()
(f 1) ⇒ (1)
(f 1 2 3) ⇒ (1 2 3)
\end{verbatim}

Please note: You can not currently define a lambda with completely optional arguments.

Finally, you can also provide a documentation string between the \emph{formals} and the body.
For example:

\begin{verbatim}
(define (inc x) 
  "Increment the argument." 
  (+ x 1))
\end{verbatim}

\subsubsection{(doc \emph{func})}
 
This retrieves the documentation for the function \emph{func}.

\subsection{Type Signatures}\label{sec:type-signatures}

GoLisp provides basic, and optional, type checking for the arguments and return values of user
defined functions. Additionally, primtive functions also have type checking on arguments, as
appropriate.

\subsubsection{(typedef \emph{fname} \emph{arg-types}\ldots{} [-\textgreater{} \emph{return-type}])}

This is similar to defining a function: \emph{fname} is the name of a function that will be
defined later (typicaly the next form) and \emph{arg-types} correspond to its arguments). But
with \verb|typedef| these are argument type specification, not argument names.

Argunment type specifications can take two forms: \emph{type} which can be a string or symbol,
or a set of types separated by a pipe (E.g. \verb?"integer|string"?) with no spaces. The
latter must be a string.

When a function is passed a type that does not match its specified type(s) an error is raised,
similar to:


\begin{verbatim}
> (typedef less-than number number)
> (define (less-than x y) (\textless{} x y))
> (less-than 1 4.3)
==> #t
> (less-than 1 'a)
Error in evaluation: 
Evaling (less-than 1 'a). less-than argument 1 has the wrong type, 
                          expected float or integer but was given symbol
\end{verbatim}

A type specification can also include a type specification of the result of the function. Note
that the \verb|->| is required. If a return type is not provided, \verb|anytype| is the default.

\begin{verbatim}
> (typedef less-than number number -> boolean)
> (define (less-than x y) (if (< x y) 'yes 'no))
> (less-than 1 4.3)
Error in evaluation: 
Evaling (less-than 1 4.3). less-than returns the wrong type, 
                           expected boolean but returned symbol
\end{verbatim}

The following types are supported:

\begin{itemize}
\item list
\item vector
\item sequence (equivalent to list|vector)
\item integer
\item float
\item number (equivalent to integer|float)
\item boolean
\item string
\item character
\item symbol
\item stringy (equivalent to string|symbol)
\item function
\item macro
\item primitive
\item procedure (equivalent to function|primitive)
\item boxedobject
\item frame
\item environment
\item port
\item anytype (equivalent to all the above typed combined)
\end{itemize}

Note that the \emph{list} type just requires a ConsCell; if a proper list or other specific
type is required, then either \verb|http://daveastels.typed.com/blog/code-contracts-in-golisp|
pre-conditions or explicit tests will be needed.

Putting all this together, a complete definition of a function would look like:

\begin{verbatim}
(typedef inc number -> number)
(define (inc x) 
  "Increment the argument." 
  (+ x 1))
\end{verbatim}

\subsubsection{(type \emph{func})}
 
This retrieves the type signature for the function \emph{func}.

\begin{verbatim}
(type inc)
==> (number -> number)

\end{verbatim}

\subsection{Top-Level Definitions}\label{sec:top-level-definitions}

A top-level definition,

\begin{verbatim}
(define variable sexpr)
\end{verbatim}

has essentially the same effect as this assignment expression, if \emph{variable} is bound:

\begin{verbatim}
(set! variable expression)
\end{verbatim}

If \emph{variable} is not bound, however, \verb|define| binds \emph{variable} to a new
location in the current environment before performing the assignment (it is an error to
perform a \verb|set!| on an unbound variable).

\begin{verbatim}
(define add3
  (lambda (x) (+ x 3)))                ⇒  unspecified
(add3 3)                                ⇒  6

(define first car)                      ⇒  unspecified
(first '(1 2))                          ⇒  1

(define bar)                            ⇒  unspecified
bar                                     error--> Unassigned variable
\end{verbatim}

\subsection{Internal Definitions}\label{sec:internal-definitions}

An \emph{internal definition} is a definition that occurs at the beginning of a \emph{body}
(that is, the body of a \verb|lambda|, \verb|let|, \verb|let*|, \verb|letrec|, or
procedure \verb|define| expression), rather than at the top level of a program. The
variable defined by an internal definition is local to the \emph{body}. That is,
\emph{variable} is bound rather than assigned, and the region of the binding is the entire
\emph{body}. For example,

\begin{verbatim}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                        ⇒  45
\end{verbatim}

A \emph{body} containing internal definitions can always be converted into a completely
equivalent \verb|letrec| expression. For example, the \verb|let| expression in the above
example is equivalent to

\begin{verbatim}
(let ((x 5))
  (letrec ((foo (lambda (y) (bar x y)))
           (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
\end{verbatim}

\subsection{Assignments}\label{sec:assignments}

\subsubsection{(set! \emph{variable} \emph{object})}

\emph{expression} is evaluated and the resulting value is stored in the location to which
\emph{variable} is bound. The value of the \verb|set!| expression is unspecified.

\emph{variable} must be bound either in some region enclosing the \verb|set!|
expression, or at the top level. However, \textbf{variable} is permitted to be
unassigned when the `set!' form is entered.

\begin{verbatim}
(define x 2)                            ⇒  unspecified
(+ x 1)                                 ⇒  3
(set! x 4)                              ⇒  unspecified
(+ x 1)                                 ⇒  5
\end{verbatim}

\subsection{Quoting}\label{sec:quoting}

This section describes the expressions that are used to modify or prevent the evaluation of
objects.

\subsubsection{(quote \emph{datum})}

\textbf{(quote \emph{datum})} evaluates to \emph{datum}. \emph{datum} may be any external
representation of a GoLisp object. Use \verb|quote| to include literal constants in Scheme
code.

\begin{verbatim}
(quote a)                               ⇒  a
(quote #(a b c))                        ⇒  #(a b c)
(quote (+ 1 2))                         ⇒  (+ 1 2)
\end{verbatim}

\verb|(quote datum)| may be abbreviated as \verb|'datum|. The two notations are equivalent
in all respects.

\begin{verbatim}
'a                                      ⇒  a
'#(a b c)                               ⇒  #(a b c)
'(+ 1 2)                                ⇒  (+ 1 2)
'(quote a)                              ⇒  (quote a)
''a                                     ⇒  (quote a)
\end{verbatim}

Numeric constants, string constants, character constants, and boolean constants evaluate to
themselves, so they don't need to be quoted.

\begin{verbatim}
'"abc"                                  ⇒  "abc"
"abc"                                   ⇒  "abc"
'145932                                 ⇒  145932
145932                                  ⇒  145932
'#t                                     ⇒  #t
#t                                      ⇒  #t
\end{verbatim}

\subsubsection{(quasiquote \emph{template})}

``Backquote'' or ``quasiquote'' expressions are useful for constructing a list or vector
structure when most but not all of the desired structure is known in advance. If no commas
appear within the \emph{template}, the result of evaluating is equivalent (in the sense of
\verb|equal?|) to the result of evaluating \verb|'template|. If a comma appears within the
\emph{template}, however, the expression following the comma is evaluated (``unquoted'') and
its result is inserted into the structure instead of the comma and the expression. If a comma
appears followed immediately by an at-sign (@), then the following expression shall evaluate
to a list; the opening and closing parentheses of the list are then ``stripped away'' and the
elements of the list are inserted in place of the comma at-sign expression sequence.

\begin{verbatim}
`(list ,(+ 1 2) 4)                       ⇒  (list 3 4)

(let ((name 'a)) `(list ,name ',name))   ⇒  (list a 'a)

`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b)    ⇒  (a 3 4 5 6 b)

`((foo ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons)))
                                         ⇒  ((foo 7) . cons)

`#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8)
                                         ⇒  #(10 5 2 4 3 8)

`,(+ 2 3)                                ⇒  5
\end{verbatim}

Quasiquote forms may be nested. Substitutions are made only for unquoted components appearing
at the same nesting level as the outermost backquote. The nesting level increases by one
inside each successive quasiquotation, and decreases by one inside each unquotation.

\begin{verbatim}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
     ⇒  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)

(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))       ⇒  (a `(b ,x ,'y d) e)
\end{verbatim}

The above notations and \verb|(quasiquote template)| are identical in all respects. is identical
to and is identical to .

\begin{verbatim}
(quasiquote (list (unquote (+ 1 2)) 4))
           ⇒  (list 3 4)

'(quasiquote (list (unquote (+ 1 2)) 4))
           ⇒  `(list ,(+ 1 2) 4)
           _i.e.,_ (quasiquote (list (unquote (+ 1 2)) 4))
\end{verbatim}

Unpredictable behavior can result if any of the symbols \verb|quasiquote|, \verb|unquote|,
or \verb|unquote-splicing| appear in a \emph{template} in ways otherwise than as described
above.

\subsection{Macros}\label{sec:macros}

\subsubsection{(define-macro (\emph{formals}) \emph{template})}

\subsubsection{(defmacro (\emph{formals}) \emph{template})}

\emph{The former is from standard Scheme and is the preferred name. The latter is retained for
  backward compatibility with earlier versions of GoLisp.}

Create a named macro:

\emph{formals} is the same as in a procedure definition: a name followed by formal parameters,
if any. \textbf{NOTE} that the arguments to a macro invocation are \textbf{not} evaluated, but
are passed as is to the macro to do with as it wishes.

\emph{template} the template expression that is processed when the macro is invoked. The
result of evaluating the processed template expression becomes the value of the macro's
invocation. \emph{template} is typically (even always) a quasiquoted expression using the
formal parameter names for purposes of unquotiing in order to fill in the template.

\begin{verbatim}
(define-macro (double x)
   `(+ ,x ,x))

(double 5) ⇒ 10
\end{verbatim}

\subsubsection{(expand \emph{name} [\emph{object}\ldots{}])}

Expands the macro named by \emph{name}, passing the evaluated sequence of \emph{object} as
arguments. \textbf{NOTE:} whereas invoking the macro (in the same way you invoke a function)
expands and evaluates, \verb|expand| (as you would expect) only expands the macro, resulting
in the expanded template sexpr. This can then be evaluated as desired.

\begin{verbatim}
(define-macro (double x)
   `(+ ,x ,x))

(expand double 5) ⇒ (+ 5 5)
\end{verbatim}

\subsection{Sequencing}\label{sec:sequencing}

The \verb|begin| special form is used to evaluate expressions in a particular order.

\subsubsection{(begin \emph{expression} \ldots{})}

The \emph{expressions} are evaluated sequentially from left to right, and the value of the
last \emph{expression} is returned. This expression type is used to sequence side effects such
as input and output. Keep in mind, \verb|begin| does \textbf{not} create a nested lexical
environment.

\begin{verbatim}
(define x 0)
(begin (set! x 5)
       (+ x 1))                 ⇒  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))
                                -|  4 plus 1 equals 5
                                ⇒  unspecified
\end{verbatim}

Often the use of \verb|begin| is unnecessary, because many special forms already support
sequences of expressions (that is, they have an implicit \verb|begin|). Some of these
special forms are:

\begin{itemize}
\item case
\item cond
\item define          ;''procedure define'' only
\item do
\item lambda
\item let
\item let*
\item letrec
\end{itemize}

\subsubsection{(-\textgreater{} \emph{value} \emph{sexpr}\textbar{}\emph{symbol}\ldots{})}

This creates a function chain. \emph{value} (evaluated first) is used as the first argument to
the first \emph{sexpr}. The result of each \emph{sexpr} is used as the first argument of the
next, and the result of the final \emph{sexpr} is the value of the \verb|->|
form. If a \emph{sexpr} would take a single argument (which would be provided by the
\emph{value} or the result of the previous \emph{sexpr}, just the function name can be used.

The form \verb|(-> 0 a b c)| is equivalent to \verb|(c (b (a 0)))|.

\begin{verbatim}
(-> 1 (+ 3) (- 2))     ⇒ 2     ; (- (+ 1 3) 2)
(-> 1 (+ 3) (- 2) str) ⇒ "2"   ; (str (- (+ 1 3) 2))
\end{verbatim}

The major advantage of this form is avoiding having to create a sequence on intermediate
values/bindings purely to support the data flow. \verb|->| lets you create a
pipeline that you can put one value into and get the final result out the other end.

\subsubsection{(=\textgreater{} \emph{value} \emph{sexpr}\textbar{}\emph{symbol}\ldots{})}

This operates similarly to \verb|->| with two differences:

\begin{enumerate}
\item \emph{value} (evaluated \textbf{once} at the beginning) is used as the initial argument
  to \textbf{each} function, and they are independent and do not pass results one to another.
\item \emph{value} is the result of the form.
\end{enumerate}

The expression

\begin{verbatim}
(=> 1 a b c)
\end{verbatim}

is equivalent to

\begin{verbatim}
(begin
  (a 1)
  (b 1)
  (c 1)
  1)
\end{verbatim}

and

\begin{verbatim}
(=> (+ x 1) a b c)
\end{verbatim}

is the same as

\begin{verbatim}(let ((y (+ x 1)))
  (a y)
  (b y)
  (c y)
  y)
\end{verbatim}

\subsection{Conditionals}\label{sec:conditionals}

The behavior of the ``conditional expressions'' is determined by whether objects are true or
false. The conditional expressions count only \verb|#f| as false. They count everything
else, including \verb|#t|, pairs, symbols, numbers, strings, vectors, and procedures as
true.

In the descriptions that follow, we say that an object has ``a true value'' or ``is true''
when the conditional expressions treat it as true, and we say that an object has ``a false
value'' or ``is false'' when the conditional expressions treat it as false.

\subsubsection{(cond \emph{clause}\ldots{})}

Each \emph{clause} has this form:

\begin{verbatim}(predicate expression...)
\end{verbatim}

where \emph{predicate} is any expression. The last \emph{clause} may be an ``\verb|else|
clause'', which has the form:

\begin{verbatim}(else expression...)
\end{verbatim}

A \verb|cond| expression does the following:

\begin{enumerate}
\item Evaluates the \emph{predicate} expressions of successive \emph{clauses} in order, until
  one of the \emph{predicates} evaluates to a true value.
\item When a \emph{predicate} evaluates to a true value, \verb|cond| evaluates the
  \emph{expressions} in the associated \emph{clause} in left to right order, and returns the
  result of evaluating the last \emph{expression} in the \emph{clause} as the result of the
  entire \verb|cond| expression. If the selected \emph{clause} contains only the
  \emph{predicate} and no \emph{expressions}, \verb|cond| returns the value of the
  \emph{predicate} as the result.
\item If all \emph{predicates} evaluate to false values, and there is no \verb|else| clause,
  the result of the conditional expression is unspecified; if there is an \verb|else|
  clause, \verb|cond| evaluates its \emph{expressions} (left to right) and returns the value
  of the last one.

\begin{verbatim}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))                  ⇒  greater

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))                    ⇒  equal
\end{verbatim}
\end{enumerate}

Normally, programs should not depend on the value of a \verb|cond| expression that has no
\verb|else| clause. However, some Scheme programmers prefer to write \verb|cond|
expressions in which at least one of the \emph{predicates} is always true. In this style, the
final \emph{clause} is equivalent to an \verb|else| clause.

GoLisp (and Scheme) supports an alternative clause syntax:

\begin{verbatim}
(predicate => recipient)
\end{verbatim}

where \emph{recipient} is an expression. If \emph{predicate} evaluates to a true value, then
\emph{recipient} is evaluated. Its value must be a procedure of one argument; this procedure
is then invoked on the value of the \emph{predicate}.

\begin{verbatim}
(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else #f))                        ⇒  2
\end{verbatim}

\subsubsection{(case \emph{key} \emph{clause}\ldots{})}

\emph{key} may be any expression.  Each \emph{clause} has this form:

\begin{verbatim}
((object...) expression...)
\end{verbatim}

No \emph{object} is evaluated, and all the \emph{objects} must be distinct. The last
\emph{clause} may be an ``\textbf{else} clause'', which has the form:

\begin{verbatim}
(else expression...)
\end{verbatim}

A \verb|case| expression does the following:

\begin{enumerate}
\item Evaluates \emph{key} and compares the result with each \emph{object}.
\item If the result of evaluating \emph{key} is equivalent (in the sense of \verb|eqv?|) to
  an \emph{object}, \verb|case| evaluates the \emph{expressions} in the corresponding
  \emph{clause} from left to right and returns the result of evaluating the last
  \emph{expression} in the \emph{clause} as the result of the \verb|case| expression.
\item If the result of evaluating \emph{key} is different from every \emph{object}, and if
  there's an \verb|else| clause, \verb|case| evaluates its \emph{expressions} and returns
  the result of the last one as the result of the \verb|case| expression. If there's no
  \verb|else| clause, \verb|case| returns an unspecified result. Programs should not
  depend on the value of a \verb|case| expression that has no \verb|else| clause.
\end{enumerate}

For example,

\begin{verbatim}
(case (* 2 3)
   ((2 3 5 7) 'prime)
   ((1 4 6 8 9) 'composite)) ⇒  composite

(case (car '(c d))
   ((a) 'a)
   ((b) 'b))                 ⇒  unspecified

(case (car '(c d))
   ((a e i o u) 'vowel)
   ((w y) 'semivowel)
   (else 'consonant))        ⇒  consonant
\end{verbatim}

\subsubsection{(and \emph{expression}\ldots{})}

The \emph{expressions} are evaluated from left to right, and the value of the first
\emph{expression} that evaluates to a false value is returned. Any remaining
\emph{expressions} are not evaluated. If all the \emph{expressions} evaluate to true values,
the value of the last \emph{expression} is returned. If there are no \emph{expressions} then
\verb|#t| is returned.

\begin{verbatim}
(and (= 2 2) (> 2 1)) ⇒  #t
(and (= 2 2) (< 2 1)) ⇒  #f
(and 1 2 'c '(f g))   ⇒  (f g)
(and)                 ⇒  #t
\end{verbatim}

\subsubsection{(or \emph{expression}\ldots{})}

The \emph{expressions} are evaluated from left to right, and the value of the first
\emph{expression} that evaluates to a true value is returned. Any remaining \emph{expressions}
are not evaluated. If all \emph{expressions} evaluate to false values, the value of the last
\emph{expression} is returned. If there are no \emph{expressions} then \verb|#f| is
returned.

\begin{verbatim}
(or (= 2 2) (> 2 1))            ⇒  #t
(or (= 2 2) (< 2 1))            ⇒  #t
(or #f #f #f)                   ⇒  #f
(or (memq 'b '(a b c)) (/ 3 0)) ⇒  (b c)
\end{verbatim}

\subsubsection{(if \emph{predicate} \emph{consequent} [\emph{alternative}])}

\verb|if| is a macro based on \verb|cond|.

\emph{predicate}, \emph{consequent}, and \emph{alternative} are expressions. An \verb|if|
expression is evaluated as follows: first, \emph{predicate} is evaluated. If it yields a true
value, then \emph{consequent} is evaluated and its value is returned. Otherwise
\emph{alternative} is evaluated and its value is returned. If \emph{predicate} yields a false
value and no \emph{alternative} is specified, then the result of the expression is
unspecified.

An \verb|if| expression evaluates either \emph{consequent} or \emph{alternative}, never
both. Programs should not depend on the value of an \verb|if| expression that has no
\emph{alternative}.

\begin{verbatim}
(if (> 3 2) 'yes 'no)                   ⇒  yes
(if (> 2 3) 'yes 'no)                   ⇒  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                            ⇒  1
\end{verbatim}

\subsubsection{(when \emph{predicate} \emph{expression}\ldots{})}

\verb|when| is a macro based on \verb|cond|.

If \emph{predicate} evaluates to logically \verb|true|, the sequence of \emph{expresions} is
evaluated and the result of the last one is the result of the \verb|when| form, otherwise
\verb|nil| is the result.

\begin{verbatim}
(when (> x 5)
  (write-line "greater")
  (+ x 2))
\end{verbatim}

The above is equivalent to the following, but is simpler and clearer.

\begin{verbatim}
(if (> x 5)
    (begin (write-line "greater")
           (+ x 2)))
\end{verbatim}

\subsubsection{(unless \emph{predicate} \emph{expression}\ldots{})}

\verb|unless| is a macro based on \verb|cond|.

If \emph{predicate} evaluates to logically \verb|false|, the sequence of \emph{expresions}
is evaluated and the result of the last one is the result of the \verb|unless| form,
otherwise \verb|nil| is the result.

\begin{verbatim}
(unless (> x 5)
  (write-line "greater")
  (+ x 2))
\end{verbatim}

The above is equivalent to the following, but is much simpler and clearer.

\begin{verbatim}
(if (> x 5)
    ()
    (begin (write-line "greater")
           (+ x 2)))
\end{verbatim}

\subsection{Iteration}\label{sec:iteration}

The ``iteration expressions'' are: ``named \verb|let|'' and \verb|do|. They are also
binding expressions, but are more commonly referred to as iteration expressions.

\subsubsection{(let \emph{name} ((\emph{variable} \emph{init})\ldots{}) \_expression\ldots{})}

GoLisp permits a variant on the syntax of \emph{let} called ``named \verb|let|'' which
provides a more general looping construct than \verb|do|, and may also be used to
express recursions.

Named \verb|let| has the same syntax and semantics as ordinary \verb|let| except that
\emph{name} is bound within the \emph{expressions} to a procedure whose formal arguments are
the \emph{variables} and whose body is the \emph{expressions}. Thus the execution of the
\emph{expressions} may be repeated by invoking the procedure named by \emph{name}.

GoLisp allows any of the \emph{inits} to be omitted, in which case the corresponding
\emph{variables} are unassigned.

Note: the following expressions are equivalent:

\begin{verbatim}
(let name ((variable init)...)
  expression...)

((letrec ((name
           (lambda (variable...)
             expression...)))
   name)
 init...)
\end{verbatim}

Here is an example:

\begin{verbatim}
(let loop
     ((numbers '(3 -2 1 6 -5))
      (nonneg '())
      (neg '()))
  (cond ((null? numbers)
         (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        (else
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))

     ⇒  ((6 1 3) (-5 -2))
\end{verbatim}

\subsubsection{(do ((\emph{variable} \emph{init} \emph{step})\ldots{}) (\emph{test} \emph{expression}\ldots{}) \emph{command}\ldots{})}

\verb|do| is an iteration construct. It specifies a set of variables to be bound, how they
are to be initialized at the start, and how they are to be updated on each iteration. When a
termination condition is met, the loop exits with a specified result value.

\verb|do| expressions are evaluated as follows: The \emph{init} expressions are evaluated
(in some unspecified order), the \emph{variables} are bound to fresh locations, the results of
the \emph{init} expressions are stored in the bindings of the \emph{variables}, and then the
iteration phase begins.

Each iteration begins by evaluating \emph{test}; if the result is false, then the
\emph{command} expressions are evaluated in order for effect, the \emph{step} expressions are
evaluated in some unspecified order, the \emph{variables} are bound to fresh locations, the
results of the \emph{steps} are stored in the bindings of the \emph{variables}, and the next
iteration begins.

If \emph{test} evaluates to a true value, then the \emph{expressions} are evaluated from left
to right and the value of the last \emph{expression} is returned as the value of the
\verb|do| expression. If no \emph{expressions} are present, then the value of the
\verb|do| expression is the empty list (i.e. \verb|nil|).

The region of the binding of a \emph{variable} consists of the entire \verb|do| expression
except for the \emph{inits}. It is an error for a \emph{variable} to appear more than once in
the list of \verb|do| variables.

A \emph{step} may be omitted, in which case the effect is the same as if
\verb|(variable init variable)| had been written instead of \verb|(variable init)|.

\begin{verbatim}
(do ((vec (make-vector 5))
      (i 0 (+ i 1)))
     ((= i 5) vec)
   (vector-set! vec i i))        ⇒  #(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
   (do ((x x (cdr x))
        (sum 0 (+ sum (car x))))
       ((null? x) sum)))         ⇒  25
\end{verbatim}

\subsection{Eval/Apply}\label{sec:evalapply}

\subsubsection{(apply \emph{function} \emph{object}\ldots{})}

Apply the function that results from evaluating \emph{function} to the argument list resulting
from evaluating each \emph{object}.

Each initial \emph{object} can be any type of object, but the final one (and there must be at
least one \emph{object}) must be a list.

\begin{verbatim}
(apply + 1 2 '(3 4)) ⇒ 10
(apply + '(1 2 3 4)) ⇒ 10
\end{verbatim}

\subsubsection{(eval \emph{expression})}

Evaluate \emph{expression} in the current environment.

\begin{verbatim}(eval '(+ 1 2 3 4)) ⇒ 10
\end{verbatim}

\subsubsection{(definition-of \emph{function})}

Fetch the definition of \emph{function}. This returns an expression that can be evaluated to
define it. One use of this is to copy definitions to a source file.

\begin{verbatim}
(define (square x)
  (* x x))

(definition-of square) ⇒ (define (square x) (* x x))

(define square (lambda (x)
                 (* x x)))

(definition-of square) ⇒ (define square (lambda (x) (* x x)))
\end{verbatim}

\section{Type tests}\label{sec:type-tests}

\subsubsection{(atom? \emph{object})}

Returns whether \emph{object} is an atom, i.e. a number, string, boolean, or symbol.

\subsubsection{(list? \emph{object})}

Returns whether \emph{object} is a list.

\subsubsection{(pair? \emph{object})}

Returns whether \emph{object} is a pair, i.e. a list or a dotted pair.

\subsubsection{(alist? \emph{object})}

Returns whether \emph{object} is an association list.

\subsubsection{(vector? \emph{object})}

Returns \verb|#t| if \verb|object| is a vector; otherwise returns \verb|#f|.

\subsubsection{(nil? \emph{object})}

\subsubsection{(null? \emph{object})}

Returns whether \emph{object} is an empty list, i.e. the nil value.

\subsubsection{(notnil? \emph{object})}

\subsubsection{(notnull? \emph{object})}

Returns whether \emph{object} is not an empty list, i.e. the nil value.

\subsubsection{(symbol? \emph{object})}

Returns whether \emph{object} is a symbol.

\subsubsection{(string? \emph{object})}

Returns whether \emph{object} is a string.

\subsubsection{(number? \emph{object})}

Returns whether \emph{object} is a number.

\subsubsection{(integer? \emph{object})}

Returns whether \emph{object} is an integer.

\subsubsection{(float? \emph{object})}

Returns whether \emph{object} is a floating point number.

\subsubsection{(function? \emph{object})}

Returns whether \emph{object} is a function.

\subsubsection{(macro? \emph{object})}

Returns whether \emph{object} is a macro.

\subsubsection{(frame? \emph{object})}

Returns whether \emph{object} is a frame.

\subsubsection{(bytearray? \emph{object})}

Returns whether \emph{object} is a bytearray.

\subsubsection{(port? \emph{object})}

Returns whether \emph{object} is a port.

\subsubsection{(channel? \emph{object})}

Returns whether \emph{object} is a channel.

\subsection{Numerical Operations}

\subsubsection{(+ \emph{number}\ldots{})}

\subsubsection{(* \emph{number} \ldots{})}

These procedures return the sum or product of their arguments.

\begin{verbatim}
(+ 3 4)                 ⇒  7
(+ 3)                   ⇒  3
(+)                     ⇒  0
(* 4)                   ⇒  4
(*)                     ⇒  1
\end{verbatim}

\subsubsection{(- \emph{number}\ldots{})}

\subsubsection{(/ \emph{number}\ldots{})}

With two or more arguments, these procedures return the difference or quotient of their
arguments, associating to the left. With one argument, however, they return the additive or
multiplicative inverse of their argument.

\begin{verbatim}
(- 3 4)                 ⇒  -1
(- 3 4 5)               ⇒  -6
(- 3)                   ⇒  -3
(/ 3 4 5)               ⇒  0.15
(/ 4)                   ⇒  0.25
\end{verbatim}

Note that \verb|/| always preforms floating point division. If the quotient is a whole
number it will be returned as an integer.

\begin{verbatim}
(/ 12 5)                ⇒  2.4
(/ 12 2.4)              ⇒  5
\end{verbatim}

\subsubsection{(succ \emph{integer})}

\subsubsection{(1+ \emph{integer})}

Equivalent to \verb|(+ integer 1)|.

\subsubsection{(pred \emph{integer})}

\subsubsection{(-1+ \emph{integer})}

Equivalent to \verb|(- integer 1)|.

\subsubsection{(quotient \emph{n1} \_n2)}

\subsubsection{(remiander \emph{n1} \emph{n2})}

\subsubsection{(modulo \emph{n1} \emph{n2})}

These procedures implement number-theoretic (integer) division: for positive integers
\emph{n1} and \emph{n2}, if \emph{n3} and \emph{n4} are integers such that

\begin{verbatim}
n1 = (n2 * n3) + n4

0 <= n4 < n2
\end{verbatim}

then

\begin{verbatim}
(quotient n1 n2)        ⇒  n3
(remainder n1 n2)       ⇒  n4
(modulo n1 n2)          ⇒  n4
\end{verbatim}

for integers \emph{n1} and \emph{n2} with \emph{n2} not equal to 0,

\begin{verbatim}
(= n1
   (+ (* n2 (quotient n1 n2))
      (remainder n1 n2)))
                        ⇒  #t
\end{verbatim}

The value returned by \verb|quotient| always has the sign of the product of its arguments.
\verb|remainder| and \verb|modulo| differ on negative arguments -- the \verb|remainder|
always has the sign of the dividend, the \verb|modulo| always has the sign of the divisor:

\begin{verbatim}
(modulo 13 4)           ⇒  1
(remainder 13 4)        ⇒  1

(modulo -13 4)          ⇒  3
(remainder -13 4)       ⇒  -1

(modulo 13 -4)          ⇒  -3
(remainder 13 -4)       ⇒  1

(modulo -13 -4)         ⇒  -1
(remainder -13 -4)      ⇒  -1
\end{verbatim}

The \verb|%| function is an alias for \verb|remainder|.

\subsubsection{(floor \emph{number})}

Returns the greatest integer value less than or equal to \emph{number}. \emph{number} can
be an integer or float. Return value is a float.

\begin{verbatim}
(floor 3.4)             ⇒ 3.0
(floor -3.4)            ⇒ -4.0
(floor 3)               ⇒ 3.0
\end{verbatim}

\subsubsection{(ceiling \emph{number})}

Returns the largest integer value greater than or equal to \emph{number}. \emph{number}
can be an integer or float. Return value is a float.

\begin{verbatim}
(ceiling 3.4)           ⇒ 4.0
(ceiling -3.4)          ⇒ -3.0
(ceiling 3)             ⇒ 3.0
\end{verbatim}

\subsubsection{(integer \emph{number})}

Returns the integer value of \emph{number}. If it is an integer, it is simply returned.
However, if it is a float the integer part is returned.

\begin{verbatim}
(integer 5)             ⇒ 5
(integer 5.2)           ⇒ 5
(integer -5.8)          ⇒ -5
\end{verbatim}

\subsubsection{(float \emph{number})}

Returns the float value of \emph{number}. If it is a float, it is simply returned.
However, if it is an integer the corresponding float is returned.

\begin{verbatim}
(float 5)               ⇒ 5.0
\end{verbatim}

Note that converting a float to a string for printing using the format \texttt{\%g} to use the
minimum number of characters so \texttt{5.0} will actually print as \texttt{5}.

\subsubsection{(number-\textgreater{}string \emph{number} [\emph{base}])}

Converts \emph{number} (first converted to an integer) to a string, in the given \emph{base}.
Allowed bases are 2, 8, 10, and 16. If the base is omitted, 10 is used. No base prefixes (e.g.
\texttt{0x} for base 16) are added.

\begin{verbatim}
(number->string 42)    ⇒ "42"
(number->string 42 2)  ⇒ "101010"
(number->string 42 8)  ⇒ "52"
(number->string 42 10) ⇒ "42"
(number->string 42 16) ⇒ "2a"
(number->string 42 15) ⇒ ERROR number->string: unsupported base 15
\end{verbatim}

\subsubsection{(string-\textgreater{}number \emph{numeric-string} [\emph{base}])}

Converts \emph{numeric-string} to an integer, in the given base. Allowed bases are 2,
8, 10, and 16. If the base is omitted, 10 is used. No base prefixes (e.g. \verb|0x|
for base 16) are allowed. Specifying an unsupported base will result in \verb|0|.

\begin{verbatim}
(string->number "42")       ⇒ 42
(string->number "101010" 2) ⇒ 42
(string->number "52" 8)     ⇒ 42
(string->number "42" 10)    ⇒ 42
(string->number "2a" 16)    ⇒ 42
(string->number "42" 15)    ⇒ ERROR number->string: unsupported base 15
\end{verbatim}

\subsection{Comparisons}\label{sec:comparisons}

All comparison operations work with floating point numbers as well.

\subsubsection{(== \emph{number1} \emph{number2})}

\subsubsection{(= \emph{number1} \emph{number2})}

\subsubsection{(!= \emph{number1} \emph{number2})}

\subsubsection{(/= \emph{number1} \emph{number2})}

\subsubsection{(\textless{} \emph{number1} \emph{number2} \ldots{})}

\subsubsection{(\textgreater{} \emph{number1} \emph{number2} \ldots{})}

\subsubsection{(\textless{}= \emph{number1} \emph{number2} \ldots{})}

\subsubsection{(\textgreater{}= \emph{number1} \emph{number2} \ldots{})}

These procedures return \verb|#t| if their arguments are (respectively): equal (two
alternatives), not equal (two alternatives), monotonically increasing, monotonically
decreasing, monotonically nondecreasing, or monotonically nonincreasing. They return
\verb|#f| otherwise. Note that \verb|<|, \verb|>|, \verb|<=|, and
\verb|>=| can take more than 2 arguments.

\subsubsection{(zero? \emph{number})}

\subsubsection{(positive? \emph{number})}

\subsubsection{(negative? \emph{number})}

\subsubsection{(odd? \emph{number})}

\subsubsection{(even? \emph{number})}

These numerical predicates test a number for a particular property, returning \verb|#t| or
\verb|#f|.

\subsubsection{(min \emph{number}\ldots{})}

\subsubsection{(min (\emph{number}\ldots{}))}

\subsubsection{(max \emph{number}\ldots{})}

\subsubsection{(max (\emph{number}\ldots{}))}

These procedures return the maximum or minimum of their arguments. Note that the arguments can
be a series of numbers or a list of numbers:

\begin{verbatim}
(min 3 7 1 2)     ⇒ 1
(min '(3 7 1 2))  ⇒ 1
\end{verbatim}

\subsubsection{(log \emph{number})}

This computes the natural logarithm of \emph{number} \textbf{(not the base ten logarithm)}. An
integer argument will be converted to a float. The result is always a float.

\section{Equivalence Predicates}\label{sec:equivalence-predicates}

A ``predicate'' is a procedure that always returns a boolean value (\verb|#t| or
\verb|#f|). An ``equivalence predicate'' is the computational analogue of a mathematical
equivalence relation (it is symmetric, reflexive, and transitive). Of the equivalence
predicates described in this section, \verb|eq?| is the finest or most discriminating, and
\verb|equal?| is the coarsest. \verb|eqv?| is slightly less discriminating than
\verb|eq?|.

\subsubsection{(eqv? \emph{obj1} \emph{obj2})}

The \verb|eqv?| procedure defines a useful equivalence relation on objects. Briefly, it
returns \verb|#t| if \emph{obj1} and \emph{obj2} should normally be regarded as the same
object.

The \verb|eqv?| procedure returns \verb|#t| if:

\begin{itemize}
\item \emph{obj1} and \emph{obj2} are both \verb|#t| or both \verb|#f|.
\item \emph{obj1} and \emph{obj2} are both interned symbols and

\begin{verbatim}
(string=? (symbol->string obj1)
          (symbol->string obj2))
      ⇒ #t
\end{verbatim}
\item \emph{obj1} and \emph{obj2} are both numbers, are numerically equal according to the
  \verb|=| procedure.
\item both \emph{obj1} and \emph{obj2} are the empty list.
\item \emph{obj1} and \emph{obj2} are procedures whose location tags are equal.
\item \emph{obj1} and \emph{obj2} are pairs, vectors, strings, byte arrays, records, cells, or
  weak pairs that denote the same locations in the store.
\end{itemize}

The \verb|eqv?| procedure returns \verb|#f| if:

\begin{itemize}
\item \emph{obj1} and \emph{obj2} are of different types.
\item one of \emph{obj1} and \emph{obj2} is \verb|#t| but the other is \verb|#f|.
\item \emph{obj1} and \emph{obj2} are symbols but

\begin{verbatim}
(string=? (symbol->string obj1)
          (symbol->string obj2))
     ⇒ #f
\end{verbatim}
\item \emph{obj1} and \emph{obj2} are numbers for which the \verb|=| procedure returns
  \verb|#f|.
\item one of \emph{obj1} and \emph{obj2} is the empty list but the other is not.
\item \emph{obj1} and \emph{obj2} are procedures which have distinct underlying
  representations.
\item \emph{obj1} and \emph{obj2} are pairs, vectors, strings, byte arrays, or frames that
  denote distinct locations.
\end{itemize}

Some examples:

\begin{verbatim}
(eqv? 'a 'a)                 ⇒  #t
(eqv? 'a 'b)                 ⇒  #f
(eqv? 2 2)                   ⇒  #t
(eqv? '() '())               ⇒  #t
(eqv? 100000000 100000000)   ⇒  #t
(eqv? (cons 1 2) (cons 1 2)) ⇒  #f
(eqv? (lambda () 1)
      (lambda () 2))         ⇒  #f
(eqv? #f 'nil)               ⇒  #f
(let ((p (lambda (x) x)))
  (eqv? p p))                ⇒  #t
\end{verbatim}

The following examples illustrate how GoLisp behaves in cases where MIT Scheme's rules do not
fully specify the behavior of `eqv?'.

\begin{verbatim}
(eqv? "" "")                 ⇒  #f
(eqv? '#() '#())             ⇒  #f
(eqv? (lambda (x) x)
      (lambda (x) x))        ⇒  #f
(eqv? (lambda (x) x)
      (lambda (y) y))        ⇒  #f
\end{verbatim}

Objects of distinct types must never be regarded as the same object.

Since it is an error to modify constant objects (those returned by literal expressions), the
implementation may share structure between constants where appropriate. Thus the value of
\verb|eqv?| on constants is sometimes unspecified, however, the following cases hold.

\begin{verbatim}
(let ((x '(a)))
  (eqv? x x))                ⇒  #t
(eqv? '(a) '(a))             ⇒  #f
(eqv? "a" "a")               ⇒  #f
(eqv? '(b) (cdr '(a b)))     ⇒  #f
\end{verbatim}

\subsubsection{(eq? \emph{obj1} \emph{obj2})}

\verb|eq?| is similar to \verb|eqv?| except that in some cases it is capable of discerning
distinctions finer than those detectable by \verb|eqv?|.

\verb|eq?| and \verb|eqv?| are guaranteed to have the same behavior on symbols, booleans,
the empty list, pairs, records, and non-empty strings and vectors. \verb|eq?|'s behavior on
numbers and characters is implementation-dependent, but it will always return either true or
false, and will return true only when \verb|eqv?| would also return true. \verb|eq?| may
also behave differently from \verb|eqv?| on empty vectors and empty strings.

\begin{verbatim}
(eq? 'a 'a)                  ⇒  #t
(eq? '(a) '(a))              ⇒  #f
(eq? (list 'a) (list 'a))    ⇒  #f
(eq? "a" "a")                ⇒  #t
(eq? "" "")                  ⇒  #t
(eq? '() '())                ⇒  #t
(eq? 2 2)                    ⇒  #t
(eq? car car)                ⇒  #t
(let ((n (+ 2 3)))
  (eq? n n))                 ⇒  #t
(let ((x '(a)))
  (eq? x x))                 ⇒  #t
(let ((x '#()))
  (eq? x x))                 ⇒  #t
(let ((p (lambda (x) x)))
  (eq? p p))                 ⇒  #t
\end{verbatim}

\subsubsection{(equal? \emph{obj1} \emph{obj2})}

\verb|equal?| recursively compares the contents of pairs, vectors, and strings,
applying \verb|eqv?| on other objects such as numbers, symbols, and booleans. A
rule of thumb is that objects are generally \verb|equal?| if they print the same.
\verb|equal?| may fail to terminate if its arguments are circular data structures.

\begin{verbatim}
(equal? 'a 'a)               ⇒  #t
(equal? '(a) '(a))           ⇒  #t
(equal? '#(a) '#(a))         ⇒  #t
(equal? '(a (b) c)
        '(a (b) c))          ⇒  #t
(equal? "abc" "abc")         ⇒  #t
(equal? 2 2)                 ⇒  #t
(equal? (make-vector 5 'a)
        (make-vector 5 'a))  ⇒  #t
(equal? (lambda (x) x)
        (lambda (y) y))      ⇒  #f
\end{verbatim}

\subsubsection{(neqv? \emph{object} \emph{object})}

\subsubsection{(neq? \emph{object} \emph{object})}

\subsubsection{(nequal? \emph{object} \emph{object})}

Each is the logical negation of the corresponding equivalence predicate.

\section{Logical}\label{sec:logical}

\subsubsection{(boolean=? \emph{object1} \emph{object2})}

Returns whether \emph{object1} and \emph{object2} are both truthy or are both falsy.

\subsubsection{(boolean/and \emph{object}\ldots{})}

Each \emph{object} is evaluated; if all of the evaluated \emph{objects} are truthy, returns
the value of the final one

\subsubsection{(boolean/or \emph{object}\ldots{})}

Each \emph{object} is evaluated; if any of the evaluated \emph{objects} are truthy, returns
the first one that is

\subsubsection{(not \emph{object})}

\subsubsection{(false? \emph{object})}

Returns the boolean negation of the argument.

\begin{verbatim}
(not #t)    ⇒ #f
(false? #f) ⇒ #t
\end{verbatim}

\section{Binary}\label{sec:binary}

\subsubsection{(binary-and \emph{int-1} \emph{int-2})}

Performs a bitwise AND of \emph{int-1} and \emph{int-2}, returning the result.

\begin{verbatim}
(number->string (binary-and 0xaa 0x0f) 16) ⇒ "a"
(number->string (binary-and 0xaa 0xf0) 16) ⇒ "a0"
\end{verbatim}

\subsubsection{(binary-or \emph{int-1} \emph{int-2})}

Performs a bitwise OR of \emph{int-1} and \emph{int-2}, returning the result.

\begin{verbatim}
(number->string (binary-or 0xaa 0x0f) 16) ⇒ "af"
(number->string (binary-or 0xaa 0xf0) 16) ⇒ "fa"
\end{verbatim}

\subsubsection{(binary-not \emph{int})}

Performs a bitwise NOT of \emph{int}, returning the result.

\begin{verbatim}
(number->string (binary-not 0x000000aa) 16) ⇒ "ffffff55"
\end{verbatim}

\subsubsection{(left-shift \emph{int} \emph{count})}

Shifts \emph{int} left by \emph{count} bits, returning the result.

\begin{verbatim}
(number->string (left-shift (string->number "10101010" 2) 1) 2) ⇒ "101010100"
(number->string (left-shift (string->number "10101010" 2) 3) 2) ⇒ "10101010000"
\end{verbatim}

\subsubsection{(right-shift \emph{int} \emph{count})}

Shifts \emph{int} right by \emph{count} bits, returning the result.

\begin{verbatim}
(number->string (right-shift (string->number "10000" 2) 1) 2) ⇒ "1000"
(number->string (right-shift (string->number "10000" 2) 4) 2) ⇒ "1"
\end{verbatim}

\section{Characters}\label{sec:characters}

GoLisp has minimal support for characters: just that required for basic string manipulation.
this may be expanded in the future.

\subsection{External Representation of Characters}\label{sec:external-representation-of-characters}

Characters are written using the notation \verb|\#CHARACTER| or \verb|#\CHARACTER-NAME|. For
example:

\begin{verbatim}
#\a                     ; lowercase letter
#\A                     ; uppercase letter
#\(                     ; left parenthesis
#\space                 ; the space character
#\newline               ; the newline character
\end{verbatim}

Case is significant in \verb|#\CHARACTER|, but not in
\verb|#\CHARACTER-NAME|. If CHARACTER in
\verb|#\CHARACTER| is a letter, \emph{CHARACTER} must be followed by a
delimiter character such as a space or closing parenthesis, bracket, or brace. Characters
written in the \verb|\#| notation are self-evaluating; you don't need to quote them.

The following \emph{CHARACTER-NAME}s are supported, shown here with their ASCII equivalents:

\begin{verbatim}
Character Name          ASCII Name
 --------------          ----------

 altmode                 ESC
 backspace               BS
 esc                     ESC
 linefeed                LF
 page                    FF
 return                  CR
 rubout                  DEL
 space
 tab                     HT
\end{verbatim}

\section{Strings}\label{sec:strings}

A ``string'' is a immutable sequence of characters.

A string is written as a sequence of characters enclosed within double quotes \verb|" "|. To
include a double quote inside a string, precede the double quote with a backslash `' (escape
it), as in

\begin{verbatim}
"The word \"recursion\" has many meanings."
\end{verbatim}

The printed representation of this string is

\begin{verbatim}
The word "recursion" has many meanings.
\end{verbatim}

To include a backslash inside a string, precede it with another
backslash; for example,

\begin{verbatim}
"Use #\\Control-q to quit."
\end{verbatim}

The printed representation of this string is

\begin{verbatim}
Use #\Control-q to quit.
\end{verbatim}

The effect of a backslash that doesn't precede a double quote or backslash is unspecified in
standard Scheme, but GoLisp specifies the effect for three other characters:
\verb|\t|, \verb|\n|, and \verb|\f|. These
escape sequences are respectively translated into tab, newline, and page characters. whose
ISO-8859-1 code is those digits.

If a string literal is continued from one line to another, the string will contain the newline
character at the line break. Standard Scheme does not
specify what appears in a string literal at a line break.

The ``length'' of a string is the number of characters that it contains. This number is a
non-negative integer that is established when the string is created. Each character in a
string has an ``index'', which is a number that indicates the character's position in the
string. The index of the first (leftmost) character in a string is 0, and the index of the
last character is one less than the length of the string. The ``valid indexes'' of a string
are the non-negative integers less than the length of the string.

\begin{verbatim}0 <= start <= end <= (string-length string)
\end{verbatim}

\subsection{Construction of Strings}\label{sec:construction-of-strings}

\subsubsection{(make-string \emph{k} [\emph{char}])}

Returns a newly allocated string of length \emph{k}. If you specify \emph{char}, all elements
of the string are initialized to \emph{char}, otherwise the contents of the string are
unspecified.

\begin{verbatim}
(make-string 10 #\x)              ⇒  "xxxxxxxxxx"
\end{verbatim}

\subsubsection{(string \emph{char}\ldots{})}

Returns a newly allocated string consisting of the specified characters. The arguments should
be single character strings.

\begin{verbatim}
(string "a")                         ⇒  "a"
(string "a" "b" #\c)                 ⇒  "abc"
(string #\a #\space #\b #\space #\c) ⇒  "a b c"
(string)                             ⇒  undefined
\end{verbatim}

\subsubsection{(list-\textgreater{}string \emph{char-list})}

\emph{char-list} must be a list of strings. \verb|list->string| returns a newly
allocated string formed by concatenating the elements of \emph{char-list}. This is equivalent
to \verb|(apply string char-list)|. The inverse of this operation is
\verb|string->list|.

\begin{verbatim}
(list->string '(#\a #\b))       ⇒  "ab"
(string->list "Hello")          ⇒  (#\H #\e #\l #\l #\o)
\end{verbatim}

\subsubsection{(string-copy \emph{string})}

Returns a newly allocated copy of \emph{string}.

\subsection{Selecting String Components}\label{sec:selecting-string-components}

\subsubsection{(string? \emph{object})}

Returns \verb|#t| if \emph{object} is a string; otherwise returns \verb|#f|.

\begin{verbatim}
(string? "Hi")                  ⇒  #t
(string? 'Hi)                   ⇒  #f
\end{verbatim}

\subsubsection{(string-length \emph{string})}

Returns the length of \emph{string} as an non-negative integer.

\begin{verbatim}
(string-length "")              ⇒  0
(string-length "The length")    ⇒  10
\end{verbatim}

\subsubsection{(string-null? \emph{string})}

Returns \verb|#t| if \emph{string} has zero length; otherwise returns \verb|#f|.

\begin{verbatim}
(string-null? "")               ⇒  #t
(string-null? "Hi")             ⇒  #f
\end{verbatim}

\subsubsection{(string-ref \emph{string} \emph{k})}

Returns character \emph{k} of \emph{string}. \emph{k} must be a valid index of \emph{string}.

\begin{verbatim}
(string-ref "Hello" 1)          ⇒  #\e
(string-ref "Hello" 5)          ERROR 5 not in correct range
\end{verbatim}

\subsubsection{(string-set! \emph{string} \emph{k} \emph{char})}

Stores \emph{char} (a single character string) in element \emph{k} of \emph{string} and
returns an unspecified value. \emph{k} must be a valid index of \emph{string}.

\begin{verbatim}
(define s "Dog")              ⇒  "Dog"
(string-set! s 0 #\L)         ⇒  "Log"
s                             ⇒  "Log"
(string-set! s 3 #\t)         ERROR 3 not in correct range
\end{verbatim}

\subsection{Comparison of Strings}\label{sec:comparison-of-strings}

\subsubsection{(string=? \emph{string1} \emph{string2})}

\subsubsection{(substring=? \emph{string1} \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string-ci=? \emph{string1} \emph{string2})}

\subsubsection{(substring-ci=?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

Returns \verb|#t| if the two strings (substrings) are the same length and contain the same
characters in the same (relative) positions; otherwise returns \verb|#f|.
\verb|string-ci=?| and \verb|substring-ci=?| don't distinguish uppercase and lowercase
letters, but \verb|string=?| and \verb|substring=?| do.

\begin{verbatim}
(string=? "PIE" "PIE")                  ⇒  #t
(string=? "PIE" "pie")                  ⇒  #f
(string-ci=? "PIE" "pie")               ⇒  #t
(substring=? "Alamo" 1 3 "cola" 2 4)    ⇒  #t ; compares "la"
\end{verbatim}

\subsubsection{(string\textless{}? \emph{string1} \emph{string2})}

\subsubsection{(substring\textless{}?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string-ci\textless{}? \emph{string1} \emph{string2})}

\subsubsection{(substring-ci\textless{}?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string\textgreater{}? \emph{string1} \emph{string2})}

\subsubsection{(substring\textgreater{}?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string-ci\textgreater{}? \emph{string1} \emph{string2})}

\subsubsection{(substring-ci\textgreater{}?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string\textless{}=? \emph{string1} \emph{string2})}

\subsubsection{(substring\textless{}=?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string-ci\textless{}=? \emph{string1} \emph{string2})}

\subsubsection{(substring-ci\textless{}=?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string\textgreater{}=? \emph{string1} \emph{string2})}

\subsubsection{(substring\textgreater{}=?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

\subsubsection{(string-ci\textgreater{}=? \emph{string1} \emph{string2})}

\subsubsection{(substring-ci\textgreater{}=?\_ string1\_ \emph{start1} \emph{end1} \emph{string2} \emph{start2} \emph{end2})}

These procedures compare strings (substrings) according to the order of the characters they
contain. The arguments are compared using a lexicographic (or dictionary) order. If two
strings differ in length but are the same up to the length of the shorter string, the shorter
string is considered to be less than the longer string.

\begin{verbatim}
(string<? "cat" "dog")          ⇒  #t
(string<? "cat" "DOG")          ⇒  #f
(string-ci<? "cat" "DOG")       ⇒  #t
(string>? "catkin" "cat")       ⇒  #t ; shorter is lesser
\end{verbatim}

\subsubsection{(string-compare \emph{string1} \emph{string2} \emph{if-eq} \emph{if-lt} \emph{if-gt})}

\subsubsection{(string-compare-ci \emph{string1} \emph{string2} \emph{if-eq} \emph{if-lt} \emph{if-gt})}

\emph{if-eq}, \emph{if-lt}, and \emph{if-gt} are procedures of no arguments (thunks). The two
strings are compared; if they are equal, \emph{if-eq} is applied, if \emph{string1} is less
than \emph{string2}, \emph{if-lt} is applied, else if \emph{string1} is greater than
\emph{string2}, \emph{if-gt} is applied. The value of the procedure is the value of the thunk
that is applied.

\verb|string-compare| distinguishes uppercase and lowercase letters;
\verb|string-compare-ci| does not.

\begin{verbatim}
(define (cheer) (display "Hooray!"))
(define (boo)   (display "Boo-hiss!"))
(string-compare "a" "b"  cheer  (lambda() 'ignore)  boo)
        -|  Hooray!
        ⇒  unspecified
\end{verbatim}

In GoLisp, only \verb|string-compare| and \verb|string-compare-ci| are available by default.
If you want the other comparison functions you need to \verb|(load "lisp/strings.scm")|.

\subsection{Alphabetic Case in Strings}\label{sec:alphabetic-case-in-strings}

\subsubsection{(string-capitalized? \emph{string})}

\subsubsection{(substring-capitalized? \emph{string} \emph{start} \emph{end})}

These procedures return \verb|#t| if the first word in the string (substring) is
capitalized, and any subsequent words are either lower case or capitalized. Otherwise, they
return \verb|#f|. A word is defined as a non-null contiguous sequence of alphabetic
characters, delimited by non-alphabetic characters or the limits of the string (substring). A
word is capitalized if its first letter is upper case and all its remaining letters are lower
case.

\begin{verbatim}
(map string-capitalized? '(""    "A"    "art"  "Art"  "ART"))
                       ⇒ (#f    #t     #f     #t     #f)
\end{verbatim}

\subsubsection{(string-upper-case? \emph{string})}

\subsubsection{(substring-upper-case? \emph{string} \emph{start} \emph{end})}

\subsubsection{(string-lower-case? \emph{string})}

\subsubsection{(substring-lower-case? \emph{string} \emph{start} \emph{end})}

These procedures return \verb|#t| if all the letters in the string (substring) are of the
correct case, otherwise they return \verb|#f|. The string (substring) must contain at least
one letter or the procedures return \verb|#f|.

\begin{verbatim}
(map string-upper-case?  '(""    "A"    "art"  "Art"  "ART"))
                       ⇒ (#f    #t     #f     #f     #t)
\end{verbatim}

\subsubsection{(string-capitalize \emph{string})}

\subsubsection{(string-capitalize! \emph{string})}

\subsubsection{(substring-capitalize! \emph{string} \emph{start} \emph{end})}

\verb|string-capitalize| returns a newly allocated copy of \emph{string} in which the first
alphabetic character is uppercase and the remaining alphabetic characters are lowercase. For
example, \verb|"abcDEF"| becomes \verb|"Abcdef"|. \verb|string-capitalize!| is the
destructive version of \verb|string-capitalize|: it alters \emph{string} and returns an
unspecified value. \verb|substring-capitalize!| destructively capitalizes the specified part
of \emph{string}.

\subsubsection{(string-downcase \emph{string})}

\subsubsection{(string-downcase! \emph{string})}

\subsubsection{(substring-downcase! \emph{string} \emph{start} \emph{end})}

\verb|string-downcase| returns a newly allocated copy of \emph{string} in which all
uppercase letters are changed to lowercase. \verb|string-downcase!| is the destructive
version of \verb|string-downcase|: it alters \emph{string} and returns an unspecified value.
\verb|substring-downcase!| destructively changes the case of the specified part of
\emph{string}.

\begin{verbatim}
(define str "ABCDEFG")          ⇒  unspecified
(substring-downcase! str 3 5)   ⇒  "ABCdeFG"
str                             ⇒  "ABCdeFG"
\end{verbatim}

\subsubsection{(string-upcase \emph{string})}

\subsubsection{(string-upcase! \emph{string})}

\subsubsection{(substring-upcase! \emph{string} \emph{start} \emph{end})}

\verb|string-upcase| returns a newly allocated copy of \emph{string} in which all lowercase
letters are changed to uppercase. \verb|string-upcase!| is the destructive version of
\verb|string-upcase|: it alters \emph{string} and returns an unspecified value.
\verb|substring-upcase!| destructively changes the case of the specified part of
\emph{string}.

\subsection{Cutting and Pasting Strings}\label{sec:cutting-and-pasting-strings}

\subsubsection{(string-split \emph{string} \emph{separator})}

Splits \emph{string} into a list of substrings that are separated by \emph{separator}.

\begin{verbatim}
(string-split "1-2-3" "-")) ⇒ ("1" "2" "3")
\end{verbatim}

\subsubsection{(string-join \emph{strings} \emph{separator})}

Joins the list of \emph{strings} into a single string by interposing \emph{separator}.

\begin{verbatim}
(string-join '("1" "2" "3") "-") ⇒ "1-2-3"
\end{verbatim}

\subsubsection{(string-append \emph{string}\ldots{})}

Returns a newly allocated string made from the concatenation of the given strings.

\begin{verbatim}
(string-append)                 ⇒  undefined
(string-append "*" "ace" "*")   ⇒  "*ace*"
(string-append "" "" "")        ⇒  ""
(eqv? str (string-append str))  ⇒  #f ; newly allocated
\end{verbatim}

\subsubsection{(substring \emph{string} \emph{start} \emph{end})}

Returns a newly allocated string formed from the characters of \emph{string} beginning with
index \emph{start} (inclusive) and ending with \emph{end} (exclusive).

\begin{verbatim}
(substring "" 0 0)              ⇒ ""
(substring "arduous" 2 5)       ⇒ "duo"
(substring "arduous" 2 8)       ERROR 8 not in correct range

(define (string-copy s)
  (substring s 0 (string-length s)))
\end{verbatim}

\subsubsection{(string-head \emph{string} \emph{end})}

Returns a newly allocated copy of the initial substring of \emph{string}, up to but excluding
\emph{end}. It could have been defined by:

\begin{verbatim}
(define (string-head string end)
  (substring string 0 end))

(string-head "uncommon" 2)      ⇒ "un"
\end{verbatim}

\subsubsection{(string-tail \emph{string} \emph{start})}

Returns a newly allocated copy of the final substring of \emph{string}, starting at index
\emph{start} and going to the end of \emph{string}. It could have been defined by:

\begin{verbatim}
(define (string-tail string start)
  (substring string start (string-length string)))

(string-tail "uncommon" 2)      ⇒  "common"
\end{verbatim}

\subsubsection{(string-pad-left \emph{string} \emph{k} [\emph{char}])}

\subsubsection{(string-pad-right \emph{string} \emph{k} [\emph{char}])}

These procedures return a newly allocated string created by padding \emph{string} out to
length \emph{k}, using \emph{char}. If \emph{char} is not given, it defaults to
\verb|#\space|. If \emph{k} is less than the length of \emph{string}, the
resulting string is a truncated form of \emph{string}. \verb|string-pad-left| adds padding
characters or truncates from the beginning of the string (lowest indices), while
\verb|string-pad-right| does so at the end of the string (highest indices).

\begin{verbatim}
(string-pad-left "hello" 4)             ⇒  "ello"
(string-pad-left "hello" 8)             ⇒  "   hello"
(string-pad-left "hello" 8 #\*)         ⇒  "***hello"
(string-pad-right "hello" 4)            ⇒  "hell"
(string-pad-right "hello" 8)            ⇒  "hello   "
(string-pad-right "hello" 8 #\*)        ⇒  "hello***"
\end{verbatim}

\subsubsection{(string-trim \emph{string} [\emph{char-set}])}

\subsubsection{(string-trim-left \emph{string} [\emph{char-set}])}

\subsubsection{(string-trim-right \emph{string} [\emph{char-set}])}

Returns a newly allocated string created by removing all characters that are not in
\emph{char-set} from: \verb|string-trim| both ends of \emph{string};
\verb|string-trim-left| the beginning of \emph{string}; or \verb|string-trim-right| the
end of \emph{string}. \emph{char-set} defaults to \verb|char-set:not-whitespace|.

\begin{verbatim}
(string-trim "  in the end  ")          ⇒  "in the end"
(string-trim "              ")          ⇒  ""
(string-trim "100th" char-set:numeric)  ⇒  "100"
(string-trim-left "-.-+-=-" (char-set #\+))
                                        ⇒  "+-=-"
(string-trim "but (+ x y) is" (char-set #\( #\)))
                                        ⇒  "(+ x y)"
\end{verbatim}

\subsection{Regexp Support}\label{sec:regexp-support}

There is some preliminary support for regular expressions.

\subsubsection{(re-string-match-go \emph{regexp} \emph{string})}

This matches regexp against the respective string, returning \#f for no match, or a list of
strings (see below) if the match succeeds.

When a successful match occurs, the above procedure returns a list of strings. Each string
corresponds to an instance of the regular-expression grouping operator ‘(’. Additionally, the
first string corresponds to the entire substring matching the regular expression.

Note that this is different from the Scheme matching procedure.

\section{Lists}\label{sec:lists}

A ``pair'' (sometimes called a ``dotted pair'') is a data structure with two fields called the
``car'' and ``cdr'' fields (for historical reasons). Pairs are created by the procedure
\verb|cons|. The car and cdr fields are accessed by the procedures \verb|car| and
\verb|cdr|. The car and cdr fields are assigned by the procedures \verb|set-car!| and
\verb|set-cdr!|.

Pairs are used primarily to represent ``lists''. A list can be defined recursively as either
the empty list or a pair whose cdr is a list. More precisely, the set of lists is defined as
the smallest set X such that

\begin{itemize}
\item The empty list is in X.
\item If LIST is in X, then any pair whose cdr field contains LIST is also in X.
\end{itemize}

The objects in the car fields of successive pairs of a list are the ``elements'' of the list.
For example, a two-element list is a pair whose car is the first element and whose cdr is a
pair whose car is the second element and whose cdr is the empty list. The ``length'' of a list
is the number of elements, which is the same as the number of pairs. The ``empty list'' is a
special object of its own type (it is not a pair); it has no elements and its length is zero.

The most general notation (external representation) for GoLisp pairs is the ``dotted''
notation \verb|(C1 . C2)| where C1 is the value of the car field and C2 is the value of the
cdr field. For example, \verb|(4 . 5)| is a pair whose car is \verb|4| and whose cdr is
\verb|5|. Note that \verb|(4 . 5)| is the external representation of a pair, not an
expression that evaluates to a pair.

A more streamlined notation can be used for lists: the elements of the list are simply
enclosed in parentheses and separated by spaces. The empty list is written \verb|()|. For
example, the following are equivalent notations for a list of symbols:

\begin{verbatim}
(a b c d e)
(a . (b . (c . (d . (e . ())))))
\end{verbatim}

Whether a given pair is a list depends upon what is stored in the cdr field. When the
\verb|set-cdr!| procedure is used, an object can be a list one moment and not the next:

\begin{verbatim}
(define x (list 'a 'b 'c))
(define y x)
y                                       ⇒ (a b c)
(list? y)                               ⇒ #t
(set-cdr! x 4)                          ⇒ (a . 4)
x                                       ⇒ (a . 4)
(eqv? x y)                              ⇒ #t
y                                       ⇒ (a . 4)
(list? y)                               ⇒ #f
(set-cdr! x x)                          ⇒ <Unprintable looping pair structure>
(list? y)                               ⇒ #f
\end{verbatim}

A chain of pairs that doesn't end in the empty list is called an ``improper list''. Note that
an improper list is not a list. The list and dotted notations can be combined to represent
improper lists, as the following equivalent notations show:

\begin{verbatim}
(a b c . d)
(a . (b . (c . d)))
\end{verbatim}

Within literal expressions and representations of objects read by the \verb|read| procedure,
the forms \verb|'DATUM|, \verb|`DATUM|, \verb|,DATUM|, and \verb|,@DATUM| denote two-element lists
whose first elements are the symbols \verb|quote|, \verb|quasiquote|, \verb|unquote|,
and \verb|unquote-splicing|, respectively. The second element in each case is DATUM. This
convention is supported so that arbitrary GoLisp programs may be represented as lists. Among
other things, this permits the use of the \verb|read| procedure to parse Scheme programs.

\subsection{Pairs}\label{sec:pairs}

This section describes the simple operations that are available for constructing and
manipulating arbitrary graphs constructed from pairs.

\subsubsection{(pair? \emph{object})}

Returns \verb|#t| if \emph{object} is a pair; otherwise returns \verb|#f|.

\begin{verbatim}
(pair? '(a . b))                        ⇒ #t
(pair? '(a b c))                        ⇒ #t
(pair? '())                             ⇒ #f
(pair? '#(a b))                         ⇒ #f
\end{verbatim}

\subsubsection{(cons \emph{obj1} \emph{obj2})}

Returns a newly allocated pair whose car is \emph{obj1} and whose cdr is \emph{obj2}. The pair
is guaranteed to be different (in the sense of \verb|eqv?|) from every previously existing
object.

\begin{verbatim}
(cons 'a '())                           ⇒ (a)
(cons '(a) '(b c d))                    ⇒ ((a) b c d)
(cons "a" '(b c))                       ⇒ ("a" b c)
(cons 'a 3)                             ⇒ (a . 3)
(cons '(a b) 'c)                        ⇒ ((a b) . c)
\end{verbatim}

\subsubsection{(car \emph{pair})}

Returns the contents of the car field of \emph{pair}. Note that taking the \verb|car| of the
empty list results in the empty list.

\begin{verbatim}
(car '(a b c))                          ⇒ a
(car '((a) b c d))                      ⇒ (a)
(car '(1 . 2))                          ⇒ 1
(car '())                               ⇒ ()
\end{verbatim}

\subsubsection{(cdr \emph{pair})}

Returns the contents of the cdr field of \emph{pair}. Note that taking the \verb|cdr| of the
empty list results in the empty list.

\begin{verbatim}
(cdr '((a) b c d))                      ⇒ (b c d)
(cdr '(1 . 2))                          ⇒ 2
(cdr '())                               ⇒ ()
\end{verbatim}

\subsubsection{(set-car! \emph{pair} \emph{object})}

Stores \emph{object} in the car field of \emph{pair}. The value returned by \verb|set-car!|
is unspecified.

\begin{verbatim}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)                        ⇒ unspecified
(set-car! (g) 3)                        ERROR Illegal datum
\end{verbatim}

\subsubsection{(set-cdr! \emph{pair} \emph{object})}

Stores \emph{object} in the cdr field of \emph{pair}. The value returned by \verb|set-cdr!|
is unspecified.

\subsubsection{(set-nth! \emph{n} \emph{list} \emph{new-value})}

Set the \verb|car| pointer of the nth cons cell of \emph{list}. Numbering starts at 1.

\begin{verbatim}
(define a '(1 2 3 4))
(set-nth! 3 a 0)
a ⇒ (1 2 0 4)
\end{verbatim}

\subsubsection{(caar \emph{pair})}

\subsubsection{(cadr \emph{pair})}

\subsubsection{(cdar \emph{pair})}

\subsubsection{(cddr \emph{pair})}

\subsubsection{(caaar \emph{pair})}

\subsubsection{(caadr \emph{pair})}

\subsubsection{(cadar \emph{pair})}

\subsubsection{(caddr \emph{pair})}

\subsubsection{(cdaar \emph{pair})}

\subsubsection{(cdadr \emph{pair})}

\subsubsection{(cddar \emph{pair})}

\subsubsection{(cdddr \emph{pair})}

\subsubsection{(caaaar \emph{pair})}

\subsubsection{(caaadr \emph{pair})}

\subsubsection{(caadar \emph{pair})}

\subsubsection{(caaddr \emph{pair})}

\subsubsection{(cadaar \emph{pair})}

\subsubsection{(cadadr \emph{pair})}

\subsubsection{(caddar \emph{pair})}

\subsubsection{(cadddr \emph{pair})}

\subsubsection{(cdaaar \emph{pair})}

\subsubsection{(cdaadr \emph{pair})}

\subsubsection{(cdadar \emph{pair})}

\subsubsection{(cdaddr \emph{pair})}

\subsubsection{(cddaar \emph{pair})}

\subsubsection{(cddadr \emph{pair})}

\subsubsection{(cdddar \emph{pair})}

\subsubsection{(cddddr \emph{pair})}

These procedures are compositions of \verb|car| and \verb|cdr|; for example, \verb|caddr| could
be defined by

\begin{verbatim}
(define caddr (lambda (x) (car (cdr (cdr x)))))
\end{verbatim}

\subsubsection{(general-car-cdr \emph{object} \emph{path})}

This procedure is a generalization of \verb|car| and \verb|cdr|. \emph{path} encodes a
particular sequence of \verb|car| and \verb|cdr| operations, which
\verb|general-car-cdr| executes on \emph{object}. \emph{path} is a non-negative integer that
encodes the operations in a bitwise fashion: a zero bit represents a \verb|cdr| operation,
and a one bit represents a \verb|car|. The bits are executed LSB to MSB, and the most
significant one bit, rather than being interpreted as an operation, signals the end of the
sequence.

For example, the following are equivalent:

\begin{verbatim}
(general-car-cdr OBJECT #b1011)
(cdr (car (car OBJECT)))
\end{verbatim}

Here is a partial table of path/operation equivalents:

\begin{verbatim}
#b10    cdr
#b11    car
#b100   cddr
#b101   cdar
#b110   cadr
#b111   caar
#b1000  cdddr
\end{verbatim}

\subsubsection{(copy \emph{object})}

This copies an arbitrary \emph{object}, recursively if it is made from pairs.

\subsection{Construction of Lists}\label{sec:construction-of-lists}

\subsubsection{(list \emph{object}\ldots{})}

Returns a list of its arguments.

\begin{verbatim}
(list 'a (+ 3 4) 'c)                    ⇒ (a 7 c)
(list)                                  ⇒ ()
\end{verbatim}

These expressions are equivalent:

\begin{verbatim}
(list OBJ1 OBJ2 ... OBJN)
(cons OBJ1 (cons OBJ2 ... (cons OBJN '()) ...))
\end{verbatim}

\subsubsection{(make-list k [element])}

This procedure returns a newly allocated list of length \emph{k}, whose elements are all
\emph{element}. If \emph{element} is not supplied, it defaults to the empty list.

\begin{verbatim}
(make-list 4 'c)                        ⇒ (c c c c)
\end{verbatim}

\subsubsection{(cons* object object \ldots{})}

\verb|cons*| is similar to \verb|list|, except that \verb|cons*| conses together the
last two arguments rather than consing the last argument with the empty list. If
the last argument is not a list the result is an improper list. If the last
argument is a list, the result is a list consisting of the initial arguments and
all of the items in the final argument. If there is only one argument, the
result is the argument.

\begin{verbatim}
(cons* 'a 'b 'c)                        ⇒ (a b . c)
(cons* 'a 'b '(c d))                    ⇒ (a b c d)
(cons* 'a)                              ⇒ a
\end{verbatim}

These expressions are equivalent:

\begin{verbatim}
(cons* OBJ1 OBJ2 ... OBJN-1 OBJN)
(cons OBJ1 (cons OBJ2 ... (cons OBJN-1 OBJN) ...))
\end{verbatim}

\subsubsection{(make-initialized-list k init-proc)}

Returns a \emph{K}-element list. Element I of the list, where 0 \textless{}= I \textless{}
\emph{k}, is produced by \verb|(init-proc I)|. No guarantee is made about the dynamic
order in which \emph{init-proc} is applied to these indices.

\begin{verbatim}
(make-initialized-list 4 (lambda (x) (* x x))) ⇒ (0 1 4 9)
\end{verbatim}

\subsubsection{(list-copy list)}

Returns a newly allocated copy of \emph{list}. This copies each of the pairs comprising
\emph{list}. This could have been defined by

\begin{verbatim}
(define (list-copy list)
  (if (null? list)
      '()
      (cons (car list)
            (list-copy (cdr list)))))
\end{verbatim}

\subsubsection{(iota count [start [step]])}

Returns a list containing the elements

\begin{verbatim}
(START START+STEP ... START+(COUNT-1)*STEP)
\end{verbatim}

\emph{count} must be a non-negative integer, while \emph{start} and \emph{step} can be any
numbers. The \emph{start} and \emph{step} parameters default to 0 and 1, respectively.

\begin{verbatim}
(iota 5)          ⇒  (0 1 2 3 4)
(iota 5 0 -0.1)   ⇒  (0 -0.1 -0.2 -0.3 -0.4)
\end{verbatim}

\subsubsection{(interval \emph{hi})}

\subsubsection{(interval \emph{lo} \emph{hi})}

\subsubsection{(interval \emph{lo} \emph{hi} \emph{step})}

The first form creates a list of numbers from 1 to \verb|hi|, inclusive. \verb|hi|
\textbf{must} be a positive integer.

\begin{verbatim}
(interval 5) ⇒ (1 2 3 4 5)
(interval 2) ⇒ (1 2)
\end{verbatim}

The second form creates a list of numbers from \verb|lo| to \verb|hi|, inclusive, stepping
by 1. If \verb|lo| \textgreater{} \verb|hi|, a step of -1 is used.

\begin{verbatim}
(interval 1 5) ⇒ (1 2 3 4 5)
(interval -2 2) ⇒ (-2 -1 0 1 2)
(interval 5 1) ⇒ (5 4 3 2 1)
(interval 2 -2) ⇒ (2 1 0 -1 -2)
\end{verbatim}

The third form creates a list of numbers from \verb|lo| to \verb|hi|, inclusive (if
possible), \verb|step| apart. \verb|step| \textbf{must} be non-zero and it's sign must
match the ordering of \verb|lo| and \verb|hi|. I.e. if \verb|lo| \textgreater{}
\verb|hi|, \verb|step| must be negative, otherwise positive.

\begin{verbatim}
(interval 1 5 2) ⇒ (1 3 5)
(interval 1 8 2) ⇒ (1 3 5 7)
(interval -2 2 2) ⇒ (-2 0 2)
(interval 2 -2 -2) ⇒ (2 0 -2)
(interval 5 1 -2) ⇒ (5 3 1)
(interval -1 -8 -2) ⇒ (-1 -3 -5 -7)
\end{verbatim}

\subsubsection{(vector-\textgreater{}list \emph{vector})}

\subsubsection{(subvector-\textgreater{}list \emph{vector} \emph{start} \emph{end})}

\verb|vector->list| returns a newly allocated list of the elements of \emph{vector}.
\verb|subvector->list| returns a newly allocated list of the elements of the given subvector.
The inverse of \verb|vector->list| is \verb|list->vector|.

\begin{verbatim}
(vector->list '#(dah dah didah))        ⇒ (dah dah didah)
\end{verbatim}

\subsubsection{(string-\textgreater{}list string)}

\subsubsection{(substring-\textgreater{}list string start end)}

\verb|string->list| returns a newly allocated list of the character elements of
\emph{string}. \verb|substring->list| returns a newly allocated list of the
character elements of the given substring. The inverse of \verb|string->list|
is \verb|list->string|.

\begin{verbatim}
(string->list "abcd")                   ⇒ (#\a #\b #\c #\d)
(substring->list "abcdef" 1 3)          ⇒ (#\b #\c)
\end{verbatim}

\subsection{Selecting List Components}\label{sec:selecting-list-components}

\subsubsection{(list? \emph{object})}

Returns \verb|#t| if \emph{object} is a list, otherwise returns \verb|#f|. By
definition, all lists have finite length and are terminated by the empty list. This procedure
returns an answer even for circular structures.

Any \emph{object} satisfying this predicate will also satisfy exactly one of \verb|pair?| or
\verb|null?|.

\begin{verbatim}
(list? '(a b c))                        ⇒ #t
(list? '())                             ⇒ #t
(list? '(a . b))                        ⇒ #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))                            ⇒ #f
\end{verbatim}

\subsubsection{(circular-list? \emph{object})}

Returns \verb|#t| if \emph{object} is a circular list, otherwise returns \verb|#f|.

\begin{verbatim}
(circular-list? (list 'a 'b 'c))        ⇒ #f
(circular-list? (cons* 'a 'b 'c))       ⇒ #f
(circular-list? (circular-list 'a 'b 'c)) ⇒ #t
\end{verbatim}

\subsubsection{(dotted-list? \emph{object})}

Returns \verb|#t| if \emph{object} is an improper list, otherwise returns \verb|#f|.

\begin{verbatim}
(dotted-list? (list 'a 'b 'c))          ⇒ #f
(dotted-list? (cons* 'a 'b 'c))         ⇒ #t
(dotted-list? (circular-list 'a 'b 'c)) ⇒ #f
\end{verbatim}

\subsubsection{(length \emph{list})}

Returns the length of \emph{list}. Signals an error if \emph{list} isn't a proper list.

\begin{verbatim}
(length '(a b c))                       ⇒ 3
(length '(a (b) (c d e)))               ⇒ 3
(length '())                            ⇒ 0
(length (circular-list 'a 'b 'c))       ERROR
\end{verbatim}

\subsubsection{(length+ \emph{clist})}

Returns the length of \emph{clist}, if it is a proper list. Returns \verb|#f| if
\emph{clist} is a circular list. Otherwise signals an error.

\begin{verbatim}
(length+ (list 'a 'b 'c))               ⇒ 3
(length+ (cons* 'a 'b 'c))              ERROR
(length+ (circular-list 'a 'b 'c))      ⇒ #f
\end{verbatim}

\subsubsection{(null? \emph{object})}

\subsubsection{(nil? \emph{object})}

Returns \verb|#t| if \emph{object} is the empty list; otherwise returns \verb|#f|.

\begin{verbatim}
(null? '(a . b))                        ⇒ #f
(null? '(a b c))                        ⇒ #f
(null? '())                             ⇒ #t
\end{verbatim}

\subsubsection{(notnull? \emph{object})}

\subsubsection{(notnil? \emph{object})}

Returns \verb|#f| if \emph{object} is the empty list; otherwise returns \verb|#t|.

\begin{verbatim}
(notnull? '(a . b))                        ⇒ #f
(notnull? '(a b c))                        ⇒ #f
(notnull? '())                             ⇒ #t
\end{verbatim}

\subsubsection{(list-ref \emph{list} \emph{k})}

\subsubsection{(nth \emph{k} \emph{list})}

Returns the \emph{k\_th element of \_list}, using zero-origin indexing. The ``valid indexes''
of a list are the non-negative integers less than the length of the list. The first element of
a list has index \verb|0|, the second has index \verb|1|, and so on. \verb|nth| is
provided for Common Lisp familiarity.

\begin{verbatim}
(list-ref '(a b c d) 2)                 ⇒ c
\end{verbatim}

\subsubsection{(first \emph{list})}

\subsubsection{(second \emph{list})}

\subsubsection{(third \emph{list})}

\subsubsection{(fourth \emph{list})}

\subsubsection{(fifth \emph{list})}

\subsubsection{(sixth \emph{list})}

\subsubsection{(seventh \emph{list})}

\subsubsection{(eighth \emph{list})}

\subsubsection{(ninth \emph{list})}

\subsubsection{(tenth \emph{list})}

Returns the specified element of \emph{list}. It is an error if \emph{list} is not long enough
to contain the specified element (for example, if the argument to \verb|seventh| is a list
that contains only six elements).

\subsubsection{(last \emph{list})}

Returns the last element in the list. An error is raised if \emph{list} is a circular list.

\subsection{Cutting and Pasting Lists}\label{sec:cutting-and-pasting-lists}

\subsubsection{(sublist \emph{list} \emph{start} \emph{end})}

\emph{start} and \emph{end} must be integers satisfying

\begin{verbatim}
0 <= START <= END <= (length LIST)
\end{verbatim}

`sublist' returns a newly allocated list formed from the elements of \emph{list}
beginning at index \emph{start} (inclusive) and ending at \emph{end} (exclusive).

\subsubsection{(list-head \emph{list} \emph{k})}

\subsubsection{(take \emph{k} \emph{list})}

Returns a newly allocated list consisting of the first K elements of \emph{list}. \emph{k}
must not be greater than the length of \emph{list}.

We could have defined \verb|list-head| this way:

\begin{verbatim}
      (define (list-head list k)
        (sublist list 0 k))
\end{verbatim}

\subsubsection{(list-tail \emph{list} \emph{k})}

\subsubsection{(drop \emph{k} \emph{list})}

Returns the sublist of \emph{list} obtained by omitting the first \emph{k} elements. The
result, if it is not the empty list, shares structure with \emph{list}. \emph{k} must not be
greater than the length of \emph{list}.

\subsubsection{(append \emph{list}\ldots{})}

Returns a list consisting of the elements of the first \emph{list} followed by the elements of
the other \emph{list} arguments.

\begin{verbatim}
(append '(x) '(y))                      ⇒ (x y)
(append '(a) '(b c d))                  ⇒ (a b c d)
(append '(a (b)) '((c)))                ⇒ (a (b) (c))
(append)                                ⇒ ()
\end{verbatim}

The resulting list is always newly allocated, except that it shares structure with the last
\emph{list} argument. The last argument may actually be any object; an improper list results
if the last argument is not a proper list.

\begin{verbatim}
(append '(a b) '(c . d))                ⇒ (a b c . d)
(append '() 'a)                         ⇒ a
\end{verbatim}

\subsubsection{(append! \emph{list}\ldots{})}

Returns a list that is the all the \emph{list} arguments concatenated together. The arguments
are changed rather than copied. (Compare this with \verb|append|, which copies arguments
rather than destroying them.) For example:

\begin{verbatim}
(define x '(a b c))
(define y '(d e f))
(define z '(g h))
(append! x y z)                         ⇒ (a b c d e f g h)
x                                       ⇒ (a b c d e f g h)
y                                       ⇒ (d e f g h)
z                                       ⇒ (g h)
\end{verbatim}

\subsubsection{(last-pair \emph{list})}

Returns the last pair in \emph{list}, which may be an improper list. \verb|last-pair| could
have been defined this way:

\begin{verbatim}
(define last-pair
  (lambda (x)
    (if (pair? (cdr x))
        (last-pair (cdr x))
        x)))
\end{verbatim}

\subsubsection{(except-last-pair \emph{list})}

\subsubsection{(except-last-pair! \emph{list})}

These procedures remove the last pair from \emph{list}. \emph{list} may be an improper list,
except that it must consist of at least one pair. \verb|except-last-pair| returns a newly
allocated copy of \emph{list} that omits the last pair. \verb|except-last-pair!|
destructively removes the last pair from \emph{list} and returns \emph{list}. If the cdr of
\emph{list} is not a pair, the empty list is returned by either procedure.

\subsection{Filtering Lists}\label{sec:filtering-lists}

\subsubsection{(filter \emph{predicate} \emph{list})}

Returns a newly allocated copy of \emph{list} containing only the elements satisfying
\emph{predicate}. \emph{predicate} must be a procedure of one argument.

\begin{verbatim}
(filter odd? '(1 2 3 4 5)) ⇒ (1 3 5)
\end{verbatim}

\subsubsection{(remove \emph{predicate} \emph{list})}

Like \verb|filter|, except that the returned list contains only those elements \textbf{not}
satisfying \emph{predicate}.

\begin{verbatim}
(remove odd? '(1 2 3 4 5)) ⇒ (2 4)
\end{verbatim}

\subsubsection{(partition \emph{predicate} \emph{list})}

\subsubsection{(partition \emph{size} \emph{step} \emph{list})}

The first form partitions the elements of \emph{list} with \emph{predicate}, and returns a
list of two elements: the list of in-elements and the list of out-elements. The \emph{list} is
not disordered--elements occur in the result lists in the same order as they occur in the
argument \emph{list}. The dynamic order in which the various applications of \emph{predicate}
are made is not specified. One of the returned lists may share a common tail with the argument
\emph{list}.

\begin{verbatim}
(partition symbol? '(one 2 3 four five 6)) ⇒
    ((one four five) (2 3 6))
\end{verbatim}

The second form partitions the elements of \emph{list} into lists of length \emph{size},
returning a list of those lists. Only lists of \emph{size} are returned; any at the end that
don't fit are discarded. As with the first form, elements occur in the result lists in the
same order as they occur in the argument \emph{list}. If the optional \emph{step} argument is
ommitted it defaults to size. Each sublist starts at \emph{step} elements from the start of
the previous. If \emph{step} \textgreater{} \emph{size} elements will be skipped between
sublists. If \emph{step} \textless{} \emph{size} the sublists will overlap.

\begin{verbatim}
(partition 2 '(one 2 3 four five 6))    ⇒ ((one 2) (3 four) (five 6))

(partition 2 '(one 2 3 four five 6 7))  ⇒ ((one 2) (3 four) (five 6) (7))

(partition 2 1 '(1 2 3 4 5 6 7 8 9 0)) ⇒ ((1 2) (2 3) (3 4) (4 5) (5 6) (6 7) (7 8) (8 9))

(partition 2 3 '(1 2 3 4 5 6 7 8 9 0)) ⇒ ((1 2) (4 5) (7 8))
\end{verbatim}

\subsubsection{(delq element list)}

\subsubsection{(delv element list)}

\subsubsection{(delete element list)}

Returns a newly allocated copy of \emph{list} with all entries equal to \emph{element}
removed. \verb|delq| uses \verb|eq?| to compare \emph{element} with the entries in
\emph{list}, \verb|delv| uses \verb|eqv?|, and \verb|delete| uses \verb|equal?|.

\subsection{Searching Lists}\label{sec:searching-lists}

\subsubsection{(find \emph{predicate} \emph{list})}

Returns the first element in \emph{list} for which \emph{predicate} is true; returns
\verb|#f| if it doesn't find such an element. \emph{predicate} must be a procedure of one
argument.

\begin{verbatim}
(find even? '(3 1 4 1 5 9)) ⇒ 4
\end{verbatim}

Note that \verb|find| has an ambiguity in its lookup semantics--if \verb|find| returns
\verb|#f|, you cannot tell (in general) if it found a \verb|#f| element that satisfied
\emph{predicate}, or if it did not find any element at all. In many situations, this ambiguity
cannot arise--either the list being searched is known not to contain any \verb|#f|
elements, or the list is guaranteed to have an element satisfying \emph{predicate}. However,
in cases where this ambiguity can arise, you should use \verb|find-tail| instead of
\verb|find| -- \verb|find-tail| has no such ambiguity:

\begin{verbatim}
(cond ((find-tail pred lis)
        => (lambda (pair) ...)) ; Handle (CAR PAIR)
      (else ...)) ; Search failed.
\end{verbatim}

\subsubsection{(find-tail \emph{predicate} \emph{list})}

Returns the first pair of \emph{list} whose car satisfies \emph{predicate}; returns
\verb|#f| if there's no such pair. \verb|find-tail| can be viewed as a general-predicate
variant of \verb|memv|.

\subsubsection{(memq \emph{object} \emph{list})}

\subsubsection{(memv \emph{object} \emph{list})}

\subsubsection{(member \emph{object} \emph{list})}

These procedures return the first pair of \emph{list} whose car is \emph{object}; the returned
pair is always one from which \emph{list} is composed. If \emph{object} does not occur in
\emph{list}, \verb|#f| (n.b.: not the empty list) is returned. \verb|memq| uses
\verb|eq?| to compare \emph{object} with the elements of \emph{list}, while \verb|memv|
uses \verb|eqv?| and \verb|member| uses \verb|equal?|.

\begin{verbatim}
(memq 'a '(a b c))                      ⇒ (a b c)
(memq 'b '(a b c))                      ⇒ (b c)
(memq 'a '(b c d))                      ⇒ #f
(memq (list 'a) '(b (a) c))             ⇒ #f
(member (list 'a) '(b (a) c))           ⇒ ((a) c)
(memq 101 '(100 101 102))               ⇒ (101 102)
(memv 101 '(100 101 102))               ⇒ (101 102)
\end{verbatim}

Although they are often used as predicates, \verb|memq|, \verb|memv|, and
\verb|member| do not have question marks in their names because they return
useful values rather than just \verb|#t| or \verb|#f|.

\subsubsection{(memp \emph{predicate} \emph{list})}

Returns the first pair of \emph{list} for which \emph{predicate} returns \verb|#t| when
passed the car; the returned pair is always one from which \emph{list} is composed. If
\emph{predicate} never returns \verb|#t|, \verb|#f| (n.b.: not the empty list) is
returned.

\subsection{Mapping of Lists}\label{sec:mapping-of-lists}

\subsubsection{(map \emph{procedure} \emph{list}\ldots{})}

\emph{procedure} must be a procedure taking as many arguments as there are \emph{lists}. If
more than one \emph{list} is given, then they must all be the same length. \verb|map|
applies \emph{procedure} element-wise to the elements of the \emph{lists} and returns a list
of the results, in order from left to right. The dynamic order in which \emph{procedure} is
applied to the elements of the \emph{lists} is unspecified; use \verb|for-each| to sequence
side effects.

\begin{verbatim}
(map cadr '((a b) (d e) (g h)))           ⇒ (b e h)
(map (lambda (n) (expt n n)) '(1 2 3 4))  ⇒ (1 4 27 256)
(map + '(1 2 3) '(4 5 6))                 ⇒ (5 7 9)
(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b c)))                         ⇒ unspecified
\end{verbatim}

\subsubsection{(for-each \emph{procedure} \emph{list} \ldots{})}

The arguments to \verb|for-each| are like the arguments to \verb|map|, but
\verb|for-each| calls \emph{procedure} for its side effects rather than for its values.
Unlike \verb|map|, \verb|for-each| is guaranteed to call \emph{procedure} on the elements
of the \emph{lists} in order from the first element to the last, and the value returned by
\verb|for-each| is unspecified.

\begin{verbatim}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                            ⇒ #(0 1 4 9 16)
\end{verbatim}

\subsection{Reduction of Lists}\label{sec:reduction-of-lists}

\subsubsection{(reduce \emph{procedure} \emph{initial} \emph{list})}

\subsubsection{(reduce-left \emph{procedure} \emph{initial} \emph{list})}

Combines all the elements of \emph{list} using the binary operation \emph{procedure}. For
example, using \verb|+| one can add up all the elements:

\begin{verbatim}
(reduce-left + 0 list-of-numbers)
\end{verbatim}

The argument \emph{initial} is used only if \emph{list} is empty; in this case \emph{initial}
is the result of the call to \verb|reduce-left|. If \emph{list} has a single argument, it is
returned. Otherwise, the arguments are reduced in a left-associative fashion. For example:

\begin{verbatim}
(reduce-left + 0 '(1 2 3 4))            ⇒ 10
(reduce-left + 0 '(1 2))                ⇒ 3
(reduce-left + 0 '(1))                  ⇒ 1
(reduce-left + 0 '())                   ⇒ 0
(reduce-left + 0 '(foo))                ⇒ foo
(reduce-left list '() '(1 2 3 4))       ⇒ (((1 2) 3) 4)
\end{verbatim}

\subsubsection{(reduce-right \emph{procedure} \emph{initial} \emph{list})}

Like \verb|reduce-left| except that it is right-associative.

\begin{verbatim}
(reduce-right list '() '(1 2 3 4))      ⇒ (1 (2 (3 4)))
\end{verbatim}

\subsubsection{(fold-right \emph{procedure} \emph{initial} \emph{list})}

Combines all of the elements of \emph{list} using the binary operation \emph{procedure}.
Unlike \verb|reduce-left| and \verb|reduce-right|, \emph{initial} is always used:

\begin{verbatim}
(fold-right + 0 '(1 2 3 4))             ⇒ 10
(fold-right + 0 '(foo))                 ERROR Illegal datum
(fold-right list '() '(1 2 3 4))        ⇒ (1 (2 (3 (4 ()))))
\end{verbatim}

\verb|fold-right| has interesting properties because it establishes a homomorphism between
(\verb|cons|, \verb|()|) and (\emph{procedure}, \emph{initial}). It can be thought of as
replacing the pairs in the spine of the list with \emph{procedure} and replacing the
\verb|()| at the end with \emph{initial}. Many of the classical list-processing procedures
can be expressed in terms of \verb|fold-right|, at least for the simple versions that take a
fixed number of arguments:

\begin{verbatim}
(define (copy-list list)
  (fold-right cons '() list))

(define (append list1 list2)
  (fold-right cons list2 list1))

(define (map p list)
  (fold-right (lambda (x r) (cons (p x) r)) '() list))

(define (reverse items)
  (fold-right (lambda (x r) (append r (list x))) '() items))
\end{verbatim}

\subsubsection{(fold-left \emph{procedure} \emph{initial} \emph{list})}

Combines all the elements of \emph{list} using the binary operation \emph{procedure}. Elements
are combined starting with \emph{initial} and then the elements of \emph{list} from left to
right. Whereas \verb|fold-right| is recursive in nature, capturing the essence of cdr-ing
down a list and then computing a result (although all the reduce/fold functions are
implemented iteratively in the runtime), \verb|fold-left| is iterative in nature, combining
the elements as the list is traversed.

\begin{verbatim}
(fold-left list '() '(1 2 3 4))         ⇒ ((((() 1) 2) 3) 4)

(define (length list)
  (fold-left (lambda (sum element) (+ sum 1)) 0 list))

(define (reverse items)
  (fold-left (lambda (x y) (cons y x)) () items))
\end{verbatim}

\subsubsection{(any \emph{predicate} \emph{list}\ldots{})}

Applies \emph{predicate} across the \emph{lists}, returning true if \emph{predicate} returns
true on any application.

If there are n list arguments \emph{list1} \ldots{} \emph{listn}, then \emph{predicate} must
be a procedure taking n arguments and returning a boolean result.

\verb|any| applies \emph{predicate} to the first elements of the \emph{list} parameters. If
this application returns a true value, \verb|any| immediately returns that value. Otherwise,
it iterates, applying \emph{predicate} to the second elements of the \emph{list} parameters,
then the third, and so forth. The iteration stops when a true value is produced or one of the
lists runs out of values; in the latter case, \verb|any| returns \verb|#f|. The
application of \emph{predicate} to the last element of the \emph{lists} is a tail call.

Note the difference between \verb|find| and \verb|any| -- \verb|find| returns the
element that satisfied the predicate; \verb|any| returns the true value that the
\emph{predicate} produced.

Like \verb|every|, \verb|any|'s name does not end with a question mark -- this is to
indicate that it does not return a simple boolean (\verb|#t| or \verb|#f|), but a
general value.

\begin{verbatim}
(any integer? '(a 3 b 2.7))   ⇒ #t
(any integer? '(a 3.1 b 2.7)) ⇒ #f
(any < '(3 1 4 1 5)
       '(2 7 1 8 2)) ⇒ #t
\end{verbatim}

\subsubsection{(every \emph{predicate} \emph{list}\ldots{})}

Applies \emph{predicate} across the \emph{lists}, returning true if \emph{predicate} returns
true on every application.

If there are n list arguments \emph{list1} \ldots{} \emph{listn}, then \emph{predicate} must
be a procedure taking n arguments and returning a boolean result.

\verb|every| applies \emph{predicate} to the first elements of the \emph{list} parameters.
If this application returns false, \verb|every| immediately returns false. Otherwise, it
iterates, applying \emph{predicate} to the second elements of the \emph{list} parameters, then
the third, and so forth. The iteration stops when a false value is produced or one of the
\emph{lists} runs out of values. In the latter case, \verb|every| returns the true value
produced by its final application of \emph{predicate}. The application of \emph{predicate} to
the last element of the \emph{lists} is a tail call.

If one of the \emph{lists} has no elements, \verb|every| simply returns \verb|#t|.

Like \verb|any|, \verb|every|'s name does not end with a question mark -- this is to
indicate that it does not return a simple boolean (\verb|#t| or \verb|#f|), but a
general value.

\subsection{Miscellaneous List Operations}\label{sec:miscellaneous-list-operations}

\subsubsection{(circular-list \emph{object}\ldots{})}

This procedure is like \verb|list|, except that the returned list is circular.

\subsubsection{(reverse \emph{list})}

Returns a newly allocated list consisting of the top-level elements of \emph{list} in reverse
order.

\begin{verbatim}
(reverse '(a b c))                  ⇒ (c b a)
(reverse '(a (b c) d (e (f))))      ⇒ ((e (f)) d (b c) a)
\end{verbatim}

\subsubsection{(sort \emph{sequence} \emph{procedure})}

\emph{sequence} must be either a list or a vector. \emph{procedure} must be a procedure of two
arguments that defines a ``total ordering'' on the elements of \emph{sequence}. In other
words, if X and Y are two distinct elements of \emph{sequence}, then it must be the case that

\begin{verbatim}
(and (PROCEDURE X Y)
     (PROCEDURE Y X))
     ⇒ #f
\end{verbatim}

If \emph{sequence} is a list (vector), \verb|sort| returns a newly allocated list (vector)
whose elements are those of \emph{sequence}, except that they are rearranged to be sorted in
the order defined by \emph{procedure}. So, for example, if the elements of \emph{sequence} are
numbers, and \emph{procedure} is \verb|<|, then the resulting elements are sorted
in monotonically nondecreasing order. Likewise, if \emph{procedure} is
\verb|>|, the resulting elements are sorted in monotonically nonincreasing
order. To be precise, if X and Y are any two adjacent elements in the result, where X precedes
Y, it is the case that

\begin{verbatim}
(PROCEDURE Y X)
     ⇒ #f
\end{verbatim}

There is also the function \verb|vector-sort| that applies only to vectors, and will raise
an erro if applied to a list.

\subsubsection{(flatten \emph{list})}

Returns a list with the contents of all top level nested lists placed directly in the result.
This is best illustrated with some examples:

\begin{verbatim}
(flatten '(a b c d)) ⇒ (a b c d)
(flatten '(a (b c) d)) ⇒ (a b c d)
(flatten '(a (b (c d)))) ⇒ (a b (c d))
\end{verbatim}

\subsubsection{(flatten* \emph{list})}

Returns a list with the contents of all nested lists placed directly in the result. This is
also best illustrated with some examples:

\begin{verbatim}
(flatten* '(a b c d)) ⇒ (a b c d)
(flatten* '(a (b c) d)) ⇒ (a b c d)
(flatten* '(a (b (c d)))) ⇒ (a b c d)
\end{verbatim}

\subsubsection{(union \emph{list}\ldots{})}

Returns a list that contains all items in the argument \emph{list}s. Each item appears only
once in the result regardless of whether it was repeated in any \emph{list}.

\begin{verbatim}
(union '(1 2 3) '(4 5))      ⇒ (1 2 3 4 5)
(union '(1 2 3) '(3 4 5))    ⇒ (1 2 3 4 5)
(union '(1 2 3 2) '(4 4 5))  ⇒ (1 2 3 4 5)
\end{verbatim}

\subsubsection{(intersection \emph{list}\ldots{})}

Returns a list that contains only items that are in all \emph{list} arguments.

\begin{verbatim}
(intersection '(1 2 3) '(3 4 5)) ⇒ (3)
(intersection '() '(3 4 5))      ⇒ ()
\end{verbatim}

\subsubsection{(complement \emph{list}\ldots{})}

Returns a list that contains only items that were in the first \emph{list} argument, but not
in any of the subsequent argument \emph{list}s.

\begin{verbatim}
(complement '(1 2 3 4 5) '(1 3 5))      ⇒ (2 4)
(complement '() '(1 2))                 ⇒ ()
(complement '(1 2 3 4 5) '(1 2) '(3 4)) ⇒ (5)
\end{verbatim}

\section{Vectors}\label{sec:vectors}

Vectors are heterogeneous structures whose elements are indexed by non-negative integers. A
vector typically occupies less space than a list of the same length, and the average time
required to access a randomly chosen element is typically less for the vector than for the
list.

The length of a vector is the number of elements that it contains. This number is a
non-negative integer that is fixed when the vector is created. The valid indexes of a vector
are the non-negative integers less than the length of the vector. The first element in a
vector is indexed by zero, and the last element is indexed by one less than the length of the
vector.

Vectors are written using the notation \verb|#(object ...)|. For example, a vector of
length 3 containing the number zero in element 0, the list \verb|(2 2 2 2)| in element 1,
and the string \verb|"Anna"| in element 2 can be written as

\begin{verbatim}
 #(0 (2 2 2 2) "Anna")
\end{verbatim}

Note that this is the external representation of a vector, not an expression evaluating to a
vector. Like list constants, vector constants must be quoted:

\begin{verbatim}
'#(0(2222)"Anna") ⇒ #(0 (2222) "Anna")
\end{verbatim}

A number of the vector procedures operate on subvectors. A subvector is a segment of a vector
that is specified by two non-negative integers, start and end. Start is the index of the first
element that is included in the subvector, and end is one greater than the index of the last
element that is included in the subvector. Thus if start and end are the same, they refer to a
null subvector, and if start is zero and end is the length of the vector, they refer to the
entire vector. The valid indexes of a subvector are the integers between start inclusive and
end exclusive.

\subsection{Construction of Vectors}\label{sec:construction-of-vectors}

\subsubsection{(make-vector \emph{k} [\emph{object}])}

Returns a newly allocated vector of k elements. If \emph{object} is specified,
\verb|make-vector| initializes each element of the vector to the \emph{object}. Otherwise
the initial elements of the result are unspecified.

\subsubsection{(vector \emph{object}\ldots{})}

Returns a newly allocated vector whose elements are the given \emph{objects}. \verb|vector|
is analogous to \verb|list|.

\begin{verbatim}
(vector 'a 'b 'c) ⇒ #(a b c)
\end{verbatim}

\subsubsection{(vector-copy \emph{vector})}

Returns a newly allocated vector that is a copy of \emph{vector}.

\subsubsection{(list-\textgreater{}vector \emph{list})}

Returns a newly allocated vector initialized to the elements of \emph{list}.

\begin{verbatim}
(list->vector '(dididit dah)) ⇒ #(dididit dah)
\end{verbatim}

\subsubsection{(vector-\textgreater{}list \emph{vector})}

Returns a newly allocated list initialized to the elements of \emph{vector}.

\begin{verbatim}
(vector->list '#(dididitdah)) ⇒ (dididit dah)
\end{verbatim}

\subsubsection{(make-initialized-vector \emph{k} \emph{initialization})}

Similar to \verb|make-vector|, except that the elements of the result are
determined by calling the procedure \emph{initialization} on the indices. For
example:

\begin{verbatim}
(make-initialized-vector 5 (lambda (x) (* x x))) ⇒ #(0 1 4 9 16)
\end{verbatim}

\subsubsection{(vector-grow \emph{vector} \emph{k})}

\emph{k} must be greater than or equal to the length of \emph{vector}. Returns a newly
allocated vector of length \emph{k}. The first \verb|(vector-length vector)| elements of the
result are initialized from the corresponding elements of \emph{vector}. The remaining
elements of the result are unspecified.

\subsection{Enumerating over Vectors}\label{sec:enumerating-over-vectors}

\subsubsection{(vector-map \emph{procedure} \emph{vector}\ldots{})}

\emph{procedure} must be a procedure with arity the same as the number or \emph{vector}s.
\verb|vector-map| applies \emph{procedure} element-wise to the corresponding elements of
each \emph{vector} and returns a newly allocated vector of the results, in order from left to
right. The dynamic order in which procedure is applied to the elements of vector is
unspecified.

\begin{verbatim}
(vector-map cadr '#((ab)(de)(gh)))            ⇒ #(b e h)
(vector-map (lambda (n) (* n n)) '#(1 2 3 4)) ⇒ #(1 4 9 16)
(vector-map + '#(1 2 3) '#(4 5 6))            ⇒ #(5 7 9)
\end{verbatim}

\subsection{Selecting Vector Components}\label{sec:selecting-vector-components}

\subsubsection{(vector-length \emph{vector})}

Returns the number of elements in \emph{vector}.

\subsubsection{(vector-ref \emph{vector} \emph{k})}

Returns the contents of element \emph{k} of \emph{vector}. \emph{k} must be a valid index of
\emph{vector}.

\begin{verbatim}
(vector-ref '#(1 1 2 3 5 8 13 21) 5)    ⇒  8
\end{verbatim}

\subsubsection{(vector-set! \emph{vector} \emph{k} \emph{object})}

Stores \emph{object} in element \emph{k} of \emph{vector} and returns an unspecified value.
\emph{K} must be a valid index of \emph{vector}.

\begin{verbatim}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)
            ⇒  #(0 ("Sue" "Sue") "Anna")
\end{verbatim}

\subsubsection{(vector-first \emph{vector})}

\subsubsection{(vector-second \emph{vector})}

\subsubsection{(vector-third \emph{vector})}

\subsubsection{(vector-fourth \emph{vector})}

\subsubsection{(vector-fifth \emph{vector})}

\subsubsection{(vector-sixth \emph{vector})}

\subsubsection{(vector-seventh \emph{vector})}

\subsubsection{(vector-eighth \emph{vector})}

\subsubsection{(vector-ninth \emph{vector})}

\subsubsection{(vector-tenth \emph{vector})}

These procedures access the first several elements of \emph{vector} in the obvious way. It is
an error if the implicit index of one of these procedures is not a valid index of
\emph{vector}.

\subsubsection{(vector-last \emph{vector})}

Returns the last element of \emph{vector}.

\subsubsection{(vector-binary-search \emph{vector} \emph{key\textless{}?} \emph{unwrap-key} \emph{key})}

Searches \emph{vector} for an element with a key matching \emph{key}, returning the element if
one is found or \emph{\#f} if none. The search operation takes time proportional to the
logarithm of the length of \emph{vector}. \emph{unwrap-key} must be a procedure that maps each
element of \emph{vector} to a key. \emph{key\textless{}?} must be a procedure that implements
a total ordering on the keys of the elements.

\begin{verbatim}
(define (translate number)
  (vector-binary-search '#((1 . i)
                           (2 . ii)
                           (3 . iii)
                           (6 . vi))
                        < car number))
(translate 2)  ⇒  (2 . ii)
(translate 4)  ⇒  #f
\end{verbatim}

\subsection{Cutting Vectors}\label{sec:cutting-vectors}

\subsubsection{(subvector \emph{vector} \emph{start} \emph{end})}

Returns a newly allocated vector that contains the elements of \emph{vector} between index
\emph{start} (inclusive) and \emph{end} (exclusive).

\subsubsection{(vector-head \emph{vector} \emph{end})}

Equivalent to

\begin{verbatim}
(subvector vector 0 end)
\end{verbatim}

\subsubsection{(vector-tail \emph{vector} \emph{start})}

Equivalent to

\begin{verbatim}
(subvector vector start (vector-length vector))
\end{verbatim}

\subsection{Modifying Vectors}\label{sec:modifying-vectors}

\subsubsection{(vector-fill! \emph{vector} \emph{object})}

\subsubsection{(subvector-fill! \emph{vector} \emph{start} \emph{end} \emph{object})}

Stores \emph{object} in every element of the vector (subvector) and returns an unspecified
value.

\subsubsection{(subvector-move-left! \emph{vector1} \emph{start1} \emph{end1} \emph{vector2} \emph{start2})}

\subsubsection{(subvector-move-right! \emph{vector1} \emph{start1} \emph{end1} \emph{vector2} \emph{start2})}

Destructively copies the elements of \emph{vector1}, starting with index \emph{start1}
(inclusive) and ending with \emph{end1} (exclusive), into \emph{vector2} starting at index
\emph{start2} (inclusive). \emph{vector1}, \emph{start1}, and \emph{end1} must specify a valid
subvector, and \emph{start2} must be a valid index for \emph{vector2}. The length of the
source subvector must not exceed the length of \emph{vector2} minus the index \emph{start2}.

The elements are copied as follows (note that this is only important when \emph{vector1} and
\emph{vector2} are \verb|eqv?|):

\verb|subvector-move-left!|: The copy starts at the left end and moves toward the right
(from smaller indices to larger). Thus if \emph{vector1} and \emph{vector2} are the same, this
procedure moves the elements toward the left inside the vector.

\verb|subvector-move-right!|: The copy starts at the right end and moves toward the left
(from larger indices to smaller). Thus if \emph{vector1} and \emph{vector2} are the same, this
procedure moves the elements toward the right inside the vector.

\subsubsection{(vector-sort! \emph{vector} \emph{procedure})}

\emph{procedure} must be a procedure of two arguments that defines a \emph{total ordering} on
the elements of \emph{vector}. The elements of \emph{vector} are rearranged so that they are
sorted in the order defined by \emph{procedure}. The elements are rearranged in place, that
is, VECTOR is destructively modified so that its elements are in the new order.

\verb|sort!| returns \emph{vector} as its value.

See also the definition of \verb|sort|.

\section{Associations}\label{sec:associations}

\subsection{Association Lists}\label{sec:association-lists}

``Association lists'' are one of Lisp's oldest association mechanisms. Because they are made
from ordinary pairs, they are easy to build and manipulate, and very flexible in use. However,
the average lookup time for an association list is linear in the number of associations.
Frames are a more efficient

An ``association list'', or ``alist'', is a data structure used very frequently in Scheme. An
alist is a list of pairs, each of which is called an ``association''. The car of an
association is called the ``key'', and the cdr is called the ``value''. Having lists as pair
values can cause confusion becase the pair in the alist look like proper lists and not dotted
pairs. Functions that look specifically for dotted pairs will not consider it an association
list (e.g. \verb|alist?|) while those that don't will work fine (e.g. the \verb|assoc| \&
\verb|dissoc| functions). The latter simply look at the car and cdr of the pairs. not
whether they are canonical dotted pairs (i.e. their cdr is not a pair).

\begin{verbatim}
'((a . (1 2)) (b . (3 4)))                   ⇒ ((a 1 2) (b 3 4))
(alist? '((a . (1 2)) (b . (3 4))))          ⇒ #f
(assoc 'b '((a . (1 2)) (b . (3 4))))        ⇒ (b 3 4)
(cdr (assoc 'b '((a . (1 2)) (b . (3 4)))))  ⇒ (3 4)
\end{verbatim}

An advantage of the alist representation is that an alist can be incrementally augmented
simply by adding new entries to the front. Moreover, because the searching procedures `assv'
et al. search the alist in order, new entries can ``shadow'' old entries. If an alist is
viewed as a mapping from keys to data, then the mapping can be not only augmented but also
altered in a non-destructive manner by adding new entries to the front of the alist.

\subsubsection{(alist? \emph{object})}

Returns \verb|#t| if \emph{object} is an association list (including the empty list);
otherwise returns \verb|#f|. Any \emph{object} satisfying this predicate also satisfies
\verb|list?|.

\subsubsection{(acons \emph{key} \emph{value} [\emph{alist}])}

Returns the result of consing a pair \verb|(key . value)| to \emph{alist}. If \emph{alist} is
omitted, it defaults to the empty list.

\begin{verbatim}
(acons 'a 1)            ⇒ ((a . 1))
(acons 'a 1 '((b . 2))) ⇒ ((a . 1) (b . 2))
(acons 'b 1 '((b . 2))) ⇒ ((b . 1) (b . 2))
\end{verbatim}

\subsubsection{(pairlis \emph{keys} \emph{values} [\emph{alist}])}

Creates an association list from lists of \emph{keys} and \emph{values} by acons-ing onto
\emph{alist}. If \emph{alist} is omitted, it defaults to the empty list. Note that the key and
value lists are paired up in left to right order, but the order they are consed onto
\emph{alist} is unspecified.

\begin{verbatim}
(pairlis '(a b) '(1 2))                    ⇒ ((b . 2) (a . 1)))
(pairlis '(a b) '(1 2) '((c . 3) (d . 4))) ⇒ ((b . 2) (a . 1) (c . 3) (d . 4))))
\end{verbatim}

\subsubsection{(assq \emph{object} \emph{alist})}

\subsubsection{(assv \emph{object} \emph{alist})}

\subsubsection{(assoc \emph{object} \emph{alist})}

These procedures find the first pair in \emph{alist} whose car field is \emph{object}, and
return that pair; the returned pair is always an \textbf{element} of \emph{alist},
\textbf{not} one of the pairs from which \emph{alist} is composed. If no pair in \emph{alist}
has \emph{object} as its car, \verb|#f| (n.b.: not the empty list) is returned.
\verb|assq| uses \verb|eq?| to compare \emph{object} with the car fields of the pairs in
\emph{alist}, while \verb|assv| uses \verb|eqv?| and \verb|assoc| uses \verb|equal?|.

\begin{verbatim}
(define e '((a . 1) (b . 2) (c . 3)))
(assq 'a e)                             ⇒  (a . 1)
(assq 'b e)                             ⇒  (b . 2)
(assq 'd e)                             ⇒  #f
(assq (list 'a) '(((a)) ((b)) ((c))))   ⇒  #f
(assoc (list 'a) '(((a)) ((b)) ((c))))  ⇒  ((a))
(assv 5 '((2 . 3) (5 . 7) (11 . 13)))   ⇒  (5 . 7)
\end{verbatim}

\subsubsection{(rassoc \emph{value} \emph{alist})}

Return the pair from \emph{alist} whose cdr is equal to \emph{value}. \verb|#f| is returned
is \emph{value} isn’t found.

\begin{verbatim}
(rassoc 1 '((a . 1) (b . 2) (c . 3))) ⇒ (a . 1)
(rassoc 3 '((a . 1) (b . 2)))         ⇒ #f
\end{verbatim}

\subsubsection{(del-assq \emph{object} \emph{alist})}

\subsubsection{(dissq \emph{object} \emph{alist})}

\subsubsection{(del-assv \emph{object} \emph{alist})}

\subsubsection{(dissv \emph{object} \emph{alist})}

\subsubsection{(del-assoc \emph{object} \emph{alist})}

\subsubsection{(dissoc \emph{object} \emph{alist})}

These procedures return a newly allocated copy of \emph{alist} in which all associations with
keys equal to \emph{object} have been removed. Note that while the returned copy is a newly
allocated list, the association pairs that are the elements of the list are shared with
\emph{alist}, not copied. \verb|del-assq|/\verb|dissq| use \verb|eq?| to compare
\emph{object} with the keys, while \verb|del-assv|/\verb|dissv| use \verb|eqv?| and
\verb|del-assoc|/\verb|dissoc| use \verb|equal?|.

\begin{verbatim}
(define a
  '((butcher . "231 e22nd St.")
    (baker . "515 w23rd St.")
    (hardware . "988 Lexington Ave.")))

(del-assq 'baker a)
     ⇒
     ((butcher . "231 e22nd St.")
      (hardware . "988 Lexington Ave."))
\end{verbatim}

\section{Frames}\label{sec:frames}

GoLisp contains a frame system inspired by Self [4] and NewtonScript [5].

A frame is a set of named slots that hold arbitrary values. Slot names must be symbols that
end with a colon. For example: \verb|color:|, or \verb|height:|. When evaluated normally,
these special symbols don’t get looked up in the environment, they simply evaluate to
themselves.

\begin{verbatim}
(define a a:)

'a ⇒ a
a  ⇒ a:

'a: ⇒ a:
a:  ⇒ a:
\end{verbatim}

\subsubsection{(make-slotname \emph{symbol})}

This function takes a symbol or string and returns an interned slotname based on it, doing
what is required.

\begin{verbatim}
(make-slotname 'name) ⇒ name:
(make-slotname "name") ⇒ name:
(make-slotname name:) ⇒ name:
\end{verbatim}

\subsection{Basic functions}\label{sec:basic-functions}

\subsubsection{(make-frame \emph{slot-name} \emph{slot-value} \ldots{} )}

Frames can be created using the \verb|make-frame| function, passing it an alternating
sequence of slot names and values:

\begin{verbatim}
(make-frame a: 1 b: 2)
\end{verbatim}

This results in a frame with two slots, named \verb|a:| and \verb|b:| with values
\verb|1| and \verb|2|, respectively.

\subsubsection{\{ \emph{slot-name} \emph{slot-value} \ldots{} \}}

This is an alternative syntax for defining frame literals:

\begin{verbatim}
{a: 1 b: 2}
\end{verbatim}

Both are equivalent. Slot names and values in both cases are evaluated (this is one reason for
the non-evaluating symbols: it avoiding having to quote literal slot names).

\subsubsection{(clone \emph{frame})}

Frames represent things. For example, you could use a frame that looks like
\verb|{x: 1 y: 10}| to represent a point. A system that would use point frames will typically
need many independant points. The approach to this is to create a prototypical point data
frame, and use the \verb|clone| function to create individual, independant frames:

\begin{verbatim}
(define point {x: 1 y: 1})
(define p1 (clone point))
(set-slot! p1 x: 5)
(get-slot p1 x:)    ⇒ 5
(get-slot point x:) ⇒ 1
\end{verbatim}

\subsubsection{(has-slot? \emph{frame} \emph{slot-name})}

\subsubsection{(\emph{slot-name}? \emph{frame})}

The \verb|has-slot?| function is used to query whether a frame contains (directly or in an
ancestor) the particular slot:

\begin{verbatim}
(define f {a: 1 b: 2})
(has-slot? f a:)      ⇒ #t
(a:? f)               ⇒ #t
(has-slot? f c:)      ⇒ #f
(c:? f)               ⇒ #f
\end{verbatim}

\subsubsection{(get-slot \emph{frame} \emph{slot-name})}

\subsubsection{(\emph{slot-name} \emph{frame})}

The \verb|get-slot| function is used to retrieve values from frame slots:

\begin{verbatim}
(define f {a: 1 b: 2})
(get-slot f a:)       ⇒ 1
(a: f)                ⇒ 1
(get-slot f b:)       ⇒ 2
(b: f)                ⇒ 2
\end{verbatim}

If the frame passed to \verb|get-slot| contains a slot with the specified name, it’s value
is returned. If not, then parent frames are searched in a nondeterministic order until a slot
with the specified name is found. If a matching slot is found, it’s value is returned. If none
is found an error is raised.

\begin{verbatim}
(define f {a: 1 b: 2})
(define g {parent*: f c: 3})

(get-slot g c:) ⇒ 3
(get-slot g a:) ⇒ 1  ; from the frame f
\end{verbatim}

\subsubsection{(get-slot-or-nil \emph{frame} \emph{slot-name})}

The same as above, except that if a matching slot is not found, \verb|nil| is returned
instead of raising an error.

\subsubsection{(set-slot! \emph{frame} \emph{slot-name} \emph{new-value})}

\subsubsection{(\emph{slot-name}! \emph{frame} \emph{new-value})}

The \verb|set-slot!| function is used to change values in frame slots:

\begin{verbatim}
(define f {a: 1 b: 2})
(get-slot f a:)    ⇒ 1
(set-slot! f a: 5) ⇒ 5
(a:! f 5) ⇒ 5
(get-slot f a:)    ⇒ 5
\end{verbatim}

Trying to set a slot that doesn’t exist in the frame will result in a corresponding slot being
created.

\begin{verbatim}
(define f {a: 1 b: 2})
(set-slot! f c: 5) ⇒ 5
f                  ⇒ {a: 1 b: 2 c: 5}
\end{verbatim}

\subsubsection{(remove-slot! \emph{frame} \emph{slot-name})}

The \verb|remove-slot!| function is used to function is used to remove a slot from a frame.
It only removes slots from the frame itself. not any of it's parents. \verb|remove-slot!|
return \verb|#t| if the slot was removed, \verb|#f| otherwise.

\begin{verbatim}
(define f {a: 1 b: 2})
(remove-slot! f a:) ⇒ #t
f                   ⇒ {b: 2}
(remove-slot! f a:) ⇒ #f
\end{verbatim}

\subsubsection{(frame-keys \emph{frame})}

Returns a list of the slot names in \emph{frame}. Note that the order of the result is
nondeterministic.

\begin{verbatim}
(frame-keys {a: 1 b: 2}) ⇒ (a: b:)
\end{verbatim}

\subsubsection{(frame-values \emph{frame})}

Returns a list of the slot values in \emph{frame}. Note that the order of the result is
nondeterministic.

\begin{verbatim}
(frame-values {a: 1 b: 2}) ⇒ (1 2)
\end{verbatim}

\subsection{Parent slots}\label{sec:parent-slots}

Frames can have slots that refer to other slots to provide prototype inheritance. These slots
have names that have a \verb|*| immediately preceeding the trailing \verb|:|, for example
\verb|proto*:|. The names of the parent slots don't matter; it is the trailing \verb|*:|
in the name that marks them as parent slots. A frame can have any number of parent slots.

When a slot is being searched for, if it isn't found in the specified slot, these
\emph{parent} slots are recursively searched until the requested slot is found or the entire
graph has been examined.

\begin{verbatim}
> (define y {a: 1})
=⇒ {a: 1}
> (define x {b: 2 p*: y})
=⇒ {b: 2 p*: {...}}

> (a: x)
=⇒ 1
\end{verbatim}

\textbf{Note:} Parent slots are searched in arbitrary order.

\subsection{Function slots}\label{sec:function-slots}

Now things get interesting. Slot values can be functions (typically \verb|lambda|
expressions) as well as data. Function slots can be executed by using the \verb|send|
function

\subsubsection{(send \emph{frame} \emph{slot-name} \emph{arg}\ldots{})}

\subsubsection{(\emph{slot-name}\textgreater{} \emph{frame}  \emph{arg}\ldots{})}

\begin{verbatim}
(define f {
  add: (lambda () (+ 1 2))
})
(send f add:) ⇒ 3
(add:> f) ⇒ 3
\end{verbatim}

As expected, parameters are supported:

\begin{verbatim}
(define f {
  add: (lambda (x) (+ 1 x))
})
(send f add: 2) ⇒ 3
\end{verbatim}

In the body of a function, slots can be refrenced like normal variables. To do so, simply omit
the trailing colon:

\begin{verbatim}
(define f {
  a: 3
  add: (lambda (x) (+ a x))
})
(send f add: 2) ⇒ 5
\end{verbatim}

Likewise, functions in the frame (or parent frames) can be referred to directly by name.

\begin{verbatim}
(define f {
  a: 5
  b: 2
  foo: (lambda (x) (+ x a))
  bar: (lambda () (foo b))
})
(send f bar:) ⇒ 7
\end{verbatim}

Bindings defined in the local environment (e.g. by a \verb|let| form) hide frame slots of
the same name. In the following, \verb|let| overrides the \verb|a:| slot by introducing a
local binding for \verb|a|.

\begin{verbatim}
(let ((f {a: 42})
      (g {
         parent*: f  
         foo: 
           (lambda ()
             (let ((a 10))
             (+ 1 a)))
      }))
(send g foo:) ⇒ 11
\end{verbatim}

Of course the end game of all this is to be able to inherit functions from parent frames:

\begin{verbatim}
(define f {
  a: 5
  foo: (lambda (x) (+ x a))
})
(define g {
  parent*: f
  b: 2
  bar: (lambda () (foo b))
})
(send g bar:) ⇒ 7
\end{verbatim}

Notice that we’ve been saying parent \textbf{frames}, i.e. plural. Also note that parent slot
names are arbitrary and for documentation purposes only. A frame can have any number of
parents. When a slot is looked for, the explictily specified frame is searched first,
recursively followed by parent frames in a nondeterministic order until a matching slot is
found. If none are found, the result is nil.

\begin{verbatim}
(define e {a: 5})
(define f {b: 2})
(define g {
  parent-e*: e
  parent-f*: f
  foo: (lambda (x) (+ x a))
  bar: (lambda () (foo b))}))
(send g bar:)       ⇒ 7
(set-slot! g a: 10)
(get-slot g a:)     ⇒ 10
(get-slot e a:)     ⇒ 5
\end{verbatim}

When you set a slot with parent frames involved, if the slot is found in the explicit frame
it’s value is set and the new value is returned. If it doesn’t exist in the explicit frame, it
gets created there. This new slot now hides any slots in a parent with the same name.

\subsubsection{(send-super \emph{slot-name} \emph{arg}\ldots{})}

\subsubsection{(\emph{slot-name}\^{} \emph{arg}\ldots{})}

Like \verb|send|, but sends to the first parent that has the named slot.
\textbf{\texttt{send-super} can only be used from within a function slot.}

\subsubsection{(apply-slot \emph{frame} \emph{slot-name} \emph{sexpr}\ldots{})}

Apply the function that results from evaluating the function in slot \emph{slot-name} of
\emph{frame} to the argument list resulting from evaluating each \emph{sexpr}.

Each initial \emph{sexpr} can evaluate to any type of object, but the final one (and there
must be at least one \emph{sexpr}) must evaluate to a list.

\begin{verbatim}
(define f {
  foo: 
    (lambda (x y z) 
      (+ 1 x y z))
})
(apply-slot f foo: 2 '(3 4)) ⇒ 10
(apply-slot f foo: '(2 3 4)) ⇒ 10
\end{verbatim}

\subsubsection{(apply-slot-super \emph{slot-name} \emph{sexpr}\ldots{})}

Like \verb|apply-slot|, but sends to the first parent that has the named slot.
\textbf{\texttt{apply-slot-super} can only be used from within a function slot.}

\subsection{Dynamic inheritence}\label{sec:dynamic-inheritence}

Parent slots are slots like any other and can have their values changed at any time. This
ability is somewhat unusual for those with a heavy OO background but can be very useful for
changing behavior on the fly. A prime example of this is the implimentation of a state
machine. The functions for each state can be placed in different frames and transitions can
modify the slot contaiing that state behavior.

Here’s an example of this.

\begin{verbatim}
(define state {
  name: ""
  enter: (lambda ())
  halt: (lambda ())
  set-speed: (lambda (s))
  halt: (lambda ())
  transition-to: 
    (lambda (s)
      (set! state* s)
      (enter))
})

(define stop-state {
  name: "stop"
  parent*: state
  enter: 
    (lambda ()
      (set! speed 0)
      (transition-to idle-state))
})

(define idle-state {
  name: "idle"
  parent*: state
  set-speed: 
    (lambda (s)
      (set! speed s)
      (transition-to start-state))
})

(define start-state {
  name: "start"
  parent*: state
  halt: 
    (lambda ()
      (transition-tostop-state))
  set-speed: 
    (lambda (s)
      (set! speed s)
      (transition-to change-speed-state))
})

(define change-speed-state {
  name: "change-speed"
  parent*: state
  halt: 
    (lambda ()
      (transition-to stop-state))
  set-speed: 
    (lambda (s)
      (set! speed s))
})

(define motor {
  speed: 0
  state*: state
  start: 
    (lambda () 
      (transition-to stop-state))
})
\end{verbatim}

Now you can do things like the following:

\begin{verbatim}
(send motor start:)
motor ⇒ {speed: 0 state*: {name: "idle" ...}}
(send motor set-speed: 10)
motor ⇒ {speed: 10 state*: {name: "start" ...}}
(send motor set-speed: 20)
motor ⇒ {speed: 20 state*: {name: "change-speed" ...}}
(send motor set-speed: 15)
motor ⇒ {speed: 15 state*: {name: "change-speed" ...}}
(send motor halt:)
motor ⇒ {speed: 0 state*: {name: "idle" ...}}
\end{verbatim}

\subsection{Json support}\label{sec:json-support}

GoLisp has built-in support for converting between stringified Json and frames, according to
the following rules:

\begin{itemize}
\item numbers and strings map directly in both directions
\item frames recursively map to objects, and the reverse
\item lists recursively map to arrays, and the reverse
\item frame slots names map to string field names, and the reverse
\item function slots \textbf{do not} get mapped to json
\item parent slots \textbf{DO not} get mapped to json
\end{itemize}

\subsubsection{(json-\textgreater{}lisp \emph{string})}

\begin{verbatim}
(json->lisp "{'key': [1, 2, 3]}") ⇒ {key: (1 2 3)}
\end{verbatim}

\subsubsection{(lisp-\textgreater{}json \emph{frame})}

\begin{verbatim}
(lisp->json {key: (1 2 3)}) ⇒ "{'key': [1, 2, 3]}"
\end{verbatim}

\section{Miscellaneous Datatypes}\label{sec:miscellaneous-datatypes}

\subsection{Booleans}\label{sec:booleans}

The ``boolean objects'' are ``true'' and ``false''. The boolean constant true is written as
\verb|#t|, and the boolean constant false is written as \verb|#f|.

The primary use for boolean objects is in the conditional expressions \verb|if|,
\verb|cond|, \verb|and|, and \verb|or|; the behavior of these expressions is determined
by whether objects are true or false. These expressions count only \verb|#f| as false. They
count everything else, including \verb|#t|, pairs, symbols, numbers, strings, vectors, and
procedures as true.

Boolean constants evaluate to themselves, so you don't need to quote them.

\begin{verbatim}
 #t                                      ⇒  #t
 #f                                      ⇒  #f
 '#f                                     ⇒  #f
 t                                       ERROR Unbound variable
\end{verbatim}

\subsubsection{false}

\subsubsection{true}

These variables are bound to the objects \verb|#f| and \verb|#t| respectively.

Note that the symbol \verb|true| is not equivalent to \verb|#t|, and the symbol
\verb|false| is not equivalent to \verb|#f|.

\subsubsection{(boolean? \emph{object})}

Returns \verb|#t| if \emph{object} is either \verb|#t| or \verb|#f|; otherwise
returns \verb|#f|.

\begin{verbatim}
(boolean? #f)                           ⇒  #t
(boolean? 0)                            ⇒  #f
\end{verbatim}

\subsubsection{(not \emph{object})}

\subsubsection{(false? \emph{object})}

These procedures return \verb|#t| if \emph{object} is false; otherwise they return
\verb|#f|. In other words they \emph{invert} boolean values. These two procedures have
identical semantics; their names are different to give different connotations to the test.

\begin{verbatim}
(not #t)                                ⇒  #f
(not 3)                                 ⇒  #f
(not (list 3))                          ⇒  #f
(not #f)                                ⇒  #t
\end{verbatim}

\subsubsection{(boolean=? \emph{obj1} \emph{obj2})}

This predicate is true iff \emph{obj1} and \emph{obj2} are either both true or both false.

\subsubsection{(boolean/and \emph{object}\ldots{})}

This procedure returns \verb|#t| if none of its arguments are \verb|#f|.
Otherwise it returns \verb|#f|.

\subsubsection{(boolean/or \emph{object}\ldots{})}

This procedure returns \verb|#f| if all of its arguments are \verb|#f|.
Otherwise it returns \verb|#t|.

\subsection{Symbols}\label{sec:symbols}

Unlike MIT/GNU Scheme, GoLisp only provides one type of symbol: ``interned''. Interned symbols
are far more common than uninterned symbols, and there are more ways to create them. We
decided that uninterned symbols were not necessary for our uses. Throughtout this document
``symbol'' means ``interned symbol''

Symbols have an extremely useful property: any two symbols whose names are the same, in the
sense of \verb|string=?|, are the same object (i.e. they are \verb|eq?| to one another).
The term ``interned'' refers to the process of ``interning'' by which this is accomplished.

The rules for writing an symbol are the same as the rules for writing an identifier. Any
symbol that has been returned as part of a literal expression, or read using the \verb|read|
procedure and subsequently written out using the \verb|write| procedure, will read back in
as the identical symbol (in the sense of \verb|eq?|).

Usually it is also true that reading in an symbol that was previously written out produces the
same symbol. An exception are symbols created by the procedures
\verb|string->symbol| and \verb|intern|; they can create symbols for which
this write/read invariance may not hold because the symbols' names contain special characters.

\subsubsection{(symbol? \emph{object})}

Returns \verb|#t| if \emph{object} is a symbol, otherwise returns \verb|#f|.

\begin{verbatim}
(symbol? 'foo)                                  ⇒  #t
(symbol? (car '(a b)))                          ⇒  #t
(symbol? "bar")                                 ⇒  #f
\end{verbatim}

\subsubsection{(symbol-\textgreater{}string \emph{symbol})}

Returns the name of \emph{symbol} as a string. If \emph{symbol} was returned by
\verb|string->symbol|, the value of this procedure will be identical (in the
sense of \verb|string=?|) to the string that was passed to
\verb|string->symbol|. Unlike MIT/GNU Scheme, the result of
\verb|symbol->string| is not converted to lower case.

\begin{verbatim}
(symbol->string 'flying-fish)           ⇒  "flying-fish"
(symbol->string 'Martin)                ⇒  "Martin"
(symbol->string (string->symbol "Malvina"))
                                        ⇒  "Malvina"
\end{verbatim}

\subsubsection{(intern \emph{string})}

Returns the symbol whose name is \emph{string}. This is the preferred way to create symbols,
as it guarantees the following independent of which case the implementation uses for symbols'
names:

\begin{verbatim}
(eq? 'bitBlt (intern "bitBlt")) ⇒     #t
\end{verbatim}

The user should take care that \emph{string} obeys the rules for identifiers, otherwise the
resulting symbol cannot be read as itself.

\subsubsection{(string-\textgreater{}symbol \emph{string})}

Returns the interned symbol whose name is \emph{string}. Although you can use this procedure
to create symbols with names containing special characters, it's usually a bad idea to create
such symbols because they cannot be read as themselves. See
\verb|symbol->string|.

\begin{verbatim}
(eq? 'mISSISSIppi 'mississippi)         ⇒  #t
(string->symbol "mISSISSIppi")
     ⇒  the symbol with the name "mISSISSIppi"
(eq? 'bitBlt (string->symbol "bitBlt")) ⇒  #t
(eq? 'JollyWog
      (string->symbol
        (symbol->string 'JollyWog)))    ⇒  #t
(string=? "K. Harper, M.D."
           (symbol->string
             (string->symbol
               "K. Harper, M.D.")))     ⇒  #t
\end{verbatim}

\subsubsection{(gensym [\emph{prefix}])}

Create a new, unique symbol made from the \emph{prefix} (or \verb|GENSYM| if a prefix is
omitted) and an increasing integer. This is useful when you are generating code and need a
unique name (in a macro, for example).

\begin{verbatim}
(gensym)      ⇒ GENSYM1
(gensym)      ⇒ GENSYM2
(gensym)      ⇒ GENSYM3

(gensym "hi") ⇒ hi1
(gensym "ho") ⇒ ho1
(gensym "hi") ⇒ hi2
(gensym "ho") ⇒ ho2
(gensym "ho") ⇒ ho3
(gensym "hi") ⇒ hi3

(gensym)      ⇒ GENSYM4
\end{verbatim}

\subsubsection{(symbol\textless{}? \emph{symbol1} \emph{symbol2})}

This procedure computes a total order on symbols. It is equivalent to

\begin{verbatim}
(string<? (symbol->string symbol1)
          (symbol->string symbol2))
\end{verbatim}

\subsection{Bytearrays}\label{sec:bytearrays}

Bytearrays are an extension that GoLisp makes to Scheme arising from the need to implement
byte level communication protocols for SteelSeries Engine 3.

\subsubsection{(list-\textgreater{}bytearray \emph{list of bytes and/or bytearrays})}

The list must be comprised of elements that are either numbers between 0 and 255, inclusive,
or existing bytearray objects. The result is an \emph{object} containing a \verb|[]byte|.

\begin{verbatim}
(list->bytearray '(1 2 3 4))     ⇒ [1 2 3 4]
(list->bytearray '(1 [2 3] 4))   ⇒ [1 2 3 4]
(list->bytearray '([1 2] [3 4])) ⇒ [1 2 3 4]
\end{verbatim}

\subsubsection{(bytearray-\textgreater{}list \emph{bytearray})}

This is the opposite of the previous function. The result is a list containing the numbers in
the bytearray.

\begin{verbatim}
(bytearray->list [1 2 3 4]) ⇒ (1 2 3 4)
\end{verbatim}

\subsubsection{(replace-byte \emph{bytearray} \emph{index} \emph{value})}

Makes a copy of \emph{bytearray} and replaces the byte at \emph{index} with \emph{value}. The
new bytearray with the replaced byte is returned. \emph{index} must be a valid index into the
byte array (zero based), and \emph{value} must be a valid byte value, i.e. between 0 and 255,
inclusive.

\begin{verbatim}
(define a [1 2 3 4])    ⇒ [1 2 3 4]
(replace-byte a 2 100)  ⇒ [1 2 100 4]
a                       ⇒ [1 2 3 4]
\end{verbatim}

\subsubsection{(replace-byte! \emph{bytearray} \emph{index} \emph{value})}

Replaces the byte at \emph{index} with \emph{value}. \emph{index} must be a valid index into
the byte array (zero based), and \emph{value} must be a valid byte value, i.e. between 0 and
255, inclusive. The original byte array is modified and the returned bytearray object is the
one that is passed to the function.

\begin{verbatim}
(define a [1 2 3 4])    ⇒ [1 2 3 4]
(replace-byte! a 2 100) ⇒ [1 2 100 4]
a                       ⇒ [1 2 100 4]
\end{verbatim}

\subsubsection{(extract-byte \emph{bytearray} \emph{index})}

Fetch and return the byte at \emph{index}. \emph{index} must be a valid index into the byte
array (zero based).

\begin{verbatim}
(extract-byte [1 2 3 4] 2) ⇒ 3
\end{verbatim}

\subsubsection{(append-bytes \emph{bytearray} \emph{byte}\ldots{})}

\subsubsection{(append-bytes \emph{bytearray} \emph{list of bytes})}

\subsubsection{(append-bytes \emph{bytearray} \emph{bytearray}\ldots{})}

Appends the rest of the arguments to a copy of the bytearray that is the first arg. The copy
is returned. Things that can be appended are: a single byte, a sequence of bytes (as a
sequence of separate arguments), a list of bytes, a bytearray object, a sequence of bytearray
objects (as a sequence of separate arguments), and code that evaluates to a byte, list of
bytes, or bytearray.

\begin{verbatim}
(append-bytes [1 2 3] 4)            ⇒ [1 2 3 4]
(append-bytes [1 2 3] 4 5 6)        ⇒ [1 2 3 4 5 6]
(append-bytes [1 2 3] '(4 5 6))     ⇒ [1 2 3 4 5 6]
(append-bytes [1 2 3] [4 5 6])        ⇒ [1 2 3 4 5 6]
(append-bytes [1 2 3] [4 5] [6])      ⇒ [1 2 3 4 5 6]
(append-bytes [1 2 3] (list 4 5 6))  ⇒ [1 2 3 4 5 6]
\end{verbatim}

\subsubsection{(append-bytes! \emph{bytearray} \emph{byte}\ldots{})}

\subsubsection{(append-bytes! \emph{bytearray} \emph{list of bytes})}

\subsubsection{(append-bytes! \emph{bytearray} \emph{bytearray}\ldots{})}

As with \verb|append-bytes|, but modifies and returns \emph{bytearray} rather than making a
copy.

\begin{verbatim}
(define a [1 2 3])  ⇒ [1 2 3]
(append-bytes a 4)  ⇒ [1 2 3 4]
a                   ⇒ [1 2 3]
(append-bytes! a 4) ⇒ [1 2 3 4]
a                   ⇒ [1 2 3 4]
\end{verbatim}

\subsubsection{(take \emph{k} \emph{bytearray})}

As with the list implementation of \verb|take|, fetches and returns a new bytearray
consisting of the bytes from \emph{bytearray} starting at index \emph{k}.

\begin{verbatim}
(take 1 [1 2 3] ⇒ [1])
(take 3 [1 2 3] ⇒ [1 2 3])
\end{verbatim}

\subsubsection{(drop \emph{k} \emph{bytearray})}

\begin{verbatim}
(drop 1 [1 2 3] ⇒ [2 3])
(drop 2 [1 2 3] ⇒ [3])
\end{verbatim}

As with the list implementation of \verb|drop|, fetches and returns a new bytearray
consisting of the bytes from \emph{bytearray} prior to index \emph{k}.

\subsubsection{(extract-bytes \emph{bytearray} \emph{index} \emph{length})}

Returns a new bytearray consisting of \emph{length} bytes from \emph{bytearray}, starting at
index \emph{index}. This is functionally equivalent to
\verb|(take length (drop index bytearray))| with bounds checking added.

\begin{verbatim}
(extract-bytes [1 2 3 4 5] 0 1) ⇒ [1]
(extract-bytes [1 2 3 4 5] 0 3) ⇒ [1 2 3]
(extract-bytes [1 2 3 4 5] 2 1) ⇒ [3]
(extract-bytes [1 2 3 4 5] 2 3) ⇒ [3 4 5]
\end{verbatim}

\section{Environments}\label{sec:environments}

Scheme (and thus GoLisp) is lexically scoped. This is implemented by the creation of a lexical
environment (aka symbol table) for each lexical scope:

\begin{itemize}
\item function/lambda/macro invocations, which holds parameters and any local
definitions
\item \verb|let| structures, which hold the \verb|let| bindings
\item \verb|do| structures, which hold the \verb|do| bindings
\end{itemize}

Functions and lambdas capture a reference to the environment in which they were defined, so
they always have access to it's bindings (that's a closure, btw).

Each environment has a connection to it's containing environment, and can override/hide
bindings in outer scopes. When a symbol is evaluated, the most local environment is searched
first. If a binding for the system isn't found there, the containing environment is searched.
This continues until a binding for the sybol is found or we go all the way to the global
environment and still can't find a binding.

Section 3.2 of [1] does a great job of explaining environments in Scheme, which is the basis
for environments in GoLisp.

In Scheme, some environments are more important than others, mainly as they tend to be larger,
long lived, and serve as the root of many other environments as a program runs. These are
known as \emph{top level environments}. Specifially, these are the global environment (the
only environment that is contained by nothing), and any environments directly below it in the
environment tree. The REPL runs in one such environment, which effectively sandboxes it,
protecting the bindings in the global environment from corruption.

\subsubsection{(environment? \emph{object})}

Returns \verb|#t| if \emph{object} is an environment; otherwise returns \verb|#f|.

\subsubsection{(environment-has-parent? \emph{environment})}

Returns \verb|#t| if \emph{environment} has a parent environment; otherwise returns
\verb|#f|.

\subsubsection{(environment-parent \emph{environment})}

Returns the parent environment of \emph{environment}. It is an error if \emph{environment} has
no parent.

\subsubsection{(environment-bound-names \emph{environment})}

Returns a newly allocated list of the names (symbols) that are bound by \emph{environment}.
This does not include the names that are bound by the parent environment of
\emph{environment}. It does include names that are unassigned or keywords in
\emph{environment}.

\subsubsection{(environment-macro-names \emph{environment})}

Returns a newly allocated list of the names (symbols) that are bound to syntactic keywords in
\emph{environment}.

\subsubsection{(environment-bindings \emph{environment})}

Returns a newly allocated list of the bindings of \emph{environment}; does not
include the bindings of the parent environment. Each element of this list takes
one of two forms: \verb|(symbol)| indicates that \emph{symbol} is bound but unassigned,
while \verb|(symbol object)| indicates that \emph{symbol} is bound, and its value is
\verb|object|.

\subsubsection{(environment-reference-type \emph{environment} \emph{symbol})}

Returns a symbol describing the reference type of \emph{symbol} in \emph{environment} or one
of its ancestor environments. The result is one of the following:

\begin{itemize}
\item \verb|normal| means \emph{symbol} is a variable binding with a normal value.
\item \verb|unassigned| means \emph{symbol} is a variable binding with no value.
\item \verb|macro| means \emph{symbol} is a keyword binding.
\item \verb|unbound| means \emph{symbol} has no associated binding.
\end{itemize}

\subsubsection{(environment-bound? \emph{environment} \emph{symbol})}

Returns \verb|#t| if \emph{symbol} is bound in \emph{environment} or one of its ancestor
environments; otherwise returns \verb|#f|. This is equivalent to

\begin{verbatim}
(not (eq? ’unbound
          (environment-reference-type environment symbol)))
\end{verbatim}

\subsubsection{(environment-assigned? \emph{environment} \emph{symbol})}

Returns \verb|#t| if \emph{symbol} is bound in \emph{environment} or one of its ancestor
environments, and has a normal value. Returns \verb|#f| if it is bound but unassigned.
Signals an error if it is unbound or is bound to a keyword.

\subsubsection{(environment-lookup \emph{environment} \emph{symbol})}

\emph{symbol} must be bound to a normal value in \emph{environment} or one of its ancestor
environments. Returns the value to which it is bound. Signals an error if unbound, unassigned,
or a keyword.

\subsubsection{(environment-lookup-macro \emph{environment} \emph{symbol})}

If \emph{symbol} is a keyword binding in \emph{environment} or one of its ancestor
environments, returns the value of the binding. Otherwise, returns \verb|#f|. Does not
signal any errors other than argument-type errors.

\subsubsection{(environment-assignable? \emph{environment} \emph{symbol})}

\emph{symbol} must be bound in \emph{environment} or one of its ancestor environments. Returns
\verb|#t| if the binding may be modified by side effect.

\subsubsection{(environment-assign! \emph{environment} \emph{symbol} \emph{value})}

\emph{symbol} must be bound in \emph{environment} or one of its ancestor environments, and
must be assignable. Modifies the binding to have \emph{value} as its value, and returns an
unspecified result.

\subsubsection{(environment-definable? \emph{environment} \emph{symbol})}

Returns \verb|#t| if \emph{symbol} is definable in \emph{environment}, and \verb|#f|
otherwise.

\subsubsection{(environment-define \emph{environment} \emph{symbol} \emph{value})}

Defines \emph{symbol} to be bound to object in \emph{environment}, and returns an unspecified
value. Signals an error if \emph{symbol} isn’t definable in \emph{environment}.

\subsubsection{(eval \emph{sexpr} \emph{environment})}

Evaluates \emph{sexpr} in \emph{environment}. You rarely need eval in ordinary programs; it is
useful mostly for evaluating expressions that have been created “on the fly” by a program.

\subsubsection{(system-global-environment)}

The function \verb|system-global-environment| is returns the distinguished environment
that’s the highest level ancestor of all other environments. It is the parent environment of
all other top-level environments. Primitives, system procedures, and most syntactic keywords
are bound in this environment.

\subsubsection{(the-environment)}

Returns the current environment. This form may only be evaluated in a top-level environment.
An error is signalled if it appears elsewhere.

\subsubsection{(procedure-environment \emph{procedure})}

Returns the closing environment of \emph{procedure}. Signals an error if \emph{procedure} is a
primitive procedure.

\subsubsection{(make-top-level-environment [\emph{names} [\emph{values}]])}

Returns a newly allocated top-level environment. extend-top-level-environment creates an
environment that has parent environment, make-top-level-environment creates an environment
that has parent system-global-environment, and make- root-top-level-environment creates an
environment that has no parent.

The optional arguments \emph{names} and \emph{values} are used to specify initial bindings in
the new environment. If specified, \emph{names} must be a list of symbols, and \emph{values}
must be a list of objects. If only \emph{names} is specified, each name in \emph{names} will
be bound in the environment, but unassigned. If \emph{names} and \emph{values} are both
specified, they must be the same length, and each name in \emph{names} will be bound to the
corresponding value in \emph{values}. If neither \emph{names} nor \emph{values} is specified,
the environment will have no initial bindings.

Environments in GoLisp differ slightly from standard Scheme in that they have a name attached.
For the various forms of \verb|let| and \verb|do| this is simply \verb|"let"| and
\verb|"do"|, respectively. Not of much use, but then these are just a byproduct of having
lexical scopes. What's more useful is the higher level environments. This brings us to the
real reason for adding environment support: game integration sandboxes. When we were writing
the game integration functionallity for Engine3, we wanted each game's event handling to live
in a separate sandbox. This is implemented buy creating a new top level environment under the
global environment. The problem here is that it's off in it's own world, separate from the
repl. By naming environments (in this case by the name of the game), we can add a function to
return an environment given it's name. That allows us to peek inside the sandbox from the
repl, examining and manipulating the bindings there. And so we added a function to let us do
that:

\subsubsection{(find-top-level-environment \emph{name})}

Returns the top level environment with the given name.

\section{Utility}\label{sec:utility}

GoLisp provides a handful of utility functions.

\subsubsection{(random-byte)}

Returns a psuedo-random unsigned integer between 0 and 255, inclusive.

\begin{verbatim}
(random-byte) ⇒ 13
(random-byte) ⇒ 207
\end{verbatim}

\subsubsection{(random)}

The return value is a pseudorandom integer in the range [0, 2,147,483,647]

\subsubsection{(random \emph{modulus})}

\emph{Modulus} must be a positive real number. If \emph{modulus} is an integer,
\verb|random| returns a pseudo-random number between zero (inclusive) and \emph{modulus}
(exclusive). If \emph{modulus} is the float 1.0, the returned number is a float in the range
[0.0, 1.0). Other float values of \emph{modulus} are rejected.

\subsubsection{(sleep \emph{millis})}

Sleep for \emph{millis} milliseconds.

\begin{verbatim}
(sleep 1000)  ;; resumes execution 1 second later
\end{verbatim}

\subsubsection{(time \emph{expression}\ldots{})}

Evaluates each \emph{expression} and reports the number of milliseconds taken to do so.

\subsubsection{(write-line \emph{object}\ldots{})}

Writes the concatenation of the string forms of \emph{objects} followed by a newline.

\begin{verbatim}
> (write-line "Hello, " 42 " world")
Hello, 42 world
=⇒ ()
\end{verbatim}

\subsubsection{(str \emph{object}\ldots{})}

If you provide multiple arguments to \verb|str| it creates a string from
concatenating the string forms of all the \emph{objects}.

\begin{verbatim}
(str 1 "." 2) ⇒ "1.2"
\end{verbatim}

\subsubsection{(copy \emph{object})}

Make a copy of the result of evaluating \emph{object}, IFF it’s mutable. This is limited to
lists and association lists. All other values are immutable. Copying an immutable item will
return the item, whereas copying a list or association list will make a deep copy of the
structure, and return it.

\subsubsection{(exec \emph{command} \emph{arg}\ldots{})}

Makes an operating system call. \verb|command| is the command to execute and the
\verb|arg|s are the arguments passed on the command line to \verb|command|.
\verb|command| must be a string, and the \verb|arg|s can be anything.

\section{Concurrency}\label{sec:concurrency}

GoLisp has limited concurrency support that is built on top of goroutines and channels.

\subsection{Process management}\label{sec:process-management}

These functions make use of a \emph{process} object. This is an opaque piece of data that
wraps a custom structure used by the concurrency code; it is returned from \verb|fork| and
\verb|schedule| and is used by \verb|proc-sleep|, \verb|wake|, and \verb|abandon| to
interact with the underlying goroutine.

\subsubsection{(fork \emph{function})}

Executes \emph{function} in a separate goroutine. When \emph{function} ends, the goroutine
terminates. \emph{function} takes a single argument which is the process object that is
returned.

\begin{verbatim}
(define (run-once proc)
  (write-line "start")
  (sleep 1000)
  (write-line "stop"))

(fork run-once)

> start
[a second goes by]
stop
[run-once completes and the goroutine terminates]
\end{verbatim}

\subsubsection{(proc-sleep \emph{process} \emph{millis})}

Use \verb|proc-sleep| in a forked function to sleep for \emph{millis} milliseconds. Using
\verb|proc-sleep| rather than \verb|sleep| (which can be used) allows code in another
process (that has a reference to the process object of the forked code) to preemptively
terminate the sleep using the \verb|wake| function.

\verb|proc-sleep| returns a boolean that indicates whether the sleep was terminated using
\verb|wake|.

\subsubsection{(wake \emph{process})}

Preemptively terminate a \verb|proc-sleep| in the code associated with \emph{process}.

\begin{verbatim}
> (define (run proc)
    (do ((woken #f woken))
        (woken (write-line "woken"))
      (write-line "tick")
      (set! woken (proc-sleep proc 10000))))

> (define p (fork run))

tick
tick
[times goes by, tick is printed every 10 seconds]
> (wake p)
woken
[run completes and the goroutine terminates]
\end{verbatim}

\subsubsection{(join \emph{process})}

Blocks the calling function until the process completes or aborts with an error. The return
value of the process is returned, or nil if the process ran into an error and aborted.
Attempting to call \verb|join| on a process twice raises an error.

\begin{verbatim}
(define (run proc) '(1 2 3))
(define p (fork run))
(join p) ⇒ (1 2 3)
\end{verbatim}

\subsubsection{(schedule \emph{millis} \emph{function})}

Schedule \emph{function} to be evaluated in a separate goroutine \emph{millis} milliseconds
from now. \emph{function} takes a single argument which is the process object that is
returned. The process object associated with that goroutine is returned immediately.

\begin{verbatim}
> (define (run-delayed proc)
    (write-line "running"))

> (schedule 10000 run-delayed)
[10 seconds pass]
running
[run-delayed completes and the goroutine terminates]
\end{verbatim}

\subsubsection{(abandon \emph{process})}

Cancels the scheduled evaluation associated with \emph{process}.

\begin{verbatim}
> (define (run-delayed proc)
    (write-line "running"))

> (define p (schedule 10000 run-delayed))
[5 seconds pass]
> (abandon p)
[the delay is cancelled and the goroutine terminates]
\end{verbatim}

\subsubsection{(reset-timeout \emph{process})}

Resets the timer on a scheduled process. Causing it to start over. You can use this function
to postpone the evaluation of scheduled code.

\begin{verbatim}
> (define (run-delayed proc)
    (write-line "running"))

> (define p (schedule 10000 run-delayed))
[less than 10 seconds pass]
> (reset-timeout p)
[10 seconds pass]
running
[run-delayed completes and the goroutine terminates]
\end{verbatim}

\subsection{Atomic Operations}\label{sec:atomic-operations}

GoLisp has support for several kinds of atomic operations. These can be useful for protecting
memory when working with GoLisp code with concurrent processes, or just Go code with multiple
goroutines.

These functions make use of a \emph{atomic} object. This is an opaque piece of data that wraps
an integer; it is returned from \verb|atomic| and is used by all the \verb|atomic-*|
primitives to interact with the underlying integer using only atomic operations.

\subsubsection{(atomic [\emph{value}])}

Creates a new \emph{atomic} object and returns it. It can optionally be passed a starting
value to initialize to. Otherwise, the starting value is 0.

\begin{verbatim}
> (atomic)   ⇒ <atomic object with value 0>
> (atomic 5) ⇒ <atomic object with value 5>
\end{verbatim}

\subsubsection{(atomic-load \emph{atomic})}

Loads the current integer value of the \emph{atomic} object and returns it as an integer.

\begin{verbatim}
> (define a (atomic 5))
> (atomic-load a) ⇒ 5
\end{verbatim}

\subsubsection{(atomic-store! \emph{atomic} \emph{new})}

Stores a new integer value in a \emph{atomic} object.

\begin{verbatim}
> (define a (atomic 5))
> (atomic-store! a 8)
> (atomic-load a) ⇒ 8
\end{verbatim}

\subsubsection{(atomic-add! \emph{atomic} \emph{delta})}

Adds the \emph{delta} value to the one stored in the \emph{atomic} object. The new sum is also
returned.

\begin{verbatim}
> (define a (atomic 5))
> (atomic-add! a 4) ⇒ 9
> (atomic-load a)   ⇒ 9
\end{verbatim}

\subsubsection{(atomic-swap! \emph{atomic} \emph{new})}

Swaps the value currently in the \emph{atomic} object with a new value. The old value is
returned.

\begin{verbatim}
> (define a (atomic 5))
> (atomic-swap! a 4) ⇒ 5
> (atomic-load a)    ⇒ 4
\end{verbatim}

\subsubsection{(atomic-compare-and-swap! \emph{atomic} \emph{old} \emph{new})}

The value in the \emph{atomic} object is compared to \emph{old}. If the value matches, the
value in the \emph{atomic} object is swapped with the value in \emph{new} and true is
returned. Otherwise, the values are not swapped and false is returned.

\begin{verbatim}
> (define a (atomic 5))
> (atomic-compare-and-swap! a 5 4) ⇒ #t
> (atomic-load a)                  ⇒ 4

> (define b (atomic 5))
> (atomic-compare-and-swap! b 9 4) ⇒ #f
> (atomic-load b)                  ⇒ 5
\end{verbatim}

\subsection{Channels}\label{sec:channels}

Channels are the main way you communicate between goroutines in Go. GoLisp has full support of
channels.

\subsubsection{(make-channel [\emph{buffer-size}])}

Creates a new channel object with an optional buffer size. If \emph{buffer-size} is omitted or
0, the channel is unbuffered.

\subsubsection{(channel-write \emph{channel} \emph{value})}

\subsubsection{(\emph{channel}\textless{}- \emph{value})}

Writes a value to a channel. If the channel is unbuffered or has a full buffer, this call
locks until there either another process tries to read from the channel or room is made in the
buffer.

\subsubsection{(channel-read \emph{channel})}

\subsubsection{(\textless{}-\emph{channel})}

Reads a value from a channel. If the channel is unbuffered or has no buffered data, this call
locks until there is data in the channel. \verb|<-channel| returns two values. The
first value is the data read from the channel. The second value is a boolean flag stating
whether there is more data in the channel. If the channel is closed and there are no more
items left in the buffer, a false flag is returned. Otherwise, a true flag is returned. If a
flag of false is returned, the first value will also be nil.

\begin{verbatim}
> (define c (make-channel 1))
> (channel-write c 1)
> (c<- 1) ; alternate syntax for the previous line
> (channel-read c) ⇒ (1 #t)
> (<-c)            ⇒ (1 #t) ; alternate syntax for the previous line
> (channel-read c) ; blocks until another process writes to c
\end{verbatim}

\subsubsection{(channel-try-write \emph{channel} \emph{value})}

Tries to write a value to a channel. If the channel is unbuffered with nobody waiting for a
write or has a full buffer, it returns immediately a false value. Otherwise, it writes the
value to the channel and returns a true value.

\begin{quote}
(define c (make-channel 1)
(channel-try-write c 1) ⇒ \#t
\end{quote}

\begin{quote}
(define c (make-channel))
(channel-try-write c 1) ⇒ \#f
\end{quote}

\subsubsection{(channel-try-read \emph{channel})}

Tries to reads a value from a channel. This call returns three values. The first is whether
data could be read or not. The second is the data that is read, or nil if none was. The last
value is whether the channel has more data in it.

\begin{verbatim}
> (define c (make-channel 1))
> (c<- 1)
> (channel-try-read c) ⇒ (#t 1 #t)
> (channel-try-read c) ⇒ (#f () #t)
\end{verbatim}

\subsubsection{(close-channel \emph{channel})}

Closes the specified channel. The channel's buffered is cleared by any other goroutines trying
to read from it then all other reads immediately return with the more flag set to false.
Trying to write to a closed channel or trying to close a channel twice results in an error.

\begin{verbatim}
> (define c (make-channel 1))
> (c<- 1)
> (close-channel c)
> (<-c) ⇒ (1 #t)
> (<-c) ⇒ (() #f)
> (<-c) ⇒ (() #f) ; repeats on subsequent calls
> (channel-try-read c) ⇒ (#t () #f)
\end{verbatim}

\section{Time and Date}
\label{sec:time-date}

All of these date and time function use the local time.

\subsubsection{(time-now)}
\label{sec:time-now}

Return the current local time as a list of the form \verb|(hour minute second)|.

\begin{verbatim}
(time-now) ⇒ (19 53 50)
\end{verbatim}

\subsubsection{(seconds)}
\label{sec:seconds}

Returns the number of seconds since midnight on the current day.

\begin{verbatim}
(seconds) ⇒ 71644
\end{verbatim}

\subsubsection{(millis)}
\label{sec:seconds}

Returns the number of milliseconds since midnight on the current day.

\begin{verbatim}
(millis) ⇒ 71646935
\end{verbatim}

\subsubsection{(date-today)}
\label{sec:date-today}

Return today's date as a list of the form \verb|(year month day)|.

\begin{verbatim}
(date-today) ⇒ (2016 12 19)
\end{verbatim}

\subsubsection{(date-in-days \emph{days})}
\label{sec:date-in-days}

Return the date in \emph{days} days from today as a list of the form \verb|(year month day)|.

\begin{verbatim}
(date-in-days 3) ⇒ (2016 12 22)
\end{verbatim}

\subsubsection{(day-of-week)}
\label{sec:day-of-week}

Returns a symbol representing the current day of the week.

\begin{verbatim}
(day-of-week) ⇒ monday
\end{verbatim}

\section{Timers}\label{sec:timers}

\subsubsection{(timer \emph{millis} \emph{func})}

Schedules \emph{func} (a function of zero arguments) to be evaluated after \emph{millis}
milliseconds. Returns a timer object.

\subsubsection{(stop-timer \emph{timer})}

Stop and cancel the timer \emph{timer}.

\subsubsection{(ticker \emph{millis} \emph{func})}

Schedules \emph{func} (a function of zero arguments) to be evaluated after \emph{millis}
milliseconds and every \emph{millis} milliseconds thereafter until stopped. Returns a ticker
object.

\subsubsection{(stop-ticker \emph{ticker})}

Stop and cancel the ticker \emph{ticker}.

\section{Input/Output}\label{sec:inputoutput}

\subsubsection{(open-input-file \emph{filename})}

Takes a \emph{filename} referring to an existing file and returns an input port capable of
delivering characters from the file.

\subsubsection{(open-output-file \emph{filename} [\emph{append?}])}

Takes a \emph{filename} referring to an output file to be created and returns an output port
capable of writing characters to a new file by that name.

If \emph{append?} is given and not \verb|#f|, the file is opened in append mode. In this
mode, the contents of the file are not overwritten; instead any characters written to the file
are appended to the end of the existing contents. If the file does not exist, append mode
creates the file and writes to it in the normal way.

\subsubsection{(close-port \emph{port})}

Closes \emph{port} and returns an unspecified value. The associated file is also closed.

\subsubsection{(write-bytes \emph{byte-array} \emph{output-port})}

Writes \emph{byte-array} to \emph{output-port} as a stream of raw bytes. Most usefull for
interacting with external devices via serial/usb ports.

\subsubsection{(write-string \emph{string} [\emph{output-port}])}

Writes \emph{string} to \emph{output-port}, performs discretionary output flushing, and
returns an unspecified value.

\subsubsection{(newline [\emph{output-port}])}

Writes an end-of-line to \emph{output-port}, performs discretionary output flushing, and
returns an unspecified value.

\subsubsection{(write \emph{object} [\emph{output-port}])}

Writes a written representation of \emph{object} to \emph{output-port}, and returns an
unspecified value. If \emph{object} has a standard external representation, then the written
representation generated by \verb|write| shall be parsable by \verb|read| into an
equivalent object. Thus strings that appear in the written representation are enclosed in
doublequotes, and within those strings backslash and doublequote are escaped by backslashes.
\verb|write| performs discretionary output flushing and returns an unspecified value.

\subsubsection{(read-string [\emph{input-port}])}

Reads characters from \emph{input-port} until it finds a terminating character or encounters
end of line. The port is updated to point to the terminating character, or to end of line if
no terminating character was found. \verb|read-string| returns the characters, up to but
excluding the terminating character, as a newly allocated string.

\subsubsection{(read [\emph{input-port}])}

Converts external representations of Scheme objects into the objects themselves. read returns
the next object parsable from \emph{input-port}, updating \emph{input-port} to point to the
first character past the end of the written representation of the object. If an end of file is
encountered in the input before any characters are found that can begin an object, read
returns an end-of-file object. The \emph{input-port} remains open, and further attempts to
read will also return an end-of-file object. If an end of file is encountered after the
beginning of an object’s written representation, but the written representation is incomplete
and therefore not parsable, an error is signalled.

\subsubsection{(eof-object? \emph{object})}

Returns \verb|#t| if \emph{object} is an end-of-file object; otherwise returns
\verb|#f|.

\subsubsection{(format \emph{destination} \emph{control-string} \emph{argument}\ldots{})}

Writes the characters of \emph{control-string} to \emph{destination}, except that a tilde
(\verb|~|) introduces a format directive. The character after the tilde,
possibly preceded by prefix parameters and modifiers, specifies what kind of formatting is
desired. Some directives use an \emph{argument} to create their output; the typical directive
puts the next \emph{argument} into the output, formatted in some special way. It is an error
if no \emph{argument} remains for a directive requiring an \emph{argument}.

The output is sent to \emph{destination}. If \emph{destination} is \verb|#f|, a string is
created that contains the output; this string is returned as the value of the call to
\verb|format|. If \emph{destination} is \verb|#t|, the output is sent to \verb|stdout|.
In all other cases \verb|format| returns an unspecified value. Otherwise, destination must
be an output port, and the output is sent there.

A format directive consists of a tilde (\ensuremath{\sim}), an optional prefix parameter, an
optional at-sign (\verb|@|) modifier, and a single character indicating what kind of
directive this is. The alphabetic case of the directive character is ignored. The prefix
parameters are generally integers, notated as optionally signed decimal numbers.

In place of a prefix parameter to a directive, you can put the letter \verb|V| (or
\verb|v|), which takes an argument for use as a parameter to the directive. Normally this
should be an integer. This feature allows variable-width fields and the like. You can also use
the character \verb|#| in place of a parameter; it represents the number of arguments
remaining to be processed.

\verb|~A|: The next argument, which may be any object, is printed as if by
write-line. \verb|~<mincol>A| inserts spaces on the right, if necessary, to
make the width at least \verb|mincol| columns. The \verb|@| modifier causes the spaces to be
inserted on the left rather than the right.

\verb|~S|: The next argument, which may be any object, is printed as if by write (in
as read-able format as possible). \verb|~mincolS| inserts spaces on the
right, if necessary, to make the width at least mincol columns. The \verb|@| modifier causes
the spaces to be inserted on the left rather than the right.

\verb|~%|: This outputs a newline character. This outputs a
\verb|\#newline| character. \verb|~n%| outputs n newlines. No
argument is used. Simply putting a newline in control-string would work, but
\verb|~%| is often used because it makes the control string look nicer in
the middle of a program.

\verb|~~|: This outputs a tilde; \verb|~n~|: outputs n tildes.

\verb|~newline|: Tilde immediately followed by a newline ignores the newline and any
following whitespace characters. With an \verb|@|, the newline is left in place, but any
following whitespace is ignored. This directive is typically used when control-string is too
long to fit nicely into one line of the program:

\begin{verbatim}
(define (type-clash-error procedure arg spec actual)
   (format
    #t
    "~%Procedure ~S~%requires its %A argument ~
     to be of type ~S,~%but it was called with ~
     an argument of type ~S.~%"
    procedure arg spec actual))
(type-clash-error ’vector-ref
                  "first"
                  ’integer
                  ’vector)
\end{verbatim}

prints

\begin{verbatim}
Procedure vector-ref
requires its first argument to be of type integer,
but it was called with an argument of type vector.
\end{verbatim}

Note that in this example newlines appear in the output only as specified by the
\ensuremath{\sim}\% directives; the actual newline characters in the control string are
suppressed because each is preceded by a tilde.

\section{Testing}\label{sec:testing}

Golisp has a builtin testing framework, completely written in GoLisp.

\subsection{Structure}\label{sec:structure}

Contests and it-clauses divide up the testing of a system under test into fixtures and focused
sets of assertions.

\subsubsection{(context \emph{tag-string} \emph{fixture} \emph{it}\ldots{})}

\emph{tag-string} is a string used to identify the context in the test run's output. This
should describe what the context focusses on. \emph{fixture} is a sequence of expressions that
typically add definitions (symbol bindings) to the environment created by \verb|context|.
Each \emph{it} expression (defined using \verb|it|) performs speific tests relevant to the
context.

\subsubsection{(it \emph{tag} \emph{assertion}\ldots{})}

This defines a cohesive block of assertions. The context's fixture code will be run in a new
environment for each \emph{it} block, thus isolating each it.

\subsection{Assertions}\label{sec:assertions}

Assertions are used to make provable (via execution) statements about the system under test.

\subsubsection{(assert-true \emph{expression})}

Passes if \emph{expression} evaluates to a truthy value, fails otherwise.

\subsubsection{(assert-false \emph{expression})}

Passes if \emph{expression} evaluates to a falsy value, fails otherwise.

\subsubsection{(assert-eq \emph{actual} \emph{expected})}

Passes if the result of evaluating \emph{actual} is equal (using
\verb|(equal? actual expected)|) to the result of evaluating \emph{expected}, fails otherwise.

\subsubsection{(assert-neq \emph{actual} \emph{expected})}

Passes if the result of evaluating \emph{actual} is \textbf{not} equal (using
\verb|(not (equal? actual expected))|to the result of evaluating \emph{expected}, fails
otherwise.

\subsubsection{(assert-nil \emph{expression})}

Passes if \emph{expression} evaluates to nil, fails otherwise.

\subsubsection{(assert-not-nil \emph{expression})}

Passes if \emph{expression} evaluates to anything \textbf{other than} nil, fails otherwise.

\subsubsection{(assert-error \emph{expression})}

Passes if evaluating \emph{expression} results in an error being signalled, fails if it
evaluates without problems.

\subsubsection{(assert-nerror \emph{expression})}

Passes if evaluating \emph{expression} does not result in an error being signalled, fails if
it the evaluation signals an error.

\subsection{Usage}\label{sec:usage}

Generally you should create a test file for each feature you are testing. The file is a plain
lisp file and can contain any lisp code, including global variable and function definitions.

For example, here is the test file for scoping:

\begin{verbatim}
(context "environments"

  ((define a 5)
   (define (foo a)
     (lambda (x)
      (+ a x))))

  (it "can access a in the global env"
      (assert-eq a 5))

  (it "gets a from the function's local env"
      (assert-eq ((foo 1) 5) 6)
      (assert-eq ((foo 2) 5) 7)
      (assert-eq ((foo 10) 7) 17)))
\end{verbatim}

Running a test results in a stream of status output for each test, followed at the very end by
a summary. Running the above results in the following:

\begin{verbatim}
environments

  can access a in the global env
    (assert-eq a 5)

  gets a from the function's local env
    (assert-eq ((foo 1) 5) 6)
    (assert-eq ((foo 2) 5) 7)
    (assert-eq ((foo 10) 7) 17)

Ran 4 tests in 0.003 seconds
4 passes, 0 failures, 0 errors
\end{verbatim}

If we introduce a failure, the output would be:

\begin{verbatim}
environments

  can access a in the global env
    (assert-eq a 5)

  gets a from the function's local env
    (assert-eq ((foo 1) 5) 6)
    (assert-eq ((foo 2) 5) 8)
      - expected 8, but was 7
    (assert-eq ((foo 10) 7) 17)

Ran 4 tests in 0.002 seconds
3 passes, 1 failures, 0 errors

Failures:
  environments gets a from the function's local env:
    (assert-eq ((foo 2) 5) 8)
      - expected 8, but was 7
\end{verbatim}

Errors are also reported. Errors are problems that occur while evaluating the clauses, that
aren't failures. Essentially they indicate bugs of some sort.

\begin{verbatim}
environments

  can access a in the global env
    (assert-eq a 5)

  gets a from the function's local env
    (assert-eq ((foo 1) 5) 6)
    ERROR: Quotent: (7 0) -> Divide by zero.

Ran 3 tests in 0.002 seconds
2 passes, 0 failures, 1 errors

Errors:
  environments gets a from the function's local env:
    ERROR: Quotent: (7 0) -> Divide by zero.
\end{verbatim}

The above output was generated by the testing framwork running in verbose mode. You can also
run in quiet mode which only outputs the summary:

\begin{verbatim}
Ran 4 tests in 0.003 seconds
4 passes, 0 failures, 0 errors
\end{verbatim}

You run tests by running the golisp repl in test mode, providing either a directory or
filename. If you provide a directory all files in it that match \verb|*_test.scm| will be
run. If you provide a filename, only that file will be run.

\begin{verbatim}
$golisp -t tests/scope_test.scm

Ran 4 tests in 0.002 seconds
4 passes, 0 failures, 0 errors


$golisp -t tests

Ran 935 tests in 0.273 seconds
935 passes, 0 failures, 0 errors
\end{verbatim}

Adding the \verb|-v| flag will produce the detailed output above.

\section{Extending GoLisp}\label{sec:extending-golisp}

\subsection{Defining primitives}\label{sec:defining-primitives}

The Go function \verb|MakePrimitiveFunction| allows you to create primitive functions.

\begin{verbatim}
MakePrimitiveFunction(name string, argCount string,
                      function func(*Data, *SymbolTableFrame)(*Data, error))
\end{verbatim}

The arguments are:

\begin{enumerate}
\item The function name. This is the name of a symbol which will be used to reference the
  function.
\item An argument count expectation. This is a string that specifies how many arguments the
  primitive expects. It can take several forms:
  \begin{itemize}
  \item A single, specific number. E.g. exactly two: \verb|"2"|
  \item A minimum number. E.g. at least two: \verb|">=2"|
  \item A range of values. E.g. between two and five, inclusive: \verb|"(2,5)"|
  \item One of a selection of the above: E.g.
    \verb?"2|3|>=5"?
  \item An unspecified number, any checking must be done in the primitive definition:
    \verb|"*"|
  \end{itemize}
\item The Go function which implements the primitive. This function \textbf{must} have the
  signature
\begin{verbatim}
 func <Name>(args *Data, env *SymbolTableFrame) (*Data, error)
\end{verbatim}
\end{enumerate}

The implementing function takes two parameters as seen above:

\begin{enumerate}
\item A Lisp list containing the arguments
\item The environment in which the primitive is being evaluated. This is used when calling
  \verb|Eval| or \verb|Apply|, as well as for any symbol lookups or bindings.
\end{enumerate}

Primitives use, like functions defined in LISP, applicative evaluation order. That means that
all arguments are evaluated and the resulting values passed to the function. This frees you
from having to evaluate the arguments and handle errors. You still have to verify the number
of arguments (only if you used -1 as trhe argument cound in the \verb|MakePrimitiveFunction|
call) and their type, if applicable.

\begin{verbatim}
MakeSpecialForm(name string,
                argCount int,
                function func(*Data, *SymbolTableFrame) (*Data, error))
\end{verbatim}

An example:

\begin{verbatim}
MakePrimitiveFunction("!", "1", BooleanNot)

func BooleanNot(args *Data, env *SymbolTableFrame) (result *Data, err error) {
    val := BooleanValue(First(args))
    return BooleanWithValue(!val), nil
 }
\end{verbatim}

You can extend the goLisp runtime without changing any of it's code. You simply import the
golisp package (typically aliased to \verb|.| to make the code less noisy) and place calls
to \verb|MakePrimitiveFunction| in your package's \verb|init| block.

\subsection{Defining primitives with argument type checking}\label{sec:defining-primitives-with-argument-type-checking}

There is also the \verb|MakeTypedPrimitiveFunction| function that takes an additional
argument which is an array of \verb|uint32|s, one element for each argument. If the defined
function accepts an arbitrary number of arguments, the final type specification is used for
the remainder. For example, if there are 3 argument type specifications and the function is
passed 5 arguments, the final specification is used for the 3rd, 4th, and 5th arguments.

\begin{verbatim}
MakeTypedPrimitiveFunction("mqtt/publish", "3", mqttPublishImpl, 
                           []uint32\{StringType, IntegerType, StringType\})
\end{verbatim}

There is not currently a way to provide a type specification for a primitive's return value.

\subsection{Defining special forms}\label{sec:defining-special-forms}

There is another, very similar function that you will typically not need unless you are
hacking on the language itself (as opposed to adding builting functions):

\begin{verbatim}
MakeSpecialForm(name string,
                argCount int,
                function func(*Data, *SymbolTableFrame) (*Data, error))
\end{verbatim}

Arguments and the signature of the implementing function are identical to
\verb|MakePrimitiveFunction|. The only difference is that this defines a \emph{special form}
which uses normal evaluation order. I.e. arguments are not evaluated before calling the
function; the raw sexpressions are passed in. Thus the implementing function has full control
over what gets evaluated and when. For example:

\begin{verbatim}
MakeSpecialForm("if", "2|3", IfImpl)

func IfImpl(args *Data, env *SymbolTableFrame) (result *Data, err error) {
    c, err := Eval(First(args), env)
    if err != nil {
        return
    }

    if BooleanValue(c) {
        return Eval(Second(args), env)
    } else {
        return Eval(Third(args), env)
    }
}
\end{verbatim}

\subsection{Data}\label{sec:data}

The core lisp data element is the data type which logically contains a type tag and a value.
The type tags are defined by the constants: \verb|ConsCellType|, \verb|NumberType|,
\verb|BooleanType|, \verb|StringType|, \verb|SymbolType|, \verb|FunctionType|,
\verb|PrimitiveType|, \verb|ObjectType|. As the language evolves this list (and the
associated functions) will change. Refer to the file \verb|data.go| for
the definitive information.

The types are described earlier. If you need to check the type of a piece of data you can
fetch it’s type using the \verb|TypeOf(*Data) uint32| function and then compare it to a type
tag constant. Additionally there are predicate functions for the most common types that have
the general form:


\end{document}
